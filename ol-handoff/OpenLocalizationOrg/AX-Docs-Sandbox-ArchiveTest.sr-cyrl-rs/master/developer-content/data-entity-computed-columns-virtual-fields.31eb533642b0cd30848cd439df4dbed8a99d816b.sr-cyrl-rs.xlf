<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="sr-cyrl-rs">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-5a646d1" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">84d7477b61151fc4cb2486f4f468e1cd8d170c9a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dev-itpro\data-entities\data-entity-computed-columns-virtual-fields.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">developer-content</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8ecccdd36d0918f8561b47e9f7b763ee7237dd6e</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7c173333de3b12792f85b234c4b1c3b18f35ba31</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" extradata="MT" restype="x-metadata">
          <source>Compute columns and virtual fields in a data entity</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" restype="x-metadata">
          <source>This article provides information about computed and virtual fields, which are the two types of unmapped fields that a data entity can have.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" restype="x-metadata">
          <source>The article includes information about the properties of unmapped fields, and examples that show how to create, use, and test them.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Compute columns and virtual fields in a data entity</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This article provides information about computed and virtual fields, which are the two types of unmapped fields that a data entity can have.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The article includes information about the properties of unmapped fields, and examples that show how to create, use, and test them.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Overview</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>A data entity can have additional <bpt id="p1">*</bpt>unmapped<ept id="p1">*</ept> fields beyond those that are directly mapped to fields of the data sources.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>There are mechanisms for generating values for unmapped fields:</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Custom X++ code</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>SQL executed by Microsoft SQL Server</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The two types of unmapped fields are computed and virtual.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Unmapped fields always support read actions, but the feature specification might not require any development effort to support write actions.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Computed field</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Value is generated by an SQL view computed column.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>During read, data is computed by SQL and is fetched directly from the view.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For writes, custom X++ code must parse the input value and then write the parsed values to the regular fields of the data entity.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The values are stored in the regular fields of the data sources of the entity.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Computed fields are used mostly for reads.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>If possible, it's a good idea to use computed columns instead of virtual fields, because they are computed at the SQL Server level, whereas, virtual fields are computed row by row in X++.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Virtual field</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Is a non-persisted field.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Is controlled by custom X++ code.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Read and write happens through custom X++ code.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Virtual fields are typically used for intake values that are calculated by using X++ code and can't be replaced by computed columns.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Properties of unmapped fields</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Category</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Name</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Type</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Default value</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Behavior</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Data</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>IsComputedField</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>NoYes</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Yes</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;strong&gt;</bpt>Yes<ept id="p1">&lt;/strong&gt;</ept> – The field is synchronized as a SQL view computed column.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Requires an X++ method to compute the SQL definition string for the column.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The virtual column definition is static and is used when the entity is synchronized.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>After that, the X++ method is not called at run time.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;strong&gt;</bpt>No<ept id="p1">&lt;/strong&gt;</ept> – The field is a true virtual field, where inbound and outbound values are fully controlled through custom code.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Data</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>ComputedFieldMethod</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>String</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>A static <bpt id="p1">&lt;strong&gt;</bpt>DataEntity<ept id="p1">&lt;/strong&gt;</ept> method in X++ to build the SQL expression that will generate the field definition.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>This property is disabled and irrelevant if the property <bpt id="p1">&lt;strong&gt;</bpt>IsComputedField<ept id="p1">&lt;/strong&gt;</ept> is set to <bpt id="p2">&lt;strong&gt;</bpt>No<ept id="p2">&lt;/strong&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The method is required if the property <bpt id="p1">&lt;strong&gt;</bpt>IsComputedField<ept id="p1">&lt;/strong&gt;</ept> is set to <bpt id="p2">&lt;strong&gt;</bpt>Yes<ept id="p2">&lt;/strong&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Data</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>ExtendedDataType</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>String</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Example: Create a computed field</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>In this example, you add a computed field to the <bpt id="p1">**</bpt>FMCustomerEntity<ept id="p1">**</ept> entity.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>For reads, the field combines the name and address of the customer into a nice format.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For writes, your X++ code parses the combined value into its separate name and address values, and then the code updates the regular name and address fields.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>In Microsoft Visual Studio, right-click your project, and add the existing <bpt id="p1">**</bpt>FMCustomerEntity<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>In Solution Explorer, right-click the <bpt id="p1">**</bpt>FMCustomerEntity<ept id="p1">**</ept> node, and then click <bpt id="p2">**</bpt>Open<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>In the designer for <bpt id="p1">**</bpt>FMCustomerEntity<ept id="p1">**</ept>, right-click the <bpt id="p2">**</bpt>FMCustomerEntity<ept id="p2">**</ept> node, and then click <bpt id="p3">**</bpt>New<ept id="p3">**</ept> <ph id="ph1">&amp;gt;</ph> <bpt id="p4">**</bpt>String Unmapped Field<ept id="p4">**</ept>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">![</ph>Creating a new string unmapped field<ept id="p1">](./media/computedcolumnsandvirtualfields11.png)](./media/computedcolumnsandvirtualfields11.png)</ept></source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Rename the new field <bpt id="p1">**</bpt>NameAndAddress<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Update properties of the <bpt id="p1">**</bpt>NameAndAddress<ept id="p1">**</ept> unmapped field, as shown in the following screenshot.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">![</ph>Updating the properties of the NameAndAddress unmapped field<ept id="p1">](./media/computedcolumnsandvirtualfields21.png)](./media/computedcolumnsandvirtualfields21.png)</ept></source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Go to <bpt id="p1">**</bpt>FMCustomerEntity<ept id="p1">**</ept> <ph id="ph1">&amp;gt;</ph> <bpt id="p2">**</bpt>Methods<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Right-click the <bpt id="p1">**</bpt>Methods<ept id="p1">**</ept> node, and then click <bpt id="p2">**</bpt>New<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Ensure that the method name matches the <bpt id="p1">**</bpt>DataEntityView Method<ept id="p1">**</ept> property value of the unmapped computed field.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Paste the following X++ code into the method.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The method returns the combined and formatted <bpt id="p1">**</bpt>NameAndAddress<ept id="p1">**</ept> value.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note:<ept id="p1">**</ept> The <bpt id="p2">**</bpt>server<ept id="p2">**</ept> keyword is necessary.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>T-SQL for the computed column.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Tip:<ept id="p1">**</ept> If you receive error in data entity synchronization because of computed columns, it's easier to come up with the SQL definition in Microsoft SQL Server Management Studio (SSMS) before using it in X++.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Rebuild the project.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Synchronize the database.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Don't forget this step.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>You can do this by going to **Dynamics 365 **<ph id="ph1">&amp;gt;</ph> <bpt id="p1">**</bpt>Synchronize database<ept id="p1">**</ept> <ph id="ph2">&amp;gt;</ph> <bpt id="p2">**</bpt>Synchronize<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Example: Create a virtual field</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>In this example, you add a virtual field to the <bpt id="p1">**</bpt>FMCustomerEntity<ept id="p1">**</ept> entity.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>This field displays the full name as a combination of the last name and first name.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>X++ code generates the combined value.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>In the designer for the <bpt id="p1">**</bpt>FMCustomerEntity<ept id="p1">**</ept> entity, right-click the <bpt id="p2">**</bpt>Fields<ept id="p2">**</ept> node, and then click <bpt id="p3">**</bpt>New<ept id="p3">**</ept> <ph id="ph1">&amp;gt;</ph> <bpt id="p4">**</bpt>String Unmapped Field<ept id="p4">**</ept>.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>In the properties pane for the unmapped field, set the <bpt id="p1">**</bpt>Name<ept id="p1">**</ept> property to <bpt id="p2">**</bpt>FullName<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Set the <bpt id="p1">**</bpt>Is Computed Field<ept id="p1">**</ept> property to <bpt id="p2">**</bpt>No<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Notice that you leave the <bpt id="p1">**</bpt>DataEntityView Method<ept id="p1">**</ept> empty.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">![</ph>Setting the properties for the unmapped field<ept id="p1">](./media/computedcolumnsandvirtualfields31.png)](./media/computedcolumnsandvirtualfields31.png)</ept></source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">**</bpt>FMCustomerEntity<ept id="p1">**</ept> designer, right-click the <bpt id="p2">**</bpt>Methods<ept id="p2">**</ept> node, and then click <bpt id="p3">**</bpt>Override<ept id="p3">**</ept> <ph id="ph1">&amp;gt;</ph> <bpt id="p4">**</bpt>postLoad<ept id="p4">**</ept>.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Your X++ code in this method will generate the values for the virtual field.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Paste the following X++ code in for the <bpt id="p1">**</bpt>postLoad<ept id="p1">**</ept> override.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Notice that the <bpt id="p1">**</bpt>postLoad<ept id="p1">**</ept> method returns <bpt id="p2">**</bpt>void<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Compile your project.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Example: Use a virtual field to receive and parse an inbound field</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Imagine that an external system sends the name of a person as a compound value that combines the last and first names in one field that comes into our system.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>However, our system stores the last and first names separately.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>For this scenario, you can use the <bpt id="p1">**</bpt>FullName<ept id="p1">**</ept> virtual field that you created.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>In this example, the major addition is an override of the <bpt id="p1">**</bpt>mapEntityToDataSource<ept id="p1">**</ept> method.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>In the designer for the <bpt id="p1">**</bpt>FMCustomerEntity<ept id="p1">**</ept>, right-click the <bpt id="p2">**</bpt>Methods<ept id="p2">**</ept> node, and then click <bpt id="p3">**</bpt>Override<ept id="p3">**</ept> <ph id="ph1">&amp;gt;</ph> <bpt id="p4">**</bpt>mapEntityToDataSource<ept id="p4">**</ept>.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Paste the following X++ code in for the <bpt id="p1">**</bpt>mapEntityToDataSource<ept id="p1">**</ept> method.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note:<ept id="p1">**</ept> When <bpt id="p2">**</bpt>update<ept id="p2">**</ept> is called, <bpt id="p3">**</bpt>mapEntityToDataSource<ept id="p3">**</ept> methods are invoked for each data source.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Test the computed and virtual fields</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The following <bpt id="p1">**</bpt>main<ept id="p1">**</ept> method tests your computed and virtual fields.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Both fields are tested in a read action, and the virtual field is tested in an update action.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>For this example, ensure that you have the data set named <bpt id="p1">**</bpt>Fleet Management (migrated)<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The data set is available from the dashboard in the browser.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Click the menu icon in the upper-right corner, click the <bpt id="p1">**</bpt>APP LINKS<ept id="p1">**</ept> menu, and then scroll to find the data set named <bpt id="p2">**</bpt>Fleet Management (migrated)<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Paste the following X++ code into the startup object of your project.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Run your project.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>