<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="sr-cyrl-rs">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-5a646d1" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">90ab356cfae33f86149331f1eb3b85926ea9fef5</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dev-itpro\dev-tools\new-x-debugger-features.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">developer-content</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8d6a4dea97f7cb6716e2d0c553a5a078b085a90a</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f09eb9706ae9105e6eee48a1b1b728277ed0bf90</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" extradata="MT" restype="x-metadata">
          <source>X++ and debugger features</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" restype="x-metadata">
          <source>This tutorial is for developers to use advanced constructs of the X++ language and take advantage of productive debugger features.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" restype="x-metadata">
          <source>This is a walkthrough of the new features with exercises included to practice using these features.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>X++ and debugger features</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>This tutorial is for developers to use advanced constructs of the X++ language and take advantage of productive debugger features.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This is a walkthrough of the new features with exercises included to practice using these features.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>In previous versions, the X++ code was compiled into pseudo-code, or p-code, that was interpreted on the server or on the client application.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>This code was then subject to further compilation into CIL.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Today the story is much simpler--only CIL is supported, and this code is generated from a new compiler.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>In this tutorial, we’ll be discussing some of the new features that have been added to the X++ language.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>As we run through the scenarios, you’ll also see some of the new features in the debugger.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Declare anywhere</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Previously, all local variables had to be placed at the start of the method in which they’re used.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Now, you have fine-grained control over the scope of your variables.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>With this new feature, it’s possible to provide smaller scopes for variables, outside of which the variables can’t be referenced.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The lifetime of the variable is the scope in which it’s declared.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Scopes can be started at the block level (inside compound statements), in for statements, and in using statements as we will see below.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>There are several advantages to making scopes small.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Readability is enhanced.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>You can reduce the risk of reusing a variable inappropriately during long-term maintenance of the code.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Refactoring becomes much easier.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>You can copy code in without having to worry about variables being reused in contexts they shouldn’t.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>In this example, we declare the loop counter inside the 'for' statement in which it's used.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The scope of the variable is the for statement itself, including the condition expression and the loop update parts.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The value can’t be used outside this scope.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>If you attempt to do that, you will get the following.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The compiler will issue an error message in the info call: 'i' is not declared.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>There's another place where scopes can be established: the using statement, which is another newcomer to the X++ language.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>As a rule, when you use an IDisposable object, you should declare and instantiate it in a using statement.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The using statement calls the Dispose method on the object in the correct way, even if an exception occurs while you are calling methods on the object.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>You can achieve the same result by putting the object inside a try block, and then explicitly calling Dispose in a finally block; in fact, this is how the using statement is translated by the compiler.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Declarations can now be provided anywhere statements can be provided-- a declaration is syntactically a statement, a declaration statement.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>You can, therefore, provide declarations immediately prior to the usage.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>You don’t have to declare the variables all in one place.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The following sample shows some of the features described above.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>To avoid confusion, the X++ compiler will issue an error if you attempt to introduce a variable that would hide another variable in an enclosing scope or even in the same scope.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For instance, the following code will cause the compiler to issue the following diagnostic message: A local variable named 'i' cannot be declared in this scope because it would give a different meaning to 'i', which is already used in a parent or current scope to denote something else.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>This aligns well with the rules that are known from C<ph id="ph1">\#</ph>, but is different from the rule in C++ where shadowing is not diagnosed.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Exercise</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Adapt the code in FMVehicleInventoryServiceClass to use smaller scopes.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Static constructors and static fields</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Static constructors and static fields are new features in the X++ language.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Static constructors are guaranteed to run before any static or instance calls are made to the class.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>In C<ph id="ph1">\#</ph>, the concept of static relates to the whole executing application domain.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The execution of the static constructor is relative to the user’s session.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The static constructor has the following profile.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>You’ll never call the static constructor explicitly; the compiler will generate code to ensure that the constructor is called exactly once prior to any other method on the class.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>A static constructor is used to initialize any static data, or to perform a particular action that needs to be performed only once.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>No parameters can be provided for the static constructor, and it must be marked as static.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Static fields are fields that are declared using the static keyword.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Conceptually they apply to the class, not instances of the class.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>We'll show how a singleton, called instance in the example below, can be created by using the static constructor.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The singleton will guarantee that only one instance of the class will ever be called, which is consumed by the following.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Assignment of field members inline</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>It's now possible to assign a value to a field inline, i.e. along with the declaration of the field itself.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>This applies to both static and instance fields.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>In the following code, the values of field1 and field2 are defined in this fashion.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The code above has the same semantic meaning as: public class MyClass2 { int field1; str field2; void new() { this.field1 = 1; this.field2 = "Banana"; // …</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>} } The inline assignments work for both static and instance members.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Consts/Readonly</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The concept of macros continues to be fully supported in X++.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>However, using constants instead of <ph id="ph1">\#</ph>defines has a number of benefits.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>You can add a documentation comment to the const, not to the value of the macro.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Ultimately, the language service will pick this up and provide good information to the user.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The const is known by IntelliSense.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The const is cross referenced, so you can find all references of a particular constant.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>This is not the case for a macro.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The const is subject to access modifiers, either private, protected, or public.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The accessibility of macros is not well understood or even rigorously defined.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Consts have scope, while macros do not.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>You can see the value of consts and readonly variables in the debugger.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Macros that are defined in class scopes (in class declarations) are effectively available in all methods of all derived classes.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>This was originally a bug in the legacy compiler macro implementation, but this loophole is now massively exploited by application programmers.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The new X++ compiler still honors this, but no new code that uses this should be written.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This particular feature also considerably impacts compiler performance.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Constants can be declared at the class level as suggested below.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The constants can then be referenced by using the double-colon syntax.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>If you're in the scope of the class where the const is defined, you can omit the type name prefix (MyClass in the example above).</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>You can easily implement the concept of a macro library this way.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The list of macro symbols becomes a class with public const definitions.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Exercise</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The fleet application contains the FMDataHelper class that contains the following macro defintions.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Change these to const definitions and update the places where the macros are used accordingly.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>You can also define consts solely as variables.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The compiler will maintain the invariant that the value can't be modified.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Read-only fields can only be assigned a value once, and that value never changes; the field can be assigned its value either inline, at the place where the field is declared, or in the constructor.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Currently, that's the only difference between const and read-only.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Var</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>You can now declare a variable without explicitly providing the type of the variable, if the compiler can determine the type from the initialization expression.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Note that the variable is still strongly-typed into one, unambiguous type.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>It's only possible to use var on declarations where an initialization expressions are provided (from which the compiler will infer the type).</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>There are situations where this can make code easier to read, but this feature shouldn't be misused.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>You should consider the following rules:</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Use var to declare local variables when the type of the variable is obvious from the right side of the assignment, or when the precise type is not important.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Don't use var when the type isn't apparent from the initialization expression.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Use var for the declarations of for loop counters.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Use var for disposable objects inside using statements.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Private and protected member variables</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Previously, all member variables defined in a class were invariably protected.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>It's now possible to make the visibility of member variables explicit by adding the private, protected, and public keywords.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The interpretation of these modifiers is obvious and aligns with the semantics for methods:</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>A private member can only be used within the class where it's defined.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>a protected member can be used in the class where it's defined, and all subclasses thereof.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>A public member can be used anywhere: it's visible outside the confines of the class hierarchy in which it's defined.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The default for member variables that aren't adorned with an explicit modifier is still protected.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>You should make it a habit of explicitly specifying the visibility.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>As described, when a member variable is defined as public, it may be consumed outside of the class in which it's defined.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>In this case, a qualifier designating the object hosting the variable has to be specified, using the dot notation (as is the case for method calls).</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Reusing the code from above:</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>In this case, field1 is accessed using the explicit 'this.'</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>qualifier.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>: Making a member variable public may not be a good idea since it exposes the internal workings of the class to its consumers, creating a strong dependency between the class implementation and its consumers.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>You should always strive to only depend on a contract, not an implementation.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Finally in try/catch statements</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Try/catch statements can now include an optional finally clause.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The semantics are the same as they are in C<ph id="ph1">\#</ph> and other managed languages.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The statements in the finally clause are executed when control leaves the try block, either normally or through an exception.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Event handlers and Pre/Post methods</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>In legacy X++, it was possible to prescribe in metadata that certain methods were to be executed prior to and after the execution of a method.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The information about what subscribes call was recorded on the publisher, which isn't useful in the environment.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>It's now possible to provide Pre and Post handlers through code, by providing the SubscribesTo attribute on the subscribers.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>This example shows a publishing method called Publisher.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Two subscribers are enlisted with the PreHandlerFor and PostHandlerFor.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The code shows how to access the variables, and the return values.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>: This feature is provided for backward compatibility and, because the application code doesn't have many delegates, to publish important application events.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Pre and Post handlers can easily break as the result of added or removed parameters, changed parameter types, or because methods are no longer called, or called under different circumstances.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Attributes are also used for binding event handlers to delegates:</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>In this case, the SubscribesTo attribute specifies that the method RentalFinalizedEventHandler should be called when the FmRentalCheckoutProcessor.RentalTransactionAboutToBeFinalizedEvent delegate is called.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Since the binding between the publisher and subscribers is done through attributes, there's no way of specifying the sequence in which subscribers are called.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Extension methods</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The extension method feature lets you add extension methods to a target class by writing the methods in a separate extension class.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The following rules apply:</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The extension class must be static.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The name of the extension class must end with the ten-character suffix <ph id="ph1">\_</ph>Extension.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>However, there's no restriction on the part of the name that precedes the suffix.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Every extension method in the extension class must be declared as public static.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The first parameter in every extension method is the type that the extension method extends.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>However, when the extension method is called, the caller must not pass in anything for the first parameter.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Instead, the system automatically passes in the required object for the first parameter.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>It's perfectly valid to have private or protected static methods in an extension class.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>These are typically used for implementation details and are not exposed as extensions.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The example below illustrates an extension class holding a few extension methods:</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Why use extension methods?</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>The extension method technique doesn't affect the source code of the class it extends.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Therefore, the addition to the class can be done without over-layering.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Upgrades to the target class are never affected by any existing extension methods.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>However, if an upgrade to the target class adds a method that has the same name as your extension method, your extension method becomes unreachable through objects of the target class.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Extension methods are easy to use.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>The extension method technique uses the same dot-delimited syntax that you routinely use the call regular instance methods.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Extension methods can access all public artifacts of the target class, but they can't access things that are protected or private.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>In this way, extension methods can be seen as a kind of syntactic sugar.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Where can extension methods be applied?</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The target of an extension method must be one of the following application object types:</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Class</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>Table</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>View</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Map</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Regardless of the target type, an extension <bpt id="p1">*</bpt>class<ept id="p1">*</ept> is used to add extension methods to the type.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>For example, an extension table is <bpt id="p1">*</bpt>not<ept id="p1">*</ept> used to add methods to a table, and there's no such thing as an extension table.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Using clauses</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Previously, all references to managed artifacts that weren't authored in X++ was done using fully qualified names, including the namespace for each type.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>This is still possible, but you can now provide using clauses to make the use of such artifacts less onerous.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>As opposed to a using statement, each using clause precedes the class in which the clause is applied.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>It's also possible to provide aliases that introduce a short name for a fully qualified name.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>Aliases can denote namespaces and classes as shown below.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Consider the following code:</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Differences between legacy X++ and new X++</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>In this section, we'll see some of the differences between legacy X++ and the new X++.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Reals are Decimals</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>The type used to represent real values has changed from interpreted X++.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>This won't require you to rewrite any code, because the new type can express all of the values that the old one could.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>We provide this material in the interest of full disclosure only.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>All instances of the real type are now implemented as instances of the .NET decimal type (System.Decimal).</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Just as the real type in previous versions, the decimal type in a binary coded decimal type that, unlike floating point type, is resilient to rounding errors.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The range and resolution of the decimal type are different from the original types.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>The original X++ real type supported 16 digits and an exponent that defined where the decimal point is placed.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The new X++ real type can represent decimal numbers ranging from positive 79,228,162,514,264,337,593,543,950,335 (2⁹⁶-1) to negative 79,228,162,514,264,337,593,543,950,335 (-(2⁹⁶-1)).</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>The new real type doesn't eliminate the need for rounding.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>For example, the following code produces a result of 0.9999999999999999999999999999 instead of 1.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>This is readily seen when using the debugger to show the value of the variables below.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>No number of decimals will suffice to represent the value of 1/3 accurately.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>The discrepancy obtained here is due to the fact that only a finite number of decimals are provided.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>You should use the Round function to round to the number of decimals required.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Internal representation</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>A decimal number is a floating-point value that consists of a sign, a numeric value where each digit in the value ranges from 0 to 9, and a scaling factor that indicates the position of a floating decimal point that separates the integral and fractional parts of the numeric value.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>The binary representation of a real value consists of a 1-bit sign, a 96-bit integer number, and a scaling factor used to divide the 96-bit integer and specify what portion of it is a decimal fraction.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>The scaling factor is implicitly the number 10, raised to an exponent ranging from 0 to 28.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Therefore, the binary representation of a decimal value represents ((-2⁹⁶ to 2⁹⁶)/10(0<ph id="ph1">\\</ph> to<ph id="ph2">\\</ph> 28)), where -(2⁹⁶-1) is equal to the minimum value and 2⁹⁶-1 is equal to the maximum value that can be expressed.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>String truncation</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>String truncation is not a new feature.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>However, when code is executed in IL in previous versions, the automatic string truncation described here doesn’t take place.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>String values can be declared in X++ to contain a maximum number of characters.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Typically, this is achieved by encoding this information in an extended data type, as shown below: Credit card numbers cannot exceed 20 characters.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">![</ph>StringTruncationSolutionExplorer<ph id="ph2">\_</ph>DebugFeatures<ept id="p1">](./media/stringtruncationsolutionexplorer_debugfeatures.png)](./media/stringtruncationsolutionexplorer_debugfeatures.png)</ept> It's also possible to specify length constraints directly in the X++ syntax:</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>All assignments to these values are implicitly truncated to this maximum length.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Exercise</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Run the following code in the debugger by including it in a static main method:</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Casting</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>The previous version of X++ was very permissive in its treatment of type casting.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>Both up-casting and down-casting were allowed without intervention from the programmer.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Some of the casting permitted in legacy X++ can’t be implemented in the confines of the .NET runtime environment.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>In object oriented programming languages, including X++, casting refers to assignments between variables whose declared types are both in the same inheritance chain.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>A cast is either a down-cast or an up-cast.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>To set the stage for this discussion, we introduce a few self-explanatory class hierarchies: <bpt id="p1">[</bpt><ph id="ph1">![</ph>Casting<ph id="ph2">\_</ph>DebugFeatures<ept id="p1">](./media/casting_debugfeatures.png)](./media/casting_debugfeatures.png)</ept> As you can see, the MotorVehicle class isn't related to the Animal cast.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">**</bpt>up-cast<ept id="p1">**</ept> happens when assigning an expression of a derived type to a base type:</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>down-cast<ept id="p1">**</ept> happens when assigning an expression of a base type to a derived variable.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Both up-casts and down-casts are supported in X++.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>However, down-casts are dangerous and should be avoided whenever possible.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The example above will fail with an InvalidCastException at runtime, since the assignment doesn't make sense.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>X++ supports late binding on a handful of types, like object and formrun.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>This means that the compiler won't diagnose any errors at compile-time when it sees a method being called on those types, if that method isn't declared explicitly on the type,.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>It's assumed that the developer knows what they're doing.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>For instance, the following code may be found in a form.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The compiler can't check the parameters, return values, etc. for the MyMethod method, since this method isn't declared on the object class.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>At runtime, the call will be made using reflection, which is orders of magnitude slower than normal calls.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>note that calls to methods that are actually defined on the late binding types will be naturally checked.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>For example, the call to ToString():</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>will cause a compilation error:</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>because the ToString method is defined on the object class.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>There's one difference from the implementation of previous version of X++, related to the fact that methods could be called on unrelated objects, as long as the name of the method was correct, even if the parameter profiles weren't entirely correct.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>This isn't supported in CIL.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>Example</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>You should use the IS and AS operators liberally in your code.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>The IS operator can be used if the expression provided is of a particular type (including derived types); the AS operator will perform casting into the given type and return null if a cast isn't possible.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>Compiler diagnoses attempts to store objects in containers</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>In previous incarnations of the X++ compiler, it was possible to store object references into containers, even though this would fail at runtime.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>This is no longer possible.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>When the compiler sees an attempt to store an object reference into a container:</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>It will issue the error message:</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>If the type of the element that is added to the container is anytype the compiler can't make the determination of whether or not the value is a reference type.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>The compiler will allow this under the assumption that the user knows what they're doing.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>The compiler won't diagnose the following code as erroneous:</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>but an error will be thrown at runtime.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Cross company clause can contain arbitrary expressions</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>The crosscompany clause can be used on select statements to indicate the companies that the search statement should take into account.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The syntax hasn't been enhanced to allow arbitrary expressions (of type container) instead of a single identifier, which is a variable of type container.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Now, it's possible to provide the expression without having to use a variable for this purpose.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>The mkDate predefined function no longer accepts shorthand values</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>In legacy systems, it was possible to use "shorthand" values for the year argument of the mkDate function.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>The effect can be seen in the following code sample.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Running this code in the legacy system will produce the following values: 0 – 2000 1 – 2001 2 – 2002 …</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>27 – 2027 28 – 2028 29 – 2029 <bpt id="p1">**</bpt>30 – 2030<ept id="p1">**</ept> <bpt id="p2">**</bpt>31 – 1931<ept id="p2">**</ept> 32 – 1932 33 – 1933 …</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>97 – 1997 98 – 1998 <bpt id="p1">**</bpt>99 – 1999<ept id="p1">**</ept> <bpt id="p2">**</bpt>100 – 1900<ept id="p2">**</ept> We no longer support these values.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Attempts to use such values will cause the mkDate function to return the null date (1/1/1900).</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Obsolete statement types</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>The following statements are no longer supported.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>Pause and Window statements</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>The X++ pause statement is no longer supported because the pop-up <bpt id="p1">**</bpt>Print Window<ept id="p1">**</ept> that it affected has been removed.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>the pause and window statement were mainly used for debugging within the MorphX development environment, which was the same as the execution environment.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>Since the two are now separated, with Visual Studio taking the place of the MorphX environment, these statements are no longer relevant.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Print statement</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>The X++ print statement is another statement that existed only for debugging purposes.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>It still exists, and its basic idea is unchanged.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>But print now outputs through System.Diagnostics.WriteLine.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>The product configuration determines the detail of the written information is sent.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">![</ph>DebuggingAdmin<ph id="ph2">\_</ph>DebugFeatures<ept id="p1">](./media/debuggingadmin_debugfeatures.png)](./media/debuggingadmin_debugfeatures.png)</ept> You may find that using the Infolog is more compelling, since its output appears in the debugger and the running form.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>The Ignore list</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Since the legacy environment was all interpreted, it was possible to have some parts not compile, and use the rest.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>As long as you only called methods that compiled correctly, you were fine; however, you would run into trouble if you tried to call methods that weren't successfully compiled.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>This way of working doesn't work in CIL.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Assemblies are generated from successful compilations and the runtime system can't load incomplete assembles.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>However, there are legitimate scenarios when porting legacy applications into the new environment where it's beneficial to get things running in a staged fashion and where parts of the application need to be tested before everything is ported.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>While this is useful for this very limited scenario, it shouldn't be used once the application is ready for production, since you would be hiding problems that will occur at runtime, after the system has been deployed.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>This is how it currently works: You can specify a method in an XML by selecting, "Edit Best Practice Suppressions," from the context menu on the project.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>This will open an XML document where the exclusions are maintained.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>New Debugger features</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>This section provides information about the new features that we've added to the debugging experience in Visual Studio.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>Adding ToString methods to your classes</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>It's often a benefit to add ToString() methods to your classes.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>The effort spent doing this comes back many times and it's easy to do.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>This advice also holds true for legacy X++.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>: Since ToString methods can be called at unpredictable times, it isn't a good idea to change the state of the object here.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>Identifying unselected fields</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>It's a common source of bugs to use fields from a table when these fields don't appear in the field list in a select statement.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>Such fields will have a default value according to their type.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>It's now possible in the debugger to see if a value has been selected or not.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Exercise</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Consider the following code:</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Set a breakpoint on the assignment statement.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>Make your class the startup object in your project, and start by pressing F5.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>When the breakpoint is encountered, view the rental variable by expanding it in the locals window.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>You'll see something similar to the following graphic.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">![</ph>DebuggingAdmin2<ph id="ph2">\_</ph>DebugFeatures<ept id="p1">](./media/debuggingadmin2_debugfeatures.png)](./media/debuggingadmin2_debugfeatures.png)</ept> You can see that the fields that have been selected (EndMileage and RentalId) appear with their selected values, while the unselected fields appear as null.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>This signifies their value wasn't fetched from the database.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>Obviously, this is a debugging artifact.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>The values of the unselected fields will be the default value for the type of the field.</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>Step over this and notice how the debugger changes the rendering to the actual value.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>: If the table is set to Cache, the system will always fetch all fields from the entire table, irrespective of the field list provided in the code.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>The Auto and Infolog Windows</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>The debugger will allow you to easily access certain parts of the state of the application easily.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>This information is available in the autos window, where the current company, the partition, the transaction level, and the current user id are listed.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">![</ph>Autos<ph id="ph2">\_</ph>DebugFeatures<ept id="p1">](./media/autos_debugfeatures.png)](./media/autos_debugfeatures.png)</ept> There is also a window showing the data that is written to the Infolog.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">![</ph>Infolog<ph id="ph2">\_</ph>DebugFeatures<ept id="p1">](./media/infolog_debugfeatures.png)](./media/infolog_debugfeatures.png)</ept></source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>New breakpoint features</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>The Visual Studio debugger supports conditional breakpoints and breakpoints that are triggered by hit count.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>You can also have the system perform specific actions for you as you hit the breakpoint.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>None of these features were available in the legacy debugger.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>These are explained below:</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Hit count enables you to determine how many times the breakpoint is hit before the debugger breaks execution.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>By default, the debugger breaks execution every time that the breakpoint is hit.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>You can set a hit count to tell the debugger to break every 2 times the breakpoint is hit, or every 10 times, or every 512 times, or any other number you choose.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>Hit counts can be useful because some bugs don't appear the first time your program executes a loop, calls a function, or accesses a variable.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>Sometimes, the bug might not appear until the 100th or the 1000th iteration.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>To debug such a problem, you can set a breakpoint with a hit count of 100 or 1000.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>Condition is an expression that determines whether the breakpoint is hit or skipped.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>When the debugger reaches the breakpoint, it'll evaluate the condition.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>The breakpoint will be hit only if the condition is satisfied.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>You can use a condition with a location breakpoint to stop at a specified location only when a certain condition is true.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>For example, suppose you're debugging a banking program where the account balance is never allowed to go below zero.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>You might set breakpoints at certain locations in the code and attach a condition such as balance <ph id="ph1">&amp;lt;</ph> 0 to each one.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>When you run the program, execution will break at those locations only when the balance is less than zero.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>You can examine variables and program state at the first breakpoint location, and then continue execution to the second breakpoint location, and so on.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>Action specifies something that should occur when the breakpoint is hit.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>By default, the debugger breaks execution, but you can choose to print a message or run a Visual Studio macro instead.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>If you decide to print a message instead of breaking, the breakpoint has an effect very similar to a Trace statement.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>This method of using breakpoints is called tracepoints</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>Exercise</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>Consider the following code:</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>Put a breakpoint on the print statements by pressing F9 while that statement is selected.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>This will create a normal, unconditional breakpoint.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>Now, use the mouse to open the context menu for the breakpoint and select <bpt id="p1">**</bpt>Condition<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>Put in a condition that indicates that the breakpoint should happen when the value of the 'i' variable exceeds 5.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>Set the class as a startup project, and the class containing the code as the startup item in the project.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>Run the code.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>Feel free to modify the value of 'i' using the debugger.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>Now, remove this breakpoint, and use the Hit count feature to accomplish the same thing.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>: A breakpoint can have several conditions.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>It's often helpful to hover the cursor over the breakpoint, causing an informative tooltip to appear.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>Tracepoints are often useful tot race execution.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>Insert a tracepoint on the line in question and log the value of the variable.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>The trace output will appear in the output window in the debugger.</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>The immediate window</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>The immediate window is a useful feature in the VS debugger that allows the user to enter expression and statements to evaluate at any given time.</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>This feature isn't currently implemented in the X++ stack, as is the case for many other languages, notably F<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>However, that doesn't mean that the savvy user can't benefit from the immediate window.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>It just means that snippets must be expressed in C<ph id="ph1">\#</ph>, not in X++.</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>There's a separate document that describes the details of how this can be done to great effect.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>