<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="sr-cyrl-rs">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-5a646d1" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f7ed52aca4017f55066db9336a05d1fbc79587d3</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dev-itpro\extensibility\class-extensions.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">developer-content</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3ab926adeea92417cd31a010cd0e4a9fa4374c8c</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dc910f74e7e09d58d723af05243af7b029585ebc</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" extradata="MT" restype="x-metadata">
          <source>Class extensions</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" restype="x-metadata">
          <source>This article describes the new class extension model in X++.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Class extensions</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>This article describes the new class extension model in X++.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Because over-layering is a very intrusive feature, we recommend that you not use it â€“ at least not for cloud solutions.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The alternative to over-layering is extension.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Extension lets you extend existing artifacts in a new model.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Extensions are easier to maintain, but the amount of extension that can be done during customization is limited.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>There are rich ways to extend the metadata.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>For example, you can add new fields to a table.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>This article describes how X++ code can be extended, so that you can add methods and state to artifacts that are defined in other models without recompiling those models.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>A similar code extension mechanism already exists for X++ and is modeled after the corresponding feature in C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Under this mechanism, a class can be designated as an extension class through a naming convention and by hosting public static methods.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>In the existing feature, the type of the first argument that is passed to the extension method is the type to extend.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>What this article describes is the next step in that direction, which offers a more capable and natural extension story.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>In objected-oriented programming, the term <bpt id="p1">*</bpt>extend<ept id="p1">*</ept> has a well-defined meaning.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>If we say, "class B extends class A," we mean that B inherits from A, and the usual object-oriented rules are implied.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>In fact, this term is even used in the X++ syntax that is used in class declarations to express this relationship.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>At the same time, we use the term <bpt id="p1">*</bpt>extension<ept id="p1">*</ept> to talk about metadata that has contributions from several models.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>To avoid overloading the term <bpt id="p1">*</bpt>extend<ept id="p1">*</ept>, we will instead use the term <bpt id="p2">*</bpt>class augmentation<ept id="p2">*</ept> to designate the relationship between a class A in a base model and a class B in a model that depends on it, where B provides additional functionality to class A in the context of that model.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Nevertheless, we will also continue to use the term <bpt id="p1">*</bpt>extension class<ept id="p1">*</ept>, because it's prevalent.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The effective class concept</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>It's useful to have a term for a class that consists of the public members of the augmented artifact and all the public members of all the class extensions that augment that artifact.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>This class is called the effective class in a given model.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The following illustration shows an artifact, <bpt id="p1">**</bpt>MyArtifact<ept id="p1">**</ept>, that is defined in a base model, <bpt id="p2">**</bpt>MyModel<ept id="p2">**</ept>, and two dependent models that have extension classes for <bpt id="p3">**</bpt>MyArtifact<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">![</ph>Artifact MyArtifact that is defined in base model MyModel, and two dependent models that have extension classes for MyArtifact<ept id="p1">](./media/extensions-11.png)](./media/extensions-11.png)</ept> In this example, the effective class is the class in the extension models that contains all the original methods and all the public artifacts from the extension classes.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The effective class isn't the same in every model, because it includes only the class extensions that are defined in a given model.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The following illustration shows the effective class of <bpt id="p1">**</bpt>MyArtifact<ept id="p1">**</ept> in the <bpt id="p2">**</bpt>MyExtensionModel<ept id="p2">**</ept> model.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><ph id="ph1">![</ph>Effective class of MyArtifact in MyExtensionModel<ept id="p1">](./media/extensions-21.png)](./media/extensions-21.png)</ept> We will describe class extensions by using a class that is named <bpt id="p2">**</bpt>MyClass<ept id="p2">**</ept> in a model that is named <bpt id="p3">**</bpt>MyModel<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>We can add new methods and state to <bpt id="p1">**</bpt>MyClass<ept id="p1">**</ept> by introducing an extension class in the extension model (<bpt id="p2">**</bpt>MyExtensionModel<ept id="p2">**</ept>) that builds on top of (that is, has a dependency on) <bpt id="p3">**</bpt>MyModel<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Extension class declarations</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Extension classes are classes that are adorned with the <bpt id="p1">**</bpt>ExtensionOf<ept id="p1">**</ept> attribute and that also have a name that has the <bpt id="p2">**</bpt><ph id="ph1">\_</ph>Extension<ept id="p2">**</ept> suffix.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>(This restriction on the naming might be removed later.) The name of the extension class is otherwise unimportant.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The class augments the artifact that is specified in the <bpt id="p1">**</bpt>ExtensionOf<ept id="p1">**</ept> attribute, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Because the classes are instantiated by the runtime system, it's not meaningful to derive from the extension class.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Therefore, the extension class must be marked as <bpt id="p1">**</bpt>final<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>classStr<ept id="p1">**</ept> compile-time function must be used and has two purposes:</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>It produces a compilation error if the <bpt id="p1">**</bpt>MyClass<ept id="p1">**</ept> class doesn't exist.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The compile-time function that is used tells the compiler what kind of artifact is augmented.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Artifact names by themselves don't uniquely identify a given artifact to augment.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>For example, forms can have the same names as tables, classes, and enums.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Any number of extension classes can augment a given artifact in a particular model.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Extension classes are never referenced directly by the programmer, only by the runtime system.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Extension class inheritance</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Any class that inherits from an augmented class also inherits the effective class.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>In other words, the classes that inherit from a class that has extensions inherit the methods that are defined in the extension classes.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Constructors</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>X++ supports both instance constructors and static constructors.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Instance constructors</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The instance constructor is the method that is named <bpt id="p1">**</bpt>new<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The instance constructor that is defined in an extension class can't have parameters.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Instances of the extension classes are created, and the runtime system calls their constructors as required by the usage scenario.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>These constructors are never explicitly called by your code.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Constructors are useful for initializing the state of the extension objects.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>It's guaranteed that the constructor that is provided in an extension class will be called one time before any instance method or the instance state on the extension class is accessed.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>However, if no such references are made, the constructor isn't called.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Static constructors</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Static constructors are the parameter-less static methods that are named <bpt id="p1">**</bpt>typenew<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Static constructors can be defined on extension classes.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>It's guaranteed that the runtime system will call the constructor before the first reference to the extension type.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You can't assume any particular order of invocation for static construction among a set of extensions.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Methods</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The public methods that are defined in extension classes provide additional functionality to the augmented class in the context of the model where the extension class is defined.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Only public methods are exposed in this way.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>You can define private methods to help implement the public methods, but those private methods aren't part of the effective class.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Because extension classes are final, methods can't be marked as <bpt id="p1">**</bpt>protected<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Instance methods</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The following example defines an extension method that is named <bpt id="p1">**</bpt>ExtensionMethod<ept id="p1">**</ept> and that augments <bpt id="p2">**</bpt>MyClass<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The public instance method (<bpt id="p1">**</bpt>ExtensionMethod<ept id="p1">**</ept>) is defined in the extension class.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Therefore, it's available just as if it were defined in <bpt id="p1">**</bpt>MyClass<ept id="p1">**</ept> in the context of the model where the extension class is defined.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The following example shows how to call the method in the model.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Note that the instance method that is defined in the extension class is used as an instance method on the augmented artifact.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>An extension method can access public members only from the artifact that it augments.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>This behavior is by design.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>No artifact should be able to interact directly with state and methods that are explicitly hidden through the <bpt id="p1">**</bpt>private<ept id="p1">**</ept>, <bpt id="p2">**</bpt>internal<ept id="p2">**</ept>, or <bpt id="p3">**</bpt>protected<ept id="p3">**</ept> keywords.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Otherwise, direct interaction with explicitly hidden state and methods could cause malfunction by invalidating key implementation assumptions in those artifacts.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Methods and statements in the method body can use the <bpt id="p1">**</bpt>this<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>In this context, the type of <bpt id="p1">**</bpt>this<ept id="p1">**</ept> is the effective class of the augmented artifact.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Static methods</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Methods that are defined as public and static in the extension class are available as static methods on the artifact that is augmented.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The following example shows how to call the method in the model.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>A static method can access the public static methods and state in the effective class of the augmented artifact.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>As an interesting side effect, static extension methods on the <bpt id="p1">**</bpt>Global<ept id="p1">**</ept> class become available in the language as functions, which are available without any prefix.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>State</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>In addition to providing static and instance methods to an artifact, you can add instance state and static state.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Instance state</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Instance state, which is state that pertains to a particular instance of an artifact, can be specified on extension classes.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The following example defines a state that is named <bpt id="p1">**</bpt>state<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The following example shows how to use <bpt id="p1">**</bpt>state<ept id="p1">**</ept> in your code.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Static state</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Static state applies to the type instead of an instance of the type.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The following example shows a static extension state.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>