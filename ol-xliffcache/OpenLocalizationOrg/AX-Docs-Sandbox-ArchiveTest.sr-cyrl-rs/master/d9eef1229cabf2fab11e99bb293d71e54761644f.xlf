<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="sr-cyrl-rs">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-5a646d1" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d9eef1229cabf2fab11e99bb293d71e54761644f</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dev-itpro\dev-ref\xpp-operators.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">developer-content</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">bb267805252b89359412c0de3da4a638ac360de9</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4eb3cffd7dd22ba4b57e138872b71ff68c54463d</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" extradata="MT" restype="x-metadata">
          <source>X++ operators</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" restype="x-metadata">
          <source>This topic describes the operators supported in X++.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>X++ operators</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>This topic describes the operators supported in X++.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Assignment operators</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>An assignment changes the value of a variable or field.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The following table shows the X++ assignment operators.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>There is no difference between prefix and postfix operators.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Operator</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Assign the expression on the right of the equal sign to the variable on the left.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Assign the current variable value plus the expression on the right to the variable on the left.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Increment the variable by 1.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Assign the current variable value minus the expression on the right to the variable on the left.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Decrement the variable by 1.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Code examples for assignment operators</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Arithmetic operators</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>You use arithmetic operators to perform numeric calculations.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Most of the operators are binary and take two operands.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>However, the <bpt id="p1">**</bpt>not<ept id="p1">**</ept> (<bpt id="p2">**</bpt><ph id="ph1">~</ph><ept id="p2">**</ept>) operator is unary and takes only one operand.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Syntax for binary operators: <bpt id="p1">*</bpt>expression1<ept id="p1">*</ept> <bpt id="p2">*</bpt>ArithmeticOperator<ept id="p2">*</ept> <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept> Syntax for unary operators: <bpt id="p4">*</bpt>ArithmeticOperator<ept id="p4">*</ept> <bpt id="p5">*</bpt>expression1<ept id="p5">*</ept></source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Operator</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>left shift<ept id="p1">**</ept> operator performs <bpt id="p2">*</bpt>expression2<ept id="p2">*</ept> left shift (multiplication by 2) on <bpt id="p3">*</bpt>expression1<ept id="p3">*</ept>.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>right shift<ept id="p1">**</ept> operator performs <bpt id="p2">*</bpt>expression2<ept id="p2">*</ept> right shift (division by 2) on <bpt id="p3">*</bpt>expression1<ept id="p3">*</ept>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>multiply<ept id="p1">**</ept> operator multiplies <bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> by <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept>.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>divide<ept id="p1">**</ept> operator divides <bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> by <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept>.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>DIV</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>integer division<ept id="p1">**</ept> operator performs an integer division of <bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> by <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept>.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>MOD</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>integer remainder<ept id="p1">**</ept> operator returns the remainder of an integer division of <bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> by <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept>.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>not<ept id="p1">**</ept> operator, or unary operator, performs a binary not operation.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>binary AND<ept id="p1">**</ept> operator performs a binary and operation on <bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> and <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept>.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>binary XOR<ept id="p1">**</ept> operator performs a binary XOR-operation on <bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> and <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept>.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>&amp;#124;</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>binary OR<ept id="p1">**</ept> operator performs a binary or operation on <bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> and <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept>.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>plus<ept id="p1">**</ept> operator adds <bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> to <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept>.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>minus<ept id="p1">**</ept> operator subtracts <bpt id="p2">*</bpt>expression2<ept id="p2">*</ept> from <bpt id="p3">*</bpt>expression1<ept id="p3">*</ept>.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>?</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>ternary<ept id="p1">**</ept> operator takes three expressions: <bpt id="p2">*</bpt>expression1<ept id="p2">*</ept> ?</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>expression2<ept id="p1">*</ept> : <bpt id="p2">*</bpt>expression3<ept id="p2">*</ept>.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">*</bpt>expression1<ept id="p1">*</ept> is true, <bpt id="p2">*</bpt>expression2<ept id="p2">*</ept> is returned.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Otherwise, <bpt id="p1">*</bpt>expression3<ept id="p1">*</ept> is returned.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Code examples for arithmetic operators</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Expression operators</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>as<ept id="p1">**</ept> and <bpt id="p2">**</bpt>is<ept id="p2">**</ept> expression operators control downcast assignments.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Downcast assignments involve class or table inheritance.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Assignment statements that implicitly downcast can cause errors that are difficult to predict and diagnose.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>You can use the <bpt id="p1">**</bpt>as<ept id="p1">**</ept> keyword to make your downcasts explicit.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>You can use the <bpt id="p1">**</bpt>is<ept id="p1">**</ept> keyword to test whether a downcast is valid at run time.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The as keyword</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Use the <bpt id="p1">**</bpt>as<ept id="p1">**</ept> keyword for assignments that downcast from a base class variable to a derived class variable.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>as<ept id="p1">**</ept> keyword tells other programmers and the compiler that you believe that the downcast will be valid during run time.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The compiler reports an error for downcast assignment statements that lack the <bpt id="p1">**</bpt>as<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>At run time, the <bpt id="p1">**</bpt>as<ept id="p1">**</ept> keyword causes the downcast assignment statement to assign <bpt id="p2">**</bpt>null<ept id="p2">**</ept> if the downcast isn't valid.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>This <bpt id="p1">**</bpt>is<ept id="p1">**</ept> keyword is often used to safely test whether the <bpt id="p2">**</bpt>as<ept id="p2">**</ept> keyword will work.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Code example for the as keyword</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>In the following code example, the <bpt id="p1">**</bpt>DerivedClass<ept id="p1">**</ept> class extends the <bpt id="p2">**</bpt>BaseClass<ept id="p2">**</ept> class.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The code example contains two valid assignments between its <bpt id="p1">**</bpt>basec<ept id="p1">**</ept> and <bpt id="p2">**</bpt>derivedc<ept id="p2">**</ept> variables.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The upcast assignment to <bpt id="p1">**</bpt>basec<ept id="p1">**</ept> doesn't require the <bpt id="p2">**</bpt>as<ept id="p2">**</ept> keyword, but the downcast assignment to <bpt id="p3">**</bpt>derivedc<ept id="p3">**</ept> does require the <bpt id="p4">**</bpt>as<ept id="p4">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The following code will compile and run without errors.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The is keyword</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>is<ept id="p1">**</ept> keyword verifies whether an object is a subtype of a specified class.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>is<ept id="p1">**</ept> expression returns <bpt id="p2">**</bpt>true<ept id="p2">**</ept> if the object is a subtype of the class, or if the object is the same type as the class.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The compiler reports an error if an <bpt id="p1">**</bpt>is<ept id="p1">**</ept> keyword expression compares two types, but neither type is a subtype of the other, and they aren't of the same type.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The compiler reports a similar error for any plain assignment statement between two types, where neither type is a subtype of the other, and they aren't of the same type.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>At run time, the type of variable that references the underlying object is irrelevant to the <bpt id="p1">**</bpt>is<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>is<ept id="p1">**</ept> keyword causes the system to verify the object that the variable references, not the declared type of the variable that references the object.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Code examples for the is keyword</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The following code examples illustrate the conditions that control whether an <bpt id="p1">**</bpt>is<ept id="p1">**</ept> expression returns <bpt id="p2">**</bpt>true<ept id="p2">**</ept> or <bpt id="p3">**</bpt>false<ept id="p3">**</ept>.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The code examples depend on the fact that the <bpt id="p1">**</bpt>Form<ept id="p1">**</ept> class and the <bpt id="p2">**</bpt>Query<ept id="p2">**</ept> class both extend the <bpt id="p3">**</bpt>TreeNode<ept id="p3">**</ept> class.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Code example for the is and as keywords</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The following code example contains a typical use of the <bpt id="p1">**</bpt>is<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>as<ept id="p1">**</ept> keyword is used after the <bpt id="p2">**</bpt>is<ept id="p2">**</ept> keyword verifies that the <bpt id="p3">**</bpt>as<ept id="p3">**</ept> keyword will succeed.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>In this example, the <bpt id="p1">**</bpt>is<ept id="p1">**</ept> and <bpt id="p2">**</bpt>as<ept id="p2">**</ept> keywords are uppercase to make them more visible.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Object class as a special case</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Object<ept id="p1">**</ept> class can appear as a special case in inheritance functionality.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The compiler bypasses type checking for assignments to and from variables that are declared to be of type <bpt id="p1">**</bpt>Object<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Some classes inherit from the <bpt id="p1">**</bpt>Object<ept id="p1">**</ept> class, some classes inherit from another class, and some classes don't inherit from any class.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Although the <bpt id="p1">**</bpt>Dialog<ept id="p1">**</ept> class doesn't inherit from any class, the assignment and call statements in the following code example work.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>However, if the assignment is <bpt id="p1">**</bpt>bank4 = dlog3;<ept id="p1">**</ept>, it will fail at compile time, because the <bpt id="p2">**</bpt>Bank<ept id="p2">**</ept> and <bpt id="p3">**</bpt>Dialog<ept id="p3">**</ept> classes have no inheritance relationship to each other.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The compiler performs only one small validation on assignments to a variable that is declared to be of the <bpt id="p1">**</bpt>Object<ept id="p1">**</ept> class.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The compiler verifies that the item that is being assigned to the <bpt id="p1">**</bpt>Object<ept id="p1">**</ept> variable is an instance of a class.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>The compiler doesn't allow an instance of a table buffer to be assigned to the <bpt id="p1">**</bpt>Object<ept id="p1">**</ept> variable.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Additionally, the compiler doesn't allow primitive data types, such as <bpt id="p1">**</bpt>int<ept id="p1">**</ept> or <bpt id="p2">**</bpt>str<ept id="p2">**</ept>, to be assigned to the <bpt id="p3">**</bpt>Object<ept id="p3">**</ept> variable.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Tables</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>All tables inherit directly from the Common system table, unless they explicitly inherit from a different table.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The Common table can't be instantiated.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>It doesn't exist in the underlying physical database.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The Common table inherits from the <bpt id="p1">**</bpt>xRecord<ept id="p1">**</ept> class, but in a special way that isn't appropriate for the <bpt id="p2">**</bpt>is<ept id="p2">**</ept> keyword or the <bpt id="p3">**</bpt>as<ept id="p3">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>When the <bpt id="p1">**</bpt>as<ept id="p1">**</ept> keyword is used to perform an invalid downcast among tables, the target variable references an unusable non-null entity.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Any attempt to de-reference the target variable will cause an error that stops the program.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The is and as keywords and extended data types</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Each extended data type has an <bpt id="p1">**</bpt>Extends<ept id="p1">**</ept> property.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The style of inheritance that this property controls differs from the style of inheritance that the <bpt id="p1">**</bpt>is<ept id="p1">**</ept> and <bpt id="p2">**</bpt>as<ept id="p2">**</ept> keywords are designed for.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Relational operators</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The following table lists the relational operators that can be used in X++.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Most of the operators are binary and take two operands.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>However, the <bpt id="p1">**</bpt>not<ept id="p1">**</ept> (<bpt id="p2">**</bpt>!<ept id="p2">**</ept>) operator is unary and takes only one operand.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Syntax for binary operators: <bpt id="p1">*</bpt>expression1<ept id="p1">*</ept> <bpt id="p2">*</bpt>relationalOperator<ept id="p2">*</ept> <bpt id="p3">*</bpt>expression2<ept id="p3">*</ept> Syntax for unary operators: <bpt id="p4">*</bpt>relationalOperator<ept id="p4">*</ept> <bpt id="p5">*</bpt>expression1<ept id="p5">*</ept></source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Operator</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Description</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>like</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>like<ept id="p1">**</ept> relational operator returns <bpt id="p2">**</bpt>true<ept id="p2">**</ept> if <bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> is like <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept>.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>equal<ept id="p1">**</ept> relational operator returns <bpt id="p2">**</bpt>true<ept id="p2">**</ept> if both expressions are equal.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>greater than or equal to<ept id="p1">**</ept> relational operator returns <bpt id="p2">**</bpt>true<ept id="p2">**</ept> if <bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> is greater than or equal to <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept>.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>less than or equal to<ept id="p1">**</ept> relational operator returns <bpt id="p2">**</bpt>true<ept id="p2">**</ept> if <bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> is less than or equal to <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept>.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>greater than<ept id="p1">**</ept> relational operator returns <bpt id="p2">**</bpt>true<ept id="p2">**</ept> if <bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> is greater than <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept>.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>less than<ept id="p1">**</ept> relational operator returns <bpt id="p2">**</bpt>true<ept id="p2">**</ept> if <bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> is less than <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept>.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>!=</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>not equal<ept id="p1">**</ept> relational operator returns <bpt id="p2">**</bpt>true<ept id="p2">**</ept> if <bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> differs from (that is, if it isn't equal to) <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept>.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>and<ept id="p1">**</ept> relational operator returns <bpt id="p2">**</bpt>true<ept id="p2">**</ept> if both <bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> and <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept> are true.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>or<ept id="p1">**</ept> relational operator returns <bpt id="p2">**</bpt>true<ept id="p2">**</ept> if <bpt id="p3">*</bpt>expression1<ept id="p3">*</ept> or <bpt id="p4">*</bpt>expression2<ept id="p4">*</ept> is true, or if both are true.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>!</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>not<ept id="p1">**</ept> or <bpt id="p2">**</bpt>unary<ept id="p2">**</ept> relational operator negates the expression.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>It returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> if the expression is false and <bpt id="p2">**</bpt>false<ept id="p2">**</ept> if the expression is true.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The like operator</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>like<ept id="p1">**</ept> operator can use <bpt id="p2">**</bpt><ph id="ph1">\*</ph><ept id="p2">**</ept> as a wildcard character for zero or more characters, and <bpt id="p3">**</bpt>?<ept id="p3">**</ept></source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>as a wildcard character for one character.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The operand can't be longer than 1,000 characters.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>like<ept id="p1">**</ept> operator is evaluated by the underlying SQL, so the result might differ on different installations.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>If the expressions that you're comparing contain a file path, you must include four backslashes between each element, as shown in the following example.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>The equal (==) operator</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>When you use the <bpt id="p1">**</bpt>equal<ept id="p1">**</ept> (<bpt id="p2">**</bpt><ph id="ph1">==</ph><ept id="p2">**</ept>) operator to compare objects, the object references are compared, not the objects themselves.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>This behavior might cause issues if you compare two objects, one of which is located on the server, and the other of which is located on the client.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>In these cases, you should use the <bpt id="p1">**</bpt>equal<ept id="p1">**</ept> method in the <bpt id="p2">**</bpt>Object<ept id="p2">**</ept> class.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>You can override this method to specify what it means for two objects to be equal.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>If you don't override the <bpt id="p1">**</bpt>equal<ept id="p1">**</ept> method, the comparison is identical to the comparison that is done by the <bpt id="p2">**</bpt>equal<ept id="p2">**</ept> (<bpt id="p3">**</bpt><ph id="ph1">==</ph><ept id="p3">**</ept>) operator.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Code examples for relational operators</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Operator precedence</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The order that a compound expression is evaluated in can be important.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">**</bpt>(x + y / 100)<ept id="p1">**</ept> gives a different result, depending on whether the addition or the division is done first.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>You can use parentheses (<bpt id="p1">**</bpt>()<ept id="p1">**</ept>) to explicitly tell the compiler how it should evaluate an expression.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>For example, you can specify <bpt id="p1">**</bpt>(x + y) / 100<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>If you don't explicitly tell the compiler the order that you want operations to be done in, the order is based on the precedence that is assigned to the operators.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>For example, the division operator has higher precedence than the addition operator.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Therefore, for the expression <bpt id="p1">**</bpt>x + y / 100<ept id="p1">**</ept>, the compiler evaluates <bpt id="p2">**</bpt>y / 100<ept id="p2">**</ept> first.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>In other words,<ph id="ph1">` `</ph><bpt id="p1">**</bpt>x + y / 100<ept id="p1">**</ept> is equivalent to <bpt id="p2">**</bpt>x + (y / 100)<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>To make your code easy to read and maintain, be explicit.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Use parentheses to indicate which operators should be evaluated first.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The following table lists the operators in order of precedence.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The higher an operator appears in the table, the higher its precedence.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Operators that have higher precedence are evaluated before operators that have lower precedence.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Note that the operator precedence of X++ isn't the same as the operator precedence of other languages, such as C<ph id="ph1">\#</ph> and Java.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Operators, in order of precedence</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Syntax</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Unary</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>- ~ !</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Multiplicative, shift, bitwise <bpt id="p1">**</bpt>AND<ept id="p1">**</ept>, bitwise exclusive <bpt id="p2">**</bpt>OR<ept id="p2">**</ept></source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\*</ph> / % DIV <ph id="ph2">&amp;lt;</ph><ph id="ph3">&amp;lt;</ph> <ph id="ph4">&amp;gt;</ph><ph id="ph5">&amp;gt;</ph> &amp; ^</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Additive, bitwise inclusive <bpt id="p1">**</bpt>OR<ept id="p1">**</ept></source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>+ –</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Relational, equality</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&amp;lt;</ph> <ph id="ph2">&amp;lt;</ph>= == != <ph id="ph3">&amp;gt;</ph> <ph id="ph4">&amp;gt;</ph>= like as is</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Logical (<bpt id="p1">**</bpt>AND<ept id="p1">**</ept>, <bpt id="p2">**</bpt>OR<ept id="p2">**</ept>)</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Conditional</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>?</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>:</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Operators on the same line have equal precedence.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>If an expression includes more than one of these operators, it's evaluated from left to right, unless assignment operators are used.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>(Assignment operators are evaluated from right to left.) For example, <bpt id="p1">**</bpt><ph id="ph1">&amp;&amp;</ph><ept id="p1">**</ept> (logical <bpt id="p2">**</bpt>AND<ept id="p2">**</ept>) and <bpt id="p3">**</bpt><ph id="ph2">||</ph><ept id="p3">**</ept> (logical <bpt id="p4">**</bpt>OR<ept id="p4">**</ept>) have the same precedence, and are evaluated from left to right.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Therefore, <bpt id="p1">**</bpt>0&amp;&amp;0||1 == 1<ept id="p1">**</ept>, and <bpt id="p2">**</bpt>1||0&amp;&amp;0 == 0<ept id="p2">**</ept>.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>