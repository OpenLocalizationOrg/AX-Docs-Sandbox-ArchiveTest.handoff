{"content":"---\n# required metadata\n\ntitle: Intrusive customizations\ndescription: This topic defines the characteristics of an intrusive customization.\nauthor: MichaelFruergaardPontoppidan\nmanager: AnnBe\nms.date: 07/11/2017\nms.topic: article\nms.prod: \nms.service: dynamics-ax-platform\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \nms.reviewer: robinr\nms.search.scope: Operations, Platform, AX Platform\n# ms.tgt_pltfrm: \nms.custom: 89563\nms.assetid: \nms.search.region: Global\n# ms.search.industry: \nms.author: mfp\nms.search.validFrom: 2017-07-01\nms.dyn365.ops.version: Platform update 9\n---\n\n# Intrusive customizations\n\nThis topic defines the characteristics of an intrusive customization. Customizations that are implemented using overlayering are intrusive, and won't be supported as we go forward. Intrusive customizations are the major obstacle to continuous upgrades at upgrade and support costs that are close to zero. Some types of intrusive customizations can be prevented by tooling, whereas other types remain the responsibility of the author of the extension. The X++ compiler and Microsoft Visual Studio designers will prevent some types of intrusive customizations. However, a subset of intrusive customizations can't be detected by tooling but might still prevent continuous upgrades. Ultimately, the developer is responsible for avoiding intrusive customizations.\n\nA customization that violates any of the following principles is intrusive.\n\n# Don't change type definitions\nTypes are referenced by their definition. A change to a type’s definition is a breaking change and requires that all references be updated. It's impossible to guarantee that future references will be implemented correctly (for example, in the model that hosts the type). There are several implications:\n\n+ Don't change a method signature. The method signature includes the return type, the name (which includes casing), and the parameters (which include optional parameters).\n+ Don't change requirements for implementers of interfaces and table maps. For example, don't add a new method to an interface or a new field to a table map.\n+ Don't change requirements for classes that are derived from abstract classes. For example, don'tadd a new abstract method to a class.\n+ Don't reduce access modifiers for types or members. For example, don't change classes, tables, or methods from public to private.\n+ Don't change constraints that are defined on a table or a data entity. Restraints include allowing editing, mandatory constraints, uniqueness constraints, and referential constraints.\n\n# Don't break encapsulation\nThe author of a model must be able improve the product by remaining in control of encapsulated code and types. Model owners must be able to change and delete encapsulated code and types at will, without prior notice, and without risk of downstream impact on extensions and customizations. Encapsulation is broken if, for example a private method is deleted. Here are some of the implications:\n\n+ Don't increase access modifiers for types or members. For example, don't change classes, tables, or methods from private to public.\n+ If something should be closed for modification, don't open it for customizing behavior. Extension capabilities must be designed as open for extensibility but closed for modification.\n            \n# Be additive in nature\nNew behaviors are enabled through added functionality as part of extensions. Extension capabilities must be designed in and open for extensions, and they must support multiple extensions that exist side by side in the same installation. There are several implications:\n\n+ Don't overlayer. Overlayering replaces the default implementation and prevents multiple solutions from changing the same element.\n+ Don't significantly change the characteristics of the standard functionality. These characteristics include the user experience and performance. For example, performance must not be adversely affected if an extension is installed but isn't used.\n+ Don't unconditionally set results in **EventHandlerResult** classes, and don't unconditionally set return values in **XppPrePostArgs** classes.\n+ Don't replace existing behavior by default, unless the replacing logic conforms to the Liskov Substitution Principle.  \n\n> [!NOTE]\n> The author of the extension is responsible for not violating these principles.\n","nodes":[{"pos":[4,630],"embed":true,"restype":"x-metadata","content":"# required metadata\n\ntitle: Intrusive customizations\ndescription: This topic defines the characteristics of an intrusive customization.\nauthor: MichaelFruergaardPontoppidan\nmanager: AnnBe\nms.date: 07/11/2017\nms.topic: article\nms.prod: \nms.service: dynamics-ax-platform\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \nms.reviewer: robinr\nms.search.scope: Operations, Platform, AX Platform\n# ms.tgt_pltfrm: \nms.custom: 89563\nms.assetid: \nms.search.region: Global\n# ms.search.industry: \nms.author: mfp\nms.search.validFrom: 2017-07-01\nms.dyn365.ops.version: Platform update 9","nodes":[{"content":"Intrusive customizations","nodes":[{"pos":[0,24],"content":"Intrusive customizations","nodes":[{"content":"Intrusive customizations","pos":[0,24]}]}],"path":["title"],"extradata":"MT"},{"content":"This topic defines the characteristics of an intrusive customization.","nodes":[{"pos":[0,69],"content":"This topic defines the characteristics of an intrusive customization.","nodes":[{"content":"This topic defines the characteristics of an intrusive customization.","pos":[0,69]}]}],"path":["description"],"extradata":"MT"}],"header":"# required metadata\n","yml":true},{"pos":[638,662],"content":"Intrusive customizations","linkify":"Intrusive customizations","nodes":[{"content":"Intrusive customizations","pos":[0,24]}]},{"content":"This topic defines the characteristics of an intrusive customization.","pos":[664,733]},{"content":"Customizations that are implemented using overlayering are intrusive, and won't be supported as we go forward.","pos":[734,844]},{"content":"Intrusive customizations are the major obstacle to continuous upgrades at upgrade and support costs that are close to zero.","pos":[845,968]},{"content":"Some types of intrusive customizations can be prevented by tooling, whereas other types remain the responsibility of the author of the extension.","pos":[969,1114]},{"content":"The X++ compiler and Microsoft Visual Studio designers will prevent some types of intrusive customizations.","pos":[1115,1222]},{"content":"However, a subset of intrusive customizations can't be detected by tooling but might still prevent continuous upgrades.","pos":[1223,1342]},{"content":"Ultimately, the developer is responsible for avoiding intrusive customizations.","pos":[1343,1422]},{"content":"A customization that violates any of the following principles is intrusive.","pos":[1424,1499]},{"pos":[1503,1532],"content":"Don't change type definitions","linkify":"Don't change type definitions","nodes":[{"content":"Don't change type definitions","pos":[0,29]}]},{"content":"Types are referenced by their definition.","pos":[1533,1574]},{"content":"A change to a type’s definition is a breaking change and requires that all references be updated.","pos":[1575,1672]},{"content":"It's impossible to guarantee that future references will be implemented correctly (for example, in the model that hosts the type).","pos":[1673,1803]},{"content":"There are several implications:","pos":[1804,1835]},{"content":"Don't change a method signature.","pos":[1839,1871]},{"content":"The method signature includes the return type, the name (which includes casing), and the parameters (which include optional parameters).","pos":[1872,2008]},{"content":"Don't change requirements for implementers of interfaces and table maps.","pos":[2011,2083]},{"content":"For example, don't add a new method to an interface or a new field to a table map.","pos":[2084,2166]},{"content":"Don't change requirements for classes that are derived from abstract classes.","pos":[2169,2246]},{"content":"For example, don'tadd a new abstract method to a class.","pos":[2247,2302]},{"content":"Don't reduce access modifiers for types or members.","pos":[2305,2356]},{"content":"For example, don't change classes, tables, or methods from public to private.","pos":[2357,2434]},{"content":"Don't change constraints that are defined on a table or a data entity.","pos":[2437,2507]},{"content":"Restraints include allowing editing, mandatory constraints, uniqueness constraints, and referential constraints.","pos":[2508,2620]},{"pos":[2624,2649],"content":"Don't break encapsulation","linkify":"Don't break encapsulation","nodes":[{"content":"Don't break encapsulation","pos":[0,25]}]},{"content":"The author of a model must be able improve the product by remaining in control of encapsulated code and types.","pos":[2650,2760]},{"content":"Model owners must be able to change and delete encapsulated code and types at will, without prior notice, and without risk of downstream impact on extensions and customizations.","pos":[2761,2938]},{"content":"Encapsulation is broken if, for example a private method is deleted.","pos":[2939,3007]},{"content":"Here are some of the implications:","pos":[3008,3042]},{"content":"Don't increase access modifiers for types or members.","pos":[3046,3099]},{"content":"For example, don't change classes, tables, or methods from private to public.","pos":[3100,3177]},{"content":"If something should be closed for modification, don't open it for customizing behavior.","pos":[3180,3267]},{"content":"Extension capabilities must be designed as open for extensibility but closed for modification.","pos":[3268,3362]},{"pos":[3378,3399],"content":"Be additive in nature","linkify":"Be additive in nature","nodes":[{"content":"Be additive in nature","pos":[0,21]}]},{"content":"New behaviors are enabled through added functionality as part of extensions.","pos":[3400,3476]},{"content":"Extension capabilities must be designed in and open for extensions, and they must support multiple extensions that exist side by side in the same installation.","pos":[3477,3636]},{"content":"There are several implications:","pos":[3637,3668]},{"content":"Don't overlayer.","pos":[3672,3688]},{"content":"Overlayering replaces the default implementation and prevents multiple solutions from changing the same element.","pos":[3689,3801]},{"content":"Don't significantly change the characteristics of the standard functionality.","pos":[3804,3881]},{"content":"These characteristics include the user experience and performance.","pos":[3882,3948]},{"content":"For example, performance must not be adversely affected if an extension is installed but isn't used.","pos":[3949,4049]},{"pos":[4052,4195],"content":"Don't unconditionally set results in <bpt id=\"p1\">**</bpt>EventHandlerResult<ept id=\"p1\">**</ept> classes, and don't unconditionally set return values in <bpt id=\"p2\">**</bpt>XppPrePostArgs<ept id=\"p2\">**</ept> classes.","source":"Don't unconditionally set results in **EventHandlerResult** classes, and don't unconditionally set return values in **XppPrePostArgs** classes."},{"content":"Don't replace existing behavior by default, unless the replacing logic conforms to the Liskov Substitution Principle.","pos":[4198,4315]},{"pos":[4321,4409],"content":"[!NOTE]\nThe author of the extension is responsible for not violating these principles.","leadings":["","> "],"nodes":[{"content":"The author of the extension is responsible for not violating these principles.","pos":[8,86]}]}]}