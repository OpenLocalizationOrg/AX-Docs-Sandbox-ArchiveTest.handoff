{"content":"---\n# required metadata\n\ntitle: Authoring best practices\ndescription: This topic describes how you can author best practice rules in C#, for both metadata and X++ code. Best practice checks are run by the compiler and in daily builds to catch objectionable practices that are unacceptable in shipping code. The features can also be used to author simple one-of tools to gather information about the application.\nauthor: pvillads\nmanager: AnnBe\nms.date: 06/20/2017\nms.topic: article\nms.prod: \nms.service: dynamics-ax-platform\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \nms.reviewer: robinr\nms.search.scope: AX 7.0.0, Operations, UnifiedOperations\n# ms.tgt_pltfrm: \nms.custom: 48071\nms.assetid: 4fe671c4-c556-4942-8570-307cf68ae0a7\nms.search.region: Global\n# ms.search.industry: \nms.author: pvillads\nms.search.validFrom: 2016-02-28\nms.dyn365.ops.version: AX 7.0.0\n\n---\n\n# Authoring best practices\n\n[!include[banner](../includes/banner.md)]\n\n\nThis topic describes how you can author best practice rules in C#, for both metadata and X++ code. Best practice checks are run by the compiler and in daily builds to catch objectionable practices that are unacceptable in shipping code. The features can also be used to author simple one-of tools to gather information about the application.\n\nThis topic shows you how to author new best practice rules using the best practices framework. Best practice checks are run during development and in daily builds to catch coding practices that are deemed unacceptable in shipping code. Best practice rules are not restricted to this usage however; they can also be used to author simple one-of tools to gather information about the application. The framework is built on top of a managed framework called XLNT (shorthand for X++ LaNguage Toolkit) that can be used to build custom tools that extract information from, and modify, X++ code. There are two types of best practice rules: those that deal with metadata and those that deal with source code.\n\n## Code Best Practice framework\nThe Code Best Practice Framework (CBPF) enables you to write your own tools for analyzing X++ source code. These rules diagnose things that you consider to be problems with X++ source code. This section describes the foundation of the Best Practice functionality. This information is helpful for understanding the later sections that describe creating your own rules in greater detail. It is also helpful to developers who want to code rules that are more complex than those demonstrated in this document. The CBPF API is designed to allow you to focus on the rule you are expressing, without having to deal with infrastructure issues; you will not need to read tokens and piece them together to create something intelligible from them. Instead, the CBPF provides the following parts:\n\n-   A parser that builds an Abstract Syntax Tree (AST) from X++ source code.\n-   A pipeline that runs a sequence of passes over the X++ code.\n-   A number of prebuilt passes. The first pass is the parsing of the source code.\n-   Infrastructure to read metadata.\n\nBecause rules are based on ASTs, it is important to understand that concept before starting to write rules.\n\n### The parser and ASTs\n\nThe parser reads  X++ code and produces an AST from it if it does not contain egregious syntax errors. The parser has a built-in error recovery scheme, so it can recover from most syntax errors reasonably well. When a syntax error happens, the parser will read symbols until it encounters a semicolon, and then try to building the AST by unstacking its state until it reaches a state where a semicolon is a correct symbol. In addition, the parser is able to suggest the correct set of symbols when a syntax error occurs. The parser is not intended to be directly interacted with by consumers of the API, but should be considered a black box that works without user intervention. As the parser recognizes the language constructs in the source code, it builds an AST. The AST consists of nodes that are abstractions of the X++ artifact they represent. We will illustrate the concept by showing a few AST nodes below:\n\n    public abstract class Statement : Ast\n    {\n        /// <summary>\n        /// Gets or sets the comments in the statement\n        /// </summary>\n        public string Comments { get; set; }\n     \n        public abstract string ToString(int indent);\n    }\n\nThe Statement class is abstract; it does not make sense to instantiate a ”statement”; only concrete derived classes (like if statements, while statements etc.) can be instantiated. Since the Comments property is placed on this base class, it applies to all derived classes; in other words: all statements can have comments preceding the statement, which are accessible through the given property. There are many different kinds of statement in X++ and each one is described by a class derived in one or more steps from the abstract Statement class shown above. The following example shows the definition of a **while** statement.\n\n    public class WhileStatement : Statement\n    {\n        /// <summary>\n        /// Gets or sets the while condition.\n        /// </summary>\n        public Expression Condition { get; set; }\n     \n        /// <summary>\n        /// Gets or sets the constituent while statement.\n        /// </summary>\n        public Statement Statement { get; set; }\n    }\n\nThe **while** statement consists of the condition (an expression) and the constituent statement, that is executed as long as the condition evaluates to true. The parser will maintain the source code positions where the represented artifact starts and ends (i.e. its extent). As the ASTs are traversed it may be useful to add information to the individual nodes. For example, every expression has a type. As the tree is traversed to diagnose type compatibility problems it becomes useful to be able to place that information on the individual node. Rather than having to modify the AST nodes for each requirement, there is a property collection that can be used to provide name/value pairs to each node. Each AST node has a **ToString** method that will return a high fidelity string representation of the node, which is useful in debugging scenarios.\n\n### The AstSweeper class\n\nThe AstSweeper applies a visitor pattern to the AST instance that it is given. The visitor pattern allows the programmer to separate the underlying data structure (i.e. the AST) from the operations that the user wants to perform on the nodes (i.e. the logic reasoning about the code). The **AstSweeper** class has a virtual method for each of the AST node types, and it will call them as directed by the structure of the AST. The following examples shows how the sweeper works. Some details have been omitted for clarity.\n\n    /// <summary>The AST sweeper visits each node in the AST</summary>\n    /// <typeparm name=\"TReturn\">The type returned by each of the sweeper methods</typeparm>\n    /// <typeparm name=\"TPayload\">\n    /// The type of the payload passed to each of the sweeper methods\n    /// </typeparm>\n    public class AstSweeper<TReturn, TPayload> where TReturn : class\n    {\n        protected virtual TReturn VisitStatement(TPayload o, Statement statement)\n        {\n            var compoundStatement = statement as CompoundStatement;\n            if (compoundStatement != null)\n            {\n                return this.VisitCompoundStatement(o, compoundStatement);\n            }\n     \n            var whileStatement = statement as WhileStatement;\n            if (whileStatement != null)\n            {\n                return this.VisitWhileStatement(o, whileStatement);\n            }\n        }\n     \n        protected virtual TReturn VisitWhileStatement(TPayload o, WhileStatement statement)\n        {\n            this.VisitExpression(statement.Condition);\n            this.VisitStatement(statement.Statement);\n     \n            return null;\n        }\n    }\n\nThe name of the virtual method handling a particular AST node is the name of the AST class prepended with Visit. The parameters are the node to visit and a payload that may be passed to all the visitors as they are called. In this way, the sweeper will call the virtual method once for each and every one of the nodes in the AST that is passed to it in a depth-first traversal. The payload parameter can be used to pass information (e.g. a symbol table) to each node as required. Developers will build classes derived from the AstSweeper class, overriding the methods of particular interest to them.\n\n#### Example\n\nSuppose you need to determine the percentage of parameter names starting with an underscore character, thus conforming to the X++ coding guidelines. You would then write a class deriving from the **AstSweeper** class with logic that calculated the number of parameters and the number of parameters starting with underscore. The following example shows this code.\n\n    public class ParameterCounter : AstSweeper<object, object>\n    {\n        /// <summary>\n        /// The parameter count maintained as the methods are encountered.\n        /// </summary>\n        public int ParameterCount { get; set; }\n     \n        /// <summary>\n        /// The number of parameters that start with an underscore character.\n        /// </summary>\n        public int UnderscoredParameters { get; set; }\n     \n        /// <summary>\n        /// Visits the method parameters.\n        /// </summary>\n        /// <param name=\"o\">The payload. Not used in this scenario.</param>\n        /// <param name=\"parameters\">The list of parameters to visit.</param>\n        /// <returns>The method parameters.</returns>\n        protected override object VisitMethodParameters(object o,\n            IEnumerable<ParameterDeclaration> parameters)\n        {\n            this.ParameterCount += parameters.Count();\n            this.UnderscoredParameters += parameters\n                .Where(p => p.Name.StartsWith(\"_\")).Count();\n     \n            return null;\n        }\n    }\n\nIn this case, the tally is maintained in the **ParametersCount** and **UnderscoredParameters** properties that are defined in the class scope. Another equally valid approach would be to pass this information into the payload that is passed to all the **Visit** methods. In most cases, the user should unconditionally call super() from the overridden method to make sure that the Visit methods are called for all nodes below the one being visited. In the case above it does not make a difference so we opt to improve performance by pruning the AST tree traversal.\n\n### Writing code for Best Practice rules\n\nNow that the concepts have been introduced, we are ready to author business rules. Basically you need to:\n\n1.  Define the situation you want to diagnose in terms of properties of the AST. You will write **Visit\\*** methods that can do the analysis.\n2.  When the error condition has been found, a diagnostic message must be generated. There is an API that is used for this purpose; basically you need to write some boilerplate code for each diagnostic message.\n3.  You need to hook your new best practice rule into the rest of the framework, so the user can decide whether or not to include your rule in his work and to actually run it if so directed.\n\n### Create a best practice rules project in Visual Studio\n\nIn this walkthrough we imagine the following scenario:\n\n1.  Some methods are adorned with an Author attribute, that provides the name of the individual who wrote the code. This is useful when finding who to point the finger at when stack traces containing that method appear.\n2.  Since we have a significant turnaround of developers, the names of the developers listed cannot be static. We want to check which names are used in the Author attributes, and match them against a list of names of current developers.\n\nThe author attribute class is simply defined as:\n\n    class AuthorAttribute extends SysAttribute\n    {\n        private str theAuthor;\n     \n        public void new(str _author) \n        {\n            this.theAuthor = _author;\n        }\n    }\n\nIn production code we would put in documentation comments and assertions to validate key assumptions about parameter values etc. For the sake of clarity, we omit these steps in this walkthrough, where the code is written for clarity. Now that we have set the stage for what we want to achieve, we can start up Visual Studio and create a best practice rules project. Provide a meaningful name that properly conveys what the rules are intended to do: Visual Studio creates a project with some source code snippets and project references set up. You can save considerable time by using this source code as a starting point for your own code. The pre-canned example contains rules that prohibits the word “Microsoft” in any method names (presumably for copyright reasons) and a metadata based rule prohibiting certain characters in names. Since we are not concerned with the metadata checks for now, you can delete the InvalidCharactersDiagnosticItem.cs and DemoMetadataCheck.cs files from the project. Also, since we are not interested in the Microsoft name check, go ahead and delete the content of the VisitMethod method in the DemoAST class. The first thing we need to do is to find out if there are one or more Author attributes for a particular method. You will notice that the Method type (that is passed as a parameter to the VisitMethod method) has an Attributes property of type AttributeList. Let's use it to see if any Author attributes are defined on this method:\n\n    protected override object VisitMethod(BestPracticeCheckerPayload payload, Method method)\n     {\n         var names = new List<string>();\n         foreach (var attribute in method.Attributes.Attributes)\n         {\n             if (string.Compare(attribute.Name, \"Author\",\n                     ignoreCase: true, culture: CultureInfo.InvariantCulture) == 0)\n             {\n                 var authorNameLiteral = attribute.Parameters.First().Literal as StringAttributeLiteral;\n                 // The name contains quotes (either single or double). Get rid of those\n                 var authorName = authorNameLiteral.Value.Trim('\\'', '\"');\n                 names.Add(authorName);\n             }\n         }\n     \n         // More to come...\n         return null;\n     }\n\nAt this point we have looped through any attributes, and collected a list of author names, i.e. names that are provided as the first parameters to the Author attributes. Now we need to compare the list against a list of acceptable authors, that we maintain in a static list. Whenever an author is provided that is not mentioned in the list we need to issue an appropriate diagnostic message. At this time, we have something like:\n\n    public class AuthorListRule : BestPracticeAstChecker<BestPracticeCheckerPayload>\n    {\n        private static HashSet<string> authorlist = new HashSet<string>()\n        {\n            \"Alan Kay\", \"John von Neuman\", \"C.A.R. Hoare\"\n        };\n     \n        public AuthorListRule() : base()\n        {\n        }\n     \n        protected override object VisitMethod(BestPracticeCheckerPayload payload, Method method)\n        {\n            var names = new List<string>();\n            foreach (var attribute in method.Attributes.Attributes)\n            {\n                if (string.Compare(attribute.Name, \"Author\",\n                        ignoreCase: true, culture: CultureInfo.InvariantCulture) == 0)\n                {\n                    var authorNameLiteral = attribute.Parameters.First().Literal as StringAttributeLiteral;\n                    // The name contains quotes (either single or double). Get rid of those\n                    var authorName = authorNameLiteral.Value.Trim('\\'', '\"');\n                    names.Add(authorName);\n                }\n            }\n     \n            foreach (var name in names)\n            {\n                if (!authorlist.Contains(name))\n                {\n                    // TODO: Add a diagnostic message\n                }\n            }\n            return null;\n        }\n    }\n\nIn other words, we need to create an diagnostic message to let the user know about the transgression of the rule. As noted before, it is important to call the base implementation of your visitor, which will then call visitor methods for all the nodes that are contained in the method. However, in this case, we do not want to do any further processing once we have determined if the author attribute is on the list.\n\n### Add a class for the diagnostic message\n\nThe project already includes boilerplate code for an error message, so we will use that as our starting point to create the diagnostic message that will be returned if the rule is violated. Each message is implemented as a class of its own. Each error message may have any amount of contextual information encoded into it. In this case, the contextual information is the name of the author that is not found in the list. We will start by adding the message to the messages resource file: Open that file in the project and add a string to it. We will use the name (also known as the error moniker) AuthorNotCurrent. The ‘{0}’ string is a placeholder for the contextual information, in this case the name of the author who is not in the list. In addition to the actual text that will appear in the error message, there is also a string containing a description of the rule; this information is shown in the best practice dialog within Visual Studio and is designed to help the user decide which rules he wants to enable on his system. Create a class for the diagnostic message, and call it AuthorNotCurrentDiagnosticItem.cs. Add the following code inspired from the NotAllowedWordDiagnosticItem class.\n\n    namespace CompareAuthorsToList\n    {\n        using System;\n        using System.Collections.Generic;\n        using System.Runtime.Serialization;\n        using System.Xml.Linq;\n        using Microsoft.Dynamics.AX.Metadata.XppCompiler;\n     \n        [DataContract]\n        public class AuthorNotCurrentDiagnosticItem : CustomDiagnosticItem\n        {\n            private const string AuthorNotCurrentKey = \"Author\";\n            public const string DiagnosticMoniker = \"AuthorNotCurrent\";\n     \n            public AuthorNotCurrentDiagnosticItem(string path, string elementType, TextPosition textPosition, string author)\n                : base(path, elementType, textPosition, DiagnosticType.BestPractices, Severity.Warning, DiagnosticMoniker, Messages.AuthorNotCurrent, author)\n            {\n                this.AuthorNotCurrent = author;\n            }\n     \n            public AuthorNotCurrentDiagnosticItem(Stack<Ast> context, TextPosition textPosition, string author)\n                : base(context, textPosition, DiagnosticType.BestPractices, Severity.Warning, DiagnosticMoniker, Messages.AuthorNotCurrent, author)\n            {\n                this.AuthorNotCurrent = author;\n            }\n     \n            // Serialization support\n            public AuthorNotCurrentDiagnosticItem(XElement element)\n                : base(element)\n            {\n            }\n     \n            [DataMember]\n            public string AuthorNotCurrent { get; private set; }\n     \n            /// <summary>\n            /// Hydrate the diagnostic item from the given XML element.\n            /// </summary>\n            /// <param name=\"itemSpecificNode\">The XML element containing the diagnostic.</param>\n            protected override void ReadItemSpecificFields(System.Xml.Linq.XElement itemSpecificNode)\n            {\n                this.AuthorNotCurrent = base.ReadCustomField(itemSpecificNode, AuthorNotCurrentKey);\n            }\n     \n            /// <summary>\n            /// Write the state into the given XML element.\n            /// </summary>\n            /// <param name=\"itemSpecificNode\">The element into which the state is persisted.</param>\n            protected override void WriteItemSpecificFields(System.Xml.Linq.XElement itemSpecificNode)\n            {\n                this.WriteCustomField(itemSpecificNode, AuthorNotCurrentKey, this.AuthorNotCurrent);\n            }\n        }\n    }\n\nThe diagnostic message is ready for consumption. There is just one piece of bookkeeping that needs to be done; the rule needs to publish declaratively which diagnostics it potentially issues. Go back to your rule and modify the BestPracticeRule attribute to reflect the new diagnostic message:\n\n    [BestPracticeRule(\n        AuthorNotCurrentDiagnosticItem.DiagnosticMoniker,\n        typeof(Messages),\n        AuthorNotCurrentDiagnosticItem.DiagnosticMoniker + \"Description\",\n        BestPracticeCheckerTargets.Class)]\n    public class AuthorListRule : BestPracticeAstChecker<BestPracticeCheckerPayload>\n    { ... }\n\nAs you can see, there are four parameters specified for the **BestPracticeRule** attribute:\n\n1.  The rule moniker.\n2.  The type of the resource file holding the rule description. In this example we are using the default resource file named Messages, which created a class called Messages. We want the type of this class as the second argument.\n3.  The name of the string resource that contains the description of the rule. This is the string called **AuthorNotCurrentDescription** that we added to the resource file above; it contains a human legible string to describe the rule. This string is used to describe the rule to the user in a best practice dialog within Visual Studio. In Visual Studio, select **Dynamics 365 &gt; Best Practices Configuration** to view the dialog.\n4.  A description of the artifacts to check. In our case the value specifies that the rule should only be applied to classes. Feel free to modify this to your needs by using one of the other literals in the BestPracticeCheckerTargets enumeration.\n\nWe still need to fill out the pending TODO item, that is now reduced to instantiating the class that describes the diagnostic message and adding it to the set of diagnostics:\n\n    foreach (var name in names)\n    {\n        if (!authorlist.Contains(name))\n        {\n            // Create the custom error message, including\n            // the contextual name information...\n            var warning = new AuthorNotCurrentDiagnosticItem(\n                this.Context, method.Position, name);\n     \n            // and add it to the set of reported messages.\n            this.ExtensionContext.AddErrorMessage(warning);\n        }\n    }\n\nAt this point you have a complete best practice rule, ready to provide value in your organization. Go ahead and build it and fix any errors that may have crept in.\n\n## Metadata based Best Practice rules\nUntil now we have been describing how to write rules that deal with code. In this section we show how to author rules that apply to metadata, not code. Classes that deal with metadata rules are derived from **BestPracticeMetadataChecker.** The derived instance receives an instance of the metadata describing the artifact that must be checked. You then use the APIs in the Microsoft.Dynamics.AX.Metadata.Metamodel to fetch further metadata as needed, and use LINQ queries over the metadata graphs. The template for best practice checks contains a class performing metadata checks as well as a code based one we discussed in the previous section. The mechanics involved in issuing diagnostic messages is the same as we covered above.\n\n## Install, run, and test your rule\nWhen your code compiles cleanly, a DLL will be created. In order for the tooling to be able to pick up the new rule, this DLL must be installed before running it. Installing the DLL can be done in two ways:\n\n-   By using the button on the Best Practice configuration dialog. Click the **Install extension...** button. You will be asked to point to the assembly file that contains your rule (i.e. the DLL generated when you build the rule). Press OK, and the system will copy the DLL where it needs to be (see below).\n-   By manually installing the DLL into the C:\\\\Packages\\\\bin\\\\BPExtensions folder.\n\nIf you want to debug your rule, you will find it useful to copy the .pdb file to the same directory as the assembly After the DLL has been deployed to the target directory, Visual Studio needs to be restarted. After that, the rule is available for use. You may have to debug your rule to iron out any remaining kinks. In fact stepping through your rule and inspecting the ASTs is valuable when you are learning the ropes. To debug a rule you need to know that the best practice rule is actually executed by the xppAgent process; it is therefore not run within the context of VS itself. Make sure you have selected **Run best practice checks** in the Visual Studio Options dialog, in the **Finance and Operations** page. Otherwise, your check will not run.   Set a breakpoint in the **VisitMethod** method, and then do a build of a model that has the new rule switched on as shown above for the Fleet management model. Attach your VS instance to the xppcAgent process. When you do a build your breakpoint will be hit, and you can start drilling into your code. You can see all the properties, the list of declarations and statements, and find out all the details about them.\n\n### Running rules in XppBp.exe\n\nAs described above the best practice rules are often run as part of the build of a project from Visual Studio, but there is also a dedicated command line tool to run them. This is the xppbp.exe tool, and it is intended mainly for nightly build scenarios. Invoking it from the command line yields a useful overview of the command line switches and arguments. Here are some useful examples:\n\n-   Run BP on all forms in a module: `xppbp -module:FleetManagement form:*`\n-   Run BP on specific elements: `xppbp -module:FleetManagement class:MyClass form:MyForm`\n-   Run BP on all items in the model (and only for this one model in the module): `xppbp -module:FleetManagement -model:FleetManagement –all`\n-   Run BP on all items in all models in the module: `xppbp -module:FleetManagement –all`\n-   Write the output to log files: `xppbp -module:FleetManagement -all -xmllog=Log.xml -log=Log.txt`\n\n\n\n\n\n","nodes":[{"pos":[4,921],"embed":true,"restype":"x-metadata","content":"# required metadata\n\ntitle: Authoring best practices\ndescription: This topic describes how you can author best practice rules in C#, for both metadata and X++ code. Best practice checks are run by the compiler and in daily builds to catch objectionable practices that are unacceptable in shipping code. The features can also be used to author simple one-of tools to gather information about the application.\nauthor: pvillads\nmanager: AnnBe\nms.date: 06/20/2017\nms.topic: article\nms.prod: \nms.service: dynamics-ax-platform\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \nms.reviewer: robinr\nms.search.scope: AX 7.0.0, Operations, UnifiedOperations\n# ms.tgt_pltfrm: \nms.custom: 48071\nms.assetid: 4fe671c4-c556-4942-8570-307cf68ae0a7\nms.search.region: Global\n# ms.search.industry: \nms.author: pvillads\nms.search.validFrom: 2016-02-28\nms.dyn365.ops.version: AX 7.0.0\n","nodes":[{"content":"Authoring best practices","nodes":[{"pos":[0,24],"content":"Authoring best practices","nodes":[{"content":"Authoring best practices","pos":[0,24]}]}],"path":["title"],"extradata":"MT"},{"content":"This topic describes how you can author best practice rules in C#, for both metadata and X++ code. Best practice checks are run by the compiler and in daily builds to catch objectionable practices that are unacceptable in shipping code. The features can also be used to author simple one-of tools to gather information about the application.","nodes":[{"pos":[0,341],"content":"This topic describes how you can author best practice rules in C#, for both metadata and X++ code. Best practice checks are run by the compiler and in daily builds to catch objectionable practices that are unacceptable in shipping code. The features can also be used to author simple one-of tools to gather information about the application.","nodes":[{"content":"This topic describes how you can author best practice rules in C#, for both metadata and X++ code. Best practice checks are run by the compiler and in daily builds to catch objectionable practices that are unacceptable in shipping code. The features can also be used to author simple one-of tools to gather information about the application.","pos":[0,341],"nodes":[{"content":"This topic describes how you can author best practice rules in C#, for both metadata and X++ code.","pos":[0,98]},{"content":"Best practice checks are run by the compiler and in daily builds to catch objectionable practices that are unacceptable in shipping code.","pos":[99,236]},{"content":"The features can also be used to author simple one-of tools to gather information about the application.","pos":[237,341]}]}]}],"path":["description"],"extradata":"MT"}],"header":"# required metadata\n","yml":true},{"pos":[929,953],"content":"Authoring best practices","linkify":"Authoring best practices","nodes":[{"content":"Authoring best practices","pos":[0,24]}]},{"content":"This topic describes how you can author best practice rules in C#, for both metadata and X++ code.","pos":[999,1097]},{"content":"Best practice checks are run by the compiler and in daily builds to catch objectionable practices that are unacceptable in shipping code.","pos":[1098,1235]},{"content":"The features can also be used to author simple one-of tools to gather information about the application.","pos":[1236,1340]},{"content":"This topic shows you how to author new best practice rules using the best practices framework.","pos":[1342,1436]},{"content":"Best practice checks are run during development and in daily builds to catch coding practices that are deemed unacceptable in shipping code.","pos":[1437,1577]},{"content":"Best practice rules are not restricted to this usage however; they can also be used to author simple one-of tools to gather information about the application.","pos":[1578,1736]},{"content":"The framework is built on top of a managed framework called XLNT (shorthand for X++ LaNguage Toolkit) that can be used to build custom tools that extract information from, and modify, X++ code.","pos":[1737,1930]},{"content":"There are two types of best practice rules: those that deal with metadata and those that deal with source code.","pos":[1931,2042]},{"pos":[2047,2075],"content":"Code Best Practice framework","linkify":"Code Best Practice framework","nodes":[{"content":"Code Best Practice framework","pos":[0,28]}]},{"content":"The Code Best Practice Framework (CBPF) enables you to write your own tools for analyzing X++ source code.","pos":[2076,2182]},{"content":"These rules diagnose things that you consider to be problems with X++ source code.","pos":[2183,2265]},{"content":"This section describes the foundation of the Best Practice functionality.","pos":[2266,2339]},{"content":"This information is helpful for understanding the later sections that describe creating your own rules in greater detail.","pos":[2340,2461]},{"content":"It is also helpful to developers who want to code rules that are more complex than those demonstrated in this document.","pos":[2462,2581]},{"content":"The CBPF API is designed to allow you to focus on the rule you are expressing, without having to deal with infrastructure issues; you will not need to read tokens and piece them together to create something intelligible from them.","pos":[2582,2812]},{"content":"Instead, the CBPF provides the following parts:","pos":[2813,2860]},{"content":"A parser that builds an Abstract Syntax Tree (AST) from X++ source code.","pos":[2866,2938]},{"content":"A pipeline that runs a sequence of passes over the X++ code.","pos":[2943,3003]},{"content":"A number of prebuilt passes.","pos":[3008,3036]},{"content":"The first pass is the parsing of the source code.","pos":[3037,3086]},{"content":"Infrastructure to read metadata.","pos":[3091,3123]},{"content":"Because rules are based on ASTs, it is important to understand that concept before starting to write rules.","pos":[3125,3232]},{"pos":[3238,3257],"content":"The parser and ASTs","linkify":"The parser and ASTs","nodes":[{"content":"The parser and ASTs","pos":[0,19]}]},{"content":"The parser reads  X++ code and produces an AST from it if it does not contain egregious syntax errors.","pos":[3259,3361]},{"content":"The parser has a built-in error recovery scheme, so it can recover from most syntax errors reasonably well.","pos":[3362,3469]},{"content":"When a syntax error happens, the parser will read symbols until it encounters a semicolon, and then try to building the AST by unstacking its state until it reaches a state where a semicolon is a correct symbol.","pos":[3470,3681]},{"content":"In addition, the parser is able to suggest the correct set of symbols when a syntax error occurs.","pos":[3682,3779]},{"content":"The parser is not intended to be directly interacted with by consumers of the API, but should be considered a black box that works without user intervention.","pos":[3780,3937]},{"content":"As the parser recognizes the language constructs in the source code, it builds an AST.","pos":[3938,4024]},{"content":"The AST consists of nodes that are abstractions of the X++ artifact they represent.","pos":[4025,4108]},{"content":"We will illustrate the concept by showing a few AST nodes below:","pos":[4109,4173]},{"content":"The Statement class is abstract; it does not make sense to instantiate a ”statement”; only concrete derived classes (like if statements, while statements etc.) can be instantiated.","pos":[4434,4614]},{"content":"Since the Comments property is placed on this base class, it applies to all derived classes; in other words: all statements can have comments preceding the statement, which are accessible through the given property.","pos":[4615,4830]},{"content":"There are many different kinds of statement in X++ and each one is described by a class derived in one or more steps from the abstract Statement class shown above.","pos":[4831,4994]},{"content":"The following example shows the definition of a <bpt id=\"p1\">**</bpt>while<ept id=\"p1\">**</ept> statement.","pos":[4995,5063],"source":" The following example shows the definition of a **while** statement."},{"content":"The <bpt id=\"p1\">**</bpt>while<ept id=\"p1\">**</ept> statement consists of the condition (an expression) and the constituent statement, that is executed as long as the condition evaluates to true.","pos":[5421,5578],"source":"The **while** statement consists of the condition (an expression) and the constituent statement, that is executed as long as the condition evaluates to true."},{"content":"The parser will maintain the source code positions where the represented artifact starts and ends (i.e. its extent).","pos":[5579,5695]},{"content":"As the ASTs are traversed it may be useful to add information to the individual nodes.","pos":[5696,5782]},{"content":"For example, every expression has a type.","pos":[5783,5824]},{"content":"As the tree is traversed to diagnose type compatibility problems it becomes useful to be able to place that information on the individual node.","pos":[5825,5968]},{"content":"Rather than having to modify the AST nodes for each requirement, there is a property collection that can be used to provide name/value pairs to each node.","pos":[5969,6123]},{"content":"Each AST node has a <bpt id=\"p1\">**</bpt>ToString<ept id=\"p1\">**</ept> method that will return a high fidelity string representation of the node, which is useful in debugging scenarios.","pos":[6124,6271],"source":" Each AST node has a **ToString** method that will return a high fidelity string representation of the node, which is useful in debugging scenarios."},{"pos":[6277,6297],"content":"The AstSweeper class","linkify":"The AstSweeper class","nodes":[{"content":"The AstSweeper class","pos":[0,20]}]},{"content":"The AstSweeper applies a visitor pattern to the AST instance that it is given.","pos":[6299,6377]},{"content":"The visitor pattern allows the programmer to separate the underlying data structure (i.e. the AST) from the operations that the user wants to perform on the nodes (i.e. the logic reasoning about the code).","pos":[6378,6583]},{"content":"The <bpt id=\"p1\">**</bpt>AstSweeper<ept id=\"p1\">**</ept> class has a virtual method for each of the AST node types, and it will call them as directed by the structure of the AST.","pos":[6584,6724],"source":" The **AstSweeper** class has a virtual method for each of the AST node types, and it will call them as directed by the structure of the AST."},{"content":"The following examples shows how the sweeper works.","pos":[6725,6776]},{"content":"Some details have been omitted for clarity.","pos":[6777,6820]},{"content":"The name of the virtual method handling a particular AST node is the name of the AST class prepended with Visit.","pos":[7970,8082]},{"content":"The parameters are the node to visit and a payload that may be passed to all the visitors as they are called.","pos":[8083,8192]},{"content":"In this way, the sweeper will call the virtual method once for each and every one of the nodes in the AST that is passed to it in a depth-first traversal.","pos":[8193,8347]},{"content":"The payload parameter can be used to pass information (e.g. a symbol table) to each node as required.","pos":[8348,8449]},{"content":"Developers will build classes derived from the AstSweeper class, overriding the methods of particular interest to them.","pos":[8450,8569]},{"pos":[8576,8583],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"Suppose you need to determine the percentage of parameter names starting with an underscore character, thus conforming to the X++ coding guidelines.","pos":[8585,8733]},{"content":"You would then write a class deriving from the <bpt id=\"p1\">**</bpt>AstSweeper<ept id=\"p1\">**</ept> class with logic that calculated the number of parameters and the number of parameters starting with underscore.","pos":[8734,8908],"source":" You would then write a class deriving from the **AstSweeper** class with logic that calculated the number of parameters and the number of parameters starting with underscore."},{"content":"The following example shows this code.","pos":[8909,8947]},{"content":"In this case, the tally is maintained in the <bpt id=\"p1\">**</bpt>ParametersCount<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>UnderscoredParameters<ept id=\"p2\">**</ept> properties that are defined in the class scope.","pos":[10022,10164],"source":"In this case, the tally is maintained in the **ParametersCount** and **UnderscoredParameters** properties that are defined in the class scope."},{"content":"Another equally valid approach would be to pass this information into the payload that is passed to all the <bpt id=\"p1\">**</bpt>Visit<ept id=\"p1\">**</ept> methods.","pos":[10165,10291],"source":" Another equally valid approach would be to pass this information into the payload that is passed to all the **Visit** methods."},{"content":"In most cases, the user should unconditionally call super() from the overridden method to make sure that the Visit methods are called for all nodes below the one being visited.","pos":[10292,10468]},{"content":"In the case above it does not make a difference so we opt to improve performance by pruning the AST tree traversal.","pos":[10469,10584]},{"pos":[10590,10626],"content":"Writing code for Best Practice rules","linkify":"Writing code for Best Practice rules","nodes":[{"content":"Writing code for Best Practice rules","pos":[0,36]}]},{"content":"Now that the concepts have been introduced, we are ready to author business rules.","pos":[10628,10710]},{"content":"Basically you need to:","pos":[10711,10733]},{"content":"Define the situation you want to diagnose in terms of properties of the AST.","pos":[10739,10815]},{"content":"You will write <bpt id=\"p1\">**</bpt>Visit<ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept> methods that can do the analysis.","pos":[10816,10876],"source":" You will write **Visit\\*** methods that can do the analysis."},{"content":"When the error condition has been found, a diagnostic message must be generated.","pos":[10881,10961]},{"content":"There is an API that is used for this purpose; basically you need to write some boilerplate code for each diagnostic message.","pos":[10962,11087]},{"content":"You need to hook your new best practice rule into the rest of the framework, so the user can decide whether or not to include your rule in his work and to actually run it if so directed.","pos":[11092,11278]},{"pos":[11284,11337],"content":"Create a best practice rules project in Visual Studio","linkify":"Create a best practice rules project in Visual Studio","nodes":[{"content":"Create a best practice rules project in Visual Studio","pos":[0,53]}]},{"content":"In this walkthrough we imagine the following scenario:","pos":[11339,11393]},{"content":"Some methods are adorned with an Author attribute, that provides the name of the individual who wrote the code.","pos":[11399,11510]},{"content":"This is useful when finding who to point the finger at when stack traces containing that method appear.","pos":[11511,11614]},{"content":"Since we have a significant turnaround of developers, the names of the developers listed cannot be static.","pos":[11619,11725]},{"content":"We want to check which names are used in the Author attributes, and match them against a list of names of current developers.","pos":[11726,11851]},{"content":"The author attribute class is simply defined as:","pos":[11853,11901]},{"content":"In production code we would put in documentation comments and assertions to validate key assumptions about parameter values etc. For the sake of clarity, we omit these steps in this walkthrough, where the code is written for clarity.","pos":[12096,12329]},{"content":"Now that we have set the stage for what we want to achieve, we can start up Visual Studio and create a best practice rules project.","pos":[12330,12461]},{"content":"Provide a meaningful name that properly conveys what the rules are intended to do: Visual Studio creates a project with some source code snippets and project references set up.","pos":[12462,12638]},{"content":"You can save considerable time by using this source code as a starting point for your own code.","pos":[12639,12734]},{"content":"The pre-canned example contains rules that prohibits the word “Microsoft” in any method names (presumably for copyright reasons) and a metadata based rule prohibiting certain characters in names.","pos":[12735,12930]},{"content":"Since we are not concerned with the metadata checks for now, you can delete the InvalidCharactersDiagnosticItem.cs and DemoMetadataCheck.cs files from the project.","pos":[12931,13094]},{"content":"Also, since we are not interested in the Microsoft name check, go ahead and delete the content of the VisitMethod method in the DemoAST class.","pos":[13095,13237]},{"content":"The first thing we need to do is to find out if there are one or more Author attributes for a particular method.","pos":[13238,13350]},{"content":"You will notice that the Method type (that is passed as a parameter to the VisitMethod method) has an Attributes property of type AttributeList.","pos":[13351,13495]},{"content":"Let's use it to see if any Author attributes are defined on this method:","pos":[13496,13568]},{"content":"At this point we have looped through any attributes, and collected a list of author names, i.e. names that are provided as the first parameters to the Author attributes.","pos":[14343,14512]},{"content":"Now we need to compare the list against a list of acceptable authors, that we maintain in a static list.","pos":[14513,14617]},{"content":"Whenever an author is provided that is not mentioned in the list we need to issue an appropriate diagnostic message.","pos":[14618,14734]},{"content":"At this time, we have something like:","pos":[14735,14772]},{"content":"In other words, we need to create an diagnostic message to let the user know about the transgression of the rule.","pos":[16097,16210]},{"content":"As noted before, it is important to call the base implementation of your visitor, which will then call visitor methods for all the nodes that are contained in the method.","pos":[16211,16381]},{"content":"However, in this case, we do not want to do any further processing once we have determined if the author attribute is on the list.","pos":[16382,16512]},{"pos":[16518,16556],"content":"Add a class for the diagnostic message","linkify":"Add a class for the diagnostic message","nodes":[{"content":"Add a class for the diagnostic message","pos":[0,38]}]},{"content":"The project already includes boilerplate code for an error message, so we will use that as our starting point to create the diagnostic message that will be returned if the rule is violated.","pos":[16558,16747]},{"content":"Each message is implemented as a class of its own.","pos":[16748,16798]},{"content":"Each error message may have any amount of contextual information encoded into it.","pos":[16799,16880]},{"content":"In this case, the contextual information is the name of the author that is not found in the list.","pos":[16881,16978]},{"content":"We will start by adding the message to the messages resource file: Open that file in the project and add a string to it.","pos":[16979,17099]},{"content":"We will use the name (also known as the error moniker) AuthorNotCurrent.","pos":[17100,17172]},{"content":"The ‘{0}’ string is a placeholder for the contextual information, in this case the name of the author who is not in the list.","pos":[17173,17298]},{"content":"In addition to the actual text that will appear in the error message, there is also a string containing a description of the rule; this information is shown in the best practice dialog within Visual Studio and is designed to help the user decide which rules he wants to enable on his system.","pos":[17299,17590]},{"content":"Create a class for the diagnostic message, and call it AuthorNotCurrentDiagnosticItem.cs.","pos":[17591,17680]},{"content":"Add the following code inspired from the NotAllowedWordDiagnosticItem class.","pos":[17681,17757]},{"content":"The diagnostic message is ready for consumption.","pos":[20152,20200]},{"content":"There is just one piece of bookkeeping that needs to be done; the rule needs to publish declaratively which diagnostics it potentially issues.","pos":[20201,20343]},{"content":"Go back to your rule and modify the BestPracticeRule attribute to reflect the new diagnostic message:","pos":[20344,20445]},{"pos":[20769,20860],"content":"As you can see, there are four parameters specified for the <bpt id=\"p1\">**</bpt>BestPracticeRule<ept id=\"p1\">**</ept> attribute:","source":"As you can see, there are four parameters specified for the **BestPracticeRule** attribute:"},{"content":"The rule moniker.","pos":[20866,20883]},{"content":"The type of the resource file holding the rule description.","pos":[20888,20947]},{"content":"In this example we are using the default resource file named Messages, which created a class called Messages.","pos":[20948,21057]},{"content":"We want the type of this class as the second argument.","pos":[21058,21112]},{"content":"The name of the string resource that contains the description of the rule.","pos":[21117,21191]},{"content":"This is the string called <bpt id=\"p1\">**</bpt>AuthorNotCurrentDescription<ept id=\"p1\">**</ept> that we added to the resource file above; it contains a human legible string to describe the rule.","pos":[21192,21348],"source":" This is the string called **AuthorNotCurrentDescription** that we added to the resource file above; it contains a human legible string to describe the rule."},{"content":"This string is used to describe the rule to the user in a best practice dialog within Visual Studio.","pos":[21349,21449]},{"content":"In Visual Studio, select <bpt id=\"p1\">**</bpt>Dynamics 365 <ph id=\"ph1\">&amp;gt;</ph> Best Practices Configuration<ept id=\"p1\">**</ept> to view the dialog.","pos":[21450,21545],"source":" In Visual Studio, select **Dynamics 365 &gt; Best Practices Configuration** to view the dialog."},{"content":"A description of the artifacts to check.","pos":[21550,21590]},{"content":"In our case the value specifies that the rule should only be applied to classes.","pos":[21591,21671]},{"content":"Feel free to modify this to your needs by using one of the other literals in the BestPracticeCheckerTargets enumeration.","pos":[21672,21792]},{"content":"We still need to fill out the pending TODO item, that is now reduced to instantiating the class that describes the diagnostic message and adding it to the set of diagnostics:","pos":[21794,21968]},{"content":"At this point you have a complete best practice rule, ready to provide value in your organization.","pos":[22424,22522]},{"content":"Go ahead and build it and fix any errors that may have crept in.","pos":[22523,22587]},{"pos":[22592,22626],"content":"Metadata based Best Practice rules","linkify":"Metadata based Best Practice rules","nodes":[{"content":"Metadata based Best Practice rules","pos":[0,34]}]},{"content":"Until now we have been describing how to write rules that deal with code.","pos":[22627,22700]},{"content":"In this section we show how to author rules that apply to metadata, not code.","pos":[22701,22778]},{"content":"Classes that deal with metadata rules are derived from <bpt id=\"p1\">**</bpt>BestPracticeMetadataChecker.<ept id=\"p1\">**</ept>","pos":[22779,22866],"source":" Classes that deal with metadata rules are derived from **BestPracticeMetadataChecker.**"},{"content":"The derived instance receives an instance of the metadata describing the artifact that must be checked.","pos":[22867,22970]},{"content":"You then use the APIs in the Microsoft.Dynamics.AX.Metadata.Metamodel to fetch further metadata as needed, and use LINQ queries over the metadata graphs.","pos":[22971,23124]},{"content":"The template for best practice checks contains a class performing metadata checks as well as a code based one we discussed in the previous section.","pos":[23125,23272]},{"content":"The mechanics involved in issuing diagnostic messages is the same as we covered above.","pos":[23273,23359]},{"pos":[23364,23396],"content":"Install, run, and test your rule","linkify":"Install, run, and test your rule","nodes":[{"content":"Install, run, and test your rule","pos":[0,32]}]},{"content":"When your code compiles cleanly, a DLL will be created.","pos":[23397,23452]},{"content":"In order for the tooling to be able to pick up the new rule, this DLL must be installed before running it.","pos":[23453,23559]},{"content":"Installing the DLL can be done in two ways:","pos":[23560,23603]},{"content":"By using the button on the Best Practice configuration dialog.","pos":[23609,23671]},{"content":"Click the <bpt id=\"p1\">**</bpt>Install extension...<ept id=\"p1\">**</ept> button.","pos":[23672,23714],"source":" Click the **Install extension...** button."},{"content":"You will be asked to point to the assembly file that contains your rule (i.e. the DLL generated when you build the rule).","pos":[23715,23836]},{"content":"Press OK, and the system will copy the DLL where it needs to be (see below).","pos":[23837,23913]},{"content":"By manually installing the DLL into the C:<ph id=\"ph1\">\\\\</ph>Packages<ph id=\"ph2\">\\\\</ph>bin<ph id=\"ph3\">\\\\</ph>BPExtensions folder.","pos":[23918,23997],"source":"By manually installing the DLL into the C:\\\\Packages\\\\bin\\\\BPExtensions folder."},{"content":"If you want to debug your rule, you will find it useful to copy the .pdb file to the same directory as the assembly After the DLL has been deployed to the target directory, Visual Studio needs to be restarted.","pos":[23999,24208]},{"content":"After that, the rule is available for use.","pos":[24209,24251]},{"content":"You may have to debug your rule to iron out any remaining kinks.","pos":[24252,24316]},{"content":"In fact stepping through your rule and inspecting the ASTs is valuable when you are learning the ropes.","pos":[24317,24420]},{"content":"To debug a rule you need to know that the best practice rule is actually executed by the xppAgent process; it is therefore not run within the context of VS itself.","pos":[24421,24584]},{"content":"Make sure you have selected <bpt id=\"p1\">**</bpt>Run best practice checks<ept id=\"p1\">**</ept> in the Visual Studio Options dialog, in the <bpt id=\"p2\">**</bpt>Finance and Operations<ept id=\"p2\">**</ept> page.","pos":[24585,24718],"source":" Make sure you have selected **Run best practice checks** in the Visual Studio Options dialog, in the **Finance and Operations** page."},{"content":"Otherwise, your check will not run.","pos":[24719,24754]},{"content":"Set a breakpoint in the <bpt id=\"p1\">**</bpt>VisitMethod<ept id=\"p1\">**</ept> method, and then do a build of a model that has the new rule switched on as shown above for the Fleet management model.","pos":[24757,24916],"source":"   Set a breakpoint in the **VisitMethod** method, and then do a build of a model that has the new rule switched on as shown above for the Fleet management model."},{"content":"Attach your VS instance to the xppcAgent process.","pos":[24917,24966]},{"content":"When you do a build your breakpoint will be hit, and you can start drilling into your code.","pos":[24967,25058]},{"content":"You can see all the properties, the list of declarations and statements, and find out all the details about them.","pos":[25059,25172]},{"pos":[25178,25204],"content":"Running rules in XppBp.exe","linkify":"Running rules in XppBp.exe","nodes":[{"content":"Running rules in XppBp.exe","pos":[0,26]}]},{"content":"As described above the best practice rules are often run as part of the build of a project from Visual Studio, but there is also a dedicated command line tool to run them.","pos":[25206,25377]},{"content":"This is the xppbp.exe tool, and it is intended mainly for nightly build scenarios.","pos":[25378,25460]},{"content":"Invoking it from the command line yields a useful overview of the command line switches and arguments.","pos":[25461,25563]},{"content":"Here are some useful examples:","pos":[25564,25594]},{"pos":[25600,25671],"content":"Run BP on all forms in a module: <ph id=\"ph1\">`xppbp -module:FleetManagement form:*`</ph>","source":"Run BP on all forms in a module: `xppbp -module:FleetManagement form:*`"},{"pos":[25676,25762],"content":"Run BP on specific elements: <ph id=\"ph1\">`xppbp -module:FleetManagement class:MyClass form:MyForm`</ph>","source":"Run BP on specific elements: `xppbp -module:FleetManagement class:MyClass form:MyForm`"},{"pos":[25767,25904],"content":"Run BP on all items in the model (and only for this one model in the module): <ph id=\"ph1\">`xppbp -module:FleetManagement -model:FleetManagement –all`</ph>","source":"Run BP on all items in the model (and only for this one model in the module): `xppbp -module:FleetManagement -model:FleetManagement –all`"},{"pos":[25909,25994],"content":"Run BP on all items in all models in the module: <ph id=\"ph1\">`xppbp -module:FleetManagement –all`</ph>","source":"Run BP on all items in all models in the module: `xppbp -module:FleetManagement –all`"},{"pos":[25999,26095],"content":"Write the output to log files: <ph id=\"ph1\">`xppbp -module:FleetManagement -all -xmllog=Log.xml -log=Log.txt`</ph>","source":"Write the output to log files: `xppbp -module:FleetManagement -all -xmllog=Log.xml -log=Log.txt`"}]}