{"content":"---\n# required metadata\n\ntitle: X++ classes and methods\ndescription: This topic describes how to create and use classes and interfaces in X++.\nauthor: RobinARH\nmanager: AnnBe\nms.date: 06/20/2017\nms.topic: article\nms.prod: \nms.service: dynamics-ax-platform\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \nms.reviewer: robinr\nms.search.scope: AX 7.0.0, Operations, UnifiedOperations\n# ms.tgt_pltfrm: \nms.custom: 150303\nms.assetid: 1b2d76d1-52d9-46b2-937f-5a3b62f2d516\nms.search.region: Global\n# ms.search.industry: \nms.author: robinr\nms.search.validFrom: 2016-02-28\nms.dyn365.ops.version: AX 7.0.0\n\n---\n\n# X++ classes and methods\n\n[!include[banner](../includes/banner.md)]\n\n\nThis topic describes how to create and use classes and interfaces in X++.\n\nClasses in X++\n--------------\n\nA *class* is a software construct that defines the data and methods of the objects that are later constructed from that class. The objects that are constructed are known as *instances* or *objects*. (This topic uses the two terms interchangeably.) The data represents the state of the object, whereas the methods represent the behavior of the object. *Variables* contain the data for the class. Variables in a class are specific to objects that are constructed from that class. Every object that is constructed from the class declaration has its own copy of the variables. These variables are known as *instance variables*. Methods define the behavior of a class. They are the sequences of statements that operate on the data. Typically, methods are declared to operate on the instance variables of the class. These methods are known as *instance methods* or *object methods*. You can also declare *static methods* and *static fields*.\n\n## Declaration of classes\n### Create a class in Visual Studio\n\nFollow these steps to create a class in Microsoft Visual Studio.\n\n1.  In Server Explorer, right-click the project, and then click **Add**.\n2.  In the **New Item** dialog box, select **Class**, and then enter a name for the class.\n3.  Click **Add**.\n\nAll classes are public. If you remove the **public** modifier, the system still treats the class as public. You can specify other modifiers on the class declaration, such as **final** and **extends**.\n\n### Creating variables in a class\n\nAll classes are public, but all member variables are implicitly private. However, even though all member variables are private, you can't decorate a member variable with the **private** keyword. All member variables belong to only object instances of the class. The following example shows how to use accessor methods to make the variable data public.\n\n    public class HasAFirstName\n    {\n        str firstName;\n        public str getFirstName()\n        {\n            return firstName;\n        }\n        \n        public void setFirstName(str newName)\n        {\n           firstName = newName;\n        }\n    }\n\n## Constructors\nTo create an instance of a class, you must instantiate it by using a *constructor*. The default constructor is the **new** method.\n\n    // Declare a variable to refer to a Point object\n    Point myPoint; \n        \n    // Create an instance of a Point object\n    myPoint = new Point(); \n\nAs a best practice, you should make the **new** method protected. Instead, if initialization isn't required, you should use a **static construct** method as the public constructor for the class. Otherwise, you should use a **static new** method.\n\n### Creating other objects in a constructor\n\nA class constructor can instantiate other objects in addition to creating an instance of the class. For example, the following code declares a **Rectangle** class that uses two **Point** objects to define its bounds.\n\n    class Rectangle1\n    {\n        Point lowerLeft;\n        Point upperRight;\n\n        void new(real _topLeftX, real _topLeftY, real _bottomRightX, real _bottomRightY)\n        {\n            lowerLeft  = new Point(_topLeftX, _topLeftY);\n            upperRight = new Point(_bottomRightX, _bottomRightY);\n        }\n    }\n\n## Destructors\nA *destructor* is used to explicitly destroy a class object. Objects are automatically destroyed when there are no references to them. However, you can destroy objects explicitly in the following ways:\n\n-   Use the **finalize** method.\n-   Set the object handle to **null**.\n\n### Using the finalize method\n\nUse the **finalize** method to explicitly destroy an object. There are no implicit calls to the **finalize** method. You must call the method to run the statements in it. The following example shows the basic structure for a call to the **finalize** method.\n\n    // From any method in a class.\n    if (condition)\n    {\n        // Removes object from memory.\n        this.finalize(); \n    }\n\nIn the **finalize** method, you should also put any clean-up code that is required. For example, if your class uses a dynamic-link library (DLL) module, you can use the **finalize** method to release the DLL when you no longer require it. Use the **finalize** method carefully. It will destroy an object even if there are references to it.\n\n### Setting an object handle to null\n\nSet the object handle to **null** to terminate an object. This approach destroys an object only if no other object handles point to that object. You should verify that other code isn't using the object handle. The following example creates an object handle and then sets it to **null**.\n\n    // Create an object handle of the type MyObject.\n    MyObject mo;\n    // Create an object of MyObject type and link it to the object handle.\n    mo = new myObject();\n    // Terminate the object.\n    mo = null;\n\n## Creating a subclass\n*Subclasses* are classes that extend or inherit from other classes. A class can extend only one other class. Multiple inheritance isn't supported. If you extend a class, the subclass inherits all the methods and variables in the parent class (the *superclass*). Subclasses let you reuse existing code for a more specific purpose. Therefore, they help save you time during design, development, and testing. To customize the behavior of a superclass, override the methods in a subclass. A superclass is often known as a *base class*, and a subclass is often known as a *derived class*.\n\n### Subclass example\n\nThe following example first creates a class that is named **Point**. It then extends the **Point** class to create a new class that is named **ThreePoint**.\n\n    class Point\n    {\n        // Instance fields.\n        real x; \n        real y; \n\n        // Constructor to initialize fields x and y.\n        void new(real _x, real _y)\n        { \n            x = _x;\n            y = _y;\n        }\n    }\n\n    class ThreePoint extends Point\n    {\n        // Additional instance fields z. Fields x and y are inherited.\n        real z; \n\n        // Constructor is overridden to initialize z.\n        void new(real _x, real _y, real _z)\n        {\n            // Initialize the fields.\n            super(_x, _y); \n            z = _z;\n        }\n    }\n\n### Preventing class inheritance\n\nYou can prevent classes from being inherited by using the **final** modifier.\n\n    public final class Attribute\n    {\n        int objectField;\n    }\n\n## Methods\nThe following code block types are standard for application classes:\n\n-   ****classDescription** declaration block** – This declaration block contains class modifiers such as **public**, **private**, and **extends**. It also contains the field members for objects that are constructed from the class. When you type the keyword **this**, IntelliSense can show a list of the members.\n-   ****new** method** – This method creates an instance of the class. The constructor can be called only by using the **new** keyword. Derived classes can call the **new** method of their constructor by calling the **super** method reference.\n-   ****finalize** method** – This method finalizes an instance of the class. This method is the destructor method. However, it's a destructor by convention only. The system doesn't automatically call the **finalize** method during garbage collection.\n\nAdditional methods for a class have the following types:\n\n-   Instance methods\n-   Static methods\n-   Main methods\n\nMethods can be created on many kinds of items. Here are some examples:\n\n-   Classes\n-   Maps\n-   Views\n-   Data Sets\n-   Forms\n-   Queries\n\n### Instance methods\n\nInstance methods, or object methods, are embedded in each object that is created from the class. You must instantiate the object before you can use the method. If you later convert an instance method to a static method, you must restart the client. Otherwise, the compiler doesn't detect the change. After you've converted an instance method to a static method, you can no longer call the method from the instance of the class. Instead, you must call the method from the class itself. Static methods are discussed in the next section. You use the following syntax to call instance methods.\n\n    ClassName objectHandleName = new ClassName();\n    objectHandleName.methodName();\n\n### Static methods\n\nStatic methods, which are also known as *class methods*, belong to a class and are created by using the keyword **static**. You don't have to instantiate an object before you use static methods. Static methods are often used to work with data that is stored in tables. Member variables can't be used in a static method. You use the following syntax to call static methods.\n\n    ClassName::methodName();\n\n### Main methods\n\nA **main** method is a class method that is run directly from a menu option. The method should only create an instance of the object and then call the required member methods. The **\\_args** parameter lets you transfer data to the method.\n\n    static void main (Args _args)\n    {\n        // Your code here.\n    }\n\n### Declaration of methods\n\nMethod declarations consist of a header and a body. The method header declares the method's name and return type), the method modifiers, and parameters. (The return type might be **void**.) The method body consists of variable declarations, method declarations, and statements.\n\n### Return type\n\nIf a method doesn't return anything, you must use the **void** keyword. The following example shows two methods. One method has a return type, but the other method doesn't have a return type.\n\n    void methodNameNoReturnValue()\n    {\n        // Your code here.\n    }\n\n    // If a method returns something, you must specify the return type and include a return statement.\n    int methodNameIntegerReturnValue()\n    {\n        return 1;\n    }\n\n### Syntax\n\nMethod declaration = *Heading*  *Body* Heading = **\\[** *Modifiers* **\\]**  *ReturnType*  *MethodName*  **(**  *ParameterList*  **)** Modifiers = **\\[client\\] \\[server\\] \\[edit | display | public | protected | private\\] \\[static | abstract | final \\]** ReturnType = *Datatype*  **| void | anytype** MethodName = *Identifier* ParameterList = **\\[** *Parameter*  **{ ,**  *Parameter*  **}\\]** Parameter = *Datatype*  *Variableidentifier*  **\\[ =**  *Expression*  **\\]** Body = **{ \\[**  *VariableDeclarations*  **\\] \\[**  *EmbeddedFunctionDeclarations*  **\\] \\[**  *Statements*  **\\] }** EmbeddedFunctionDeclaration = *Heading*  **{\\[**  *VariableDeclarations*  **\\] \\[**  *Statements*  **\\]}** If you use the **anytype** return type, the method can return any data type.\n\n### Example of a method that doesn't have a return type\n\n    void update ()\n    {   \n        // Variable declared and initialized\n        CustTable this_Orig = this.orig();\n\n        // First statement in body (begin transaction)\n        ttsBegin;\n        this.setNameAlias();\n        // Calls super's implementation of update\n        super();\n        this.setAccountOnVend(this_Orig);\n        if (this_Orig.custGroup != this.custGroup)\n            ForecastSales::setCustGroupId(\n                this.accountNum,\n                this_Orig.custGroup,\n                this.custGroup);\n        // Commits transaction\n        ttsCommit;\n    }\n\n### Example of a method that has parameters\n\nIn the following example, the **checkAccountBlocked** method returns a Boolean value and acts on the **amountCur** parameter.\n\n    boolean checkAccountBlocked(AmountCur amountCur)\n    {\n        if (this.blocked == CustVendorBlocked::All \n            ||(this.blocked == CustVendorBlocked::Invoice \n            && amountCur > 0 ))\n        return checkFailed(strFmt(\"@SYS7987\",this.accountNum));\n        return true;\n    }\n\n## Method modifiers\nSeveral modifiers can be applied to method declarations. Some of the modifiers can be combined (for example, **final static**). Here are the method modifier keywords:\n\n-   **abstract** – The method is declared but isn't implemented in a parent class. The method must be overridden in subclasses. If you try to create an object from a subclass where one or more abstract methods that belong to the parent class haven't been overridden, you receive a compiler error. Classes can also be abstract. Sometimes, a class should not be instantiated even though it represents an abstract concept. Only subclasses should be instantiated. Base classes of this type can be declared as **abstract**. For example, you want to model the concept of an account. Accounts are abstract, because only derived classes (ledger accounts and so on) exist in the real world. This examples describes a clear case where you should declare the **Account** class as **abstract**.\n-   **display** – The method's return value should be shown on a page or a report. The value can't be modified on the page or report. Typically, the return value is a calculated value, such as a sum.\n-   **edit** – The method's return type should be used to provide information for a field that is used on a page. The value in the field can be modified.\n-   **final** – The method can't be overridden in any class that derives from its class.\n-   **public** – Methods that are declared as **public** can be accessed anywhere that the class is accessible, and they can be overridden by subclasses. Methods that have no access modifier are implicitly public.\n-   **protected** – Methods that are declared as **protected** can be called only from methods in the class and in subclasses that extend the class where the method is declared.\n-   **private** – Methods that are declared as **private** can be called only from methods in the class where the private method is declared.\n-   **static** – The method is a class method and doesn't act on an instance. Static methods can't refer to instance variables. They aren't invoked on an instance of the class. Instead, the are invoked by using the class name (for example, **MyClass::aStaticProcedure()**).\n\n### Methods that have modifiers\n\n**Note:** The following examples show only the method headers.\n\n    // A method that cannot be overridden\n    final int dontAlterMe() \n\n    // A static method \n    static void noChange()\n\n    // A display method that returns an integer\n    display int value()\n\n## Static class members\nYou declare static class members by using the **static** keyword. The **static** keyword instructs the system to create only one instance of the method, regardless of the number of times that you call **new**. This one instance is used throughout your session. In general, static methods are intended for cases where the following criteria are met:\n\n-   The method has no reason to access the member variables that are declared in the class.\n-   The method has no reason to call any instance (non-static) methods of the class.\n\n#### Static methods\n\nThis section describes a scenario where a software key type is used to help prevent piracy. Each instance of a software key can have its own unique value. However, because all software keys must conform to the rules of software key design, the logic that tests for software key conformance is the same for all software keys. Therefore, the method that contains the conformance validation logic should be static. Here is an example of a method that is declared by using the **static** keyword.\n\n    static public boolean validateSoftwareKey(str _softwareKeyString)\n    {\n          // Your code here.\n    }\n\nIn the following example, you don't have to construct an instance of the **SoftwareKey** class before you call a static method on the class. When you want to call the static **validateSoftwareKey** method, the syntax starts with the name of the class that contains the method. A pair of colons (::) is used to connect the class name to the static method name.\n\n    boolean yourBool = SoftwareKey::validateSoftwareKey(yourSoftwareKeyString);\n\n#### Static fields\n\nStatic fields are fields that are declared by using the **static** keyword. Conceptually, they apply to the class, not to instances of the class.\n\n### Static constructors\n\nStatic constructors are guaranteed to run before any static or instance calls are made to the class. In C\\#, the *static* concept is related to the whole executing application domain. However, in X++, the execution of the static constructor is relative to the user’s session. The static constructor has the following syntax.\n\n    static void TypeNew() \n\nYou never explicitly call the static constructor. The compiler will generate code to make sure that the constructor is called exactly one time before any other method on the class. A static constructor is used to initialize any static data or perform a particular action that must be performed only one time. No parameters can be provided for the static constructor, and it must be marked as **static**. The following example shows how to create a singleton instance by using a static constructor.\n\n    public class Singleton\n    {\n      private static Singleton instance;\n\n      private void new()\n      {\n      }\n\n      static void TypeNew()\n      {\n        instance = new Singleton();\n      }\n\n      public static Singleton Instance()\n      {\n        return Singleton::instance;\n      }\n    }\n\nThe singleton guarantees that only one instance of the class will ever be called. The following example shows how to instantiate the singleton.\n\n    {\n        Singleton i = Singleton::Instance();\n    }\n\n## Method access control\nYou use the accessor keywords **public**, **protected**, and **private** to control whether the methods in other classes can call the methods on your class. The accessor keywords on methods also interact with the rules for class inheritance. Here are the accessor keywords that you use with methods:\n\n-   **public** – Methods that are declared as **public** can be called from anywhere that the class is accessible. In addition, a public method can be overridden by a subclass, unless the method is declared as **final**.\n-   **protected** – Methods that are declared as **protected** can be called only from the following methods:\n    -   Methods in the class.\n    -   Methods in a subclass of the class that contains the protected method. Methods that are protected can be overridden in subclasses.\n-   **private** – Methods that are declared as **private** can be called only from methods in the class where the private method is declared. No private method can be overridden in a subclass. By default, when you create a new method, the **private** accessor keyword appears in the code editor. For maximum security, **private** is the most conservative default accessor keyword.\n\n### Static and instance methods\n\nThe accessor keywords on methods never restrict calls between two methods that are in the same class, regardless of which method is static or non-static. In a static method, calls to the **new** constructor method are valid even if the **new** constructor method is decorated with the **private** modifier. The syntax for these calls requires that the **new** keyword be used. The code in a static method must construct an instance object of its own class before it can call any instance methods on the class.\n\n### Increasing access during overrides\n\nWhen a method is overridden in a subclass, the overriding method must be at least as accessible as the overridden method. For example, the following compiler rules apply when a protected method is overridden in a subclass:\n\n-   A public method in a superclass can be overridden only by a public method in the subclass.\n-   In a subclass, a public or protected method can override a protected method of the superclass.\n-   In a subclass, a private method can't override a protected method of the superclass.\n\n## Optional parameters\nParameters can be initialized in the method declaration. In this case, the parameter becomes an *optional parameter*. If no value is supplied in the method call, the default value is used. All required parameters must be listed before the first optional parameter. The following examples show how to create and call a method that has optional parameters. The example of the **AddThreeInts** method shows that you can't skip default parameters when you call a method.\n\n### Examples of optional parameters\n\n    // This is an example of a function being used as the default.\n    public class Person \n    {\n        date birthDate;\n\n        // The constructor that takes a date type as\n        // a parameter. That value is assigned to the field member birthDate. \n        void new(date _date)\n        {\n            birthDate = _date;\n        }\n\n        // The CalculateAgeAsOfDate method references\n        // the birthDate field, is called by the Main method, and has an \n        // optional parameter. In this example, the default value is the\n        // return value of a function. \n        public real CalculateAgeAsOfDate(date _calcToDate = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone()) )  \n        {\n            return (_calcToDate - birthDate) / 365;\n        }\n\n        // The Main method calls the CalculateAgeAsOfDate method twice. \n        static public void Main(Args _args)\n        {\n            Person mc = new Person(13\\5\\2010);   // birthDate is initialized.\n            // Optional parameter's default is used.\n            print( \"Age in years: \" + num2str(mc.CalculateAgeAsOfDate(),2,0,0,0));\n            // January 2, 2044  is the parameter value for _date.\n            print \"Age in years: \" + num2str(mc.CalculateAgeAsOfDate(2\\1\\2044),2,0,0,0);\n        }\n    }\n\n    // This is an example of how you cannot skip to a second optional parameter. \n    // The first method has two optional parameters. The second method is a caller \n    // of the first method. The caller wants to override only the _i3 default value, but the \n    // compiler requires that all prior optional parameters also \n    // be overridden in the call. \n    public class Additions {\n        static public int AddThreeInts(int _i1, int _i2 = 2,int _i3 = 3)\n        {\n            return _i1 + _i2 + _i3;\n        }\n    }\n\n    // The second method has a commented section showing the\n    // failed attempt to accept the default of the first optional \n    // parameter (_i2) while trying to override the final optional \n    // parameter (_i3).\n    static public void Main(Args _args)\n    { \n        // No way to skip the first optional parameter (so it can default)\n        // while also specifying the value of the second optional parameter.\n        // The next statement does not compile.\n        //print Additions::AddThreeInts(1, , 99);\n\n        // Settle for overriding both optional parameters.\n        print Additions::AddThreeInts(1, 2, 99);\n    }\n\n## Accessor methods\nClass variables are private. By hiding details of the internal implementation of a class, you can change the implementation of the class later without breaking any code that uses that class. To access the data from reference variables, you must create accessor methods. The following example defines a **Point** class that uses accessor methods to access the variables **x** and **y**.\n\n    class Point\n    {\n        // Instance variables\n        real x; \n        real y;\n\n        //Constructor to initialize to a specific or default value\n        void new(real _x=10, real _y=10) \n        {\n            x = _x;\n            y = _y;\n        }\n\n        //Accessor methods\n        void setX(real _x) \n        {\n            x = _x;\n        }\n\n        void setY(real _y) \n        {\n            y = _y;\n        }\n\n        real getX() \n        {\n            return x;\n        }\n\n        real getY() \n        {\n            return y;\n        }\n    }\n\nThese method declarations show how the **Point** class provides access to its variables from the outside world. Other objects can manipulate the instance variables of **Point** objects by using the accessor methods.\n\n    // Declare a variable to refer to a Point object\n    Point myPoint; \n    // Create a Point object\n    myPoint = new Point(); \n    // Set the x variable using the accessor method\n    myPoint.setX(10.0); \n    // Set the y variable by means of the accessor method\n    myPoint.setY(25.7);\n\nThe depth of the call stack is limited to 100.\n\n## Overriding a method\nThe methods in a class are inherited by any class that extends it. To change the functionality of an inherited method, you can create a method in the subclass, and then give that method the same name and parameters as the method in the superclass. This process is known as *overriding* the method. In the following example, **ColorAttribute** is a subclass of **Attribute** and therefore inherits the **methodAttr** method. However, because **ColorAttribute** defines a method that has the same name and the same number of arguments, the method in the superclass is overridden.\n\n    // Superclass: Attribute\n    public class Attribute\n    {\n        int objectVariable;\n\n        void methodAtt()\n        {\n            //Some statements\n        }\n    }\n\n    // Subclass: ColorAttribute\n    public class ColorAttribute extends Attribute\n    {\n        int addedObjectVariable;\n\n        void methodAtt()\n        {\n            //Some statements\n        }\n    }\n\n### Preventing method overrides\n\nStatic methods can't be overridden, because they exist per class. To protect other sensitive methods, or core methods, from being overridden, use the **final** modifier. In the following example, because **methodAtt** is declared as **final**, it can't be overridden in any class that extends **Attribute**. You should not specify **new** or **finalize** methods as **final**. The following example shows how to use the **final** keyword.\n\n    public class Attribute\n    {\n        int objectVariable;\n\n        final void methodAtt()\n        {\n            //Some statements\n        }\n    }\n\n### Overriding vs. overloading\n\nOverriding occurs when the superclass's implementation of a method is changed by the subclass's implementation of that method, but the signatures of both methods are the same. By contrast, *overloading* occurs when more than one method has the same name, but the methods have different signatures (return types, parameter lists, or both). X++ supports overriding, but it doesn't support overloading.\n\n## Parameters\nAll methods have their own *scope*. A method can take one or more parameters. Within the scope of the method, these parameters are treated as local variables and are initialized with a value from the parameter in the method call. All parameters are passed by value. You can't change the value of the original variable. You can change only the local variable in the method. This local variable is a copy of the original variable.\n\n## Scope of variables in methods\nA scope defines the area in which an item can be accessed. Variables that are defined in a class are available to the methods within that class. Variables in methods can be accessed only within the current block.\n\n## Local functions\nYou can declare local functions inside a method. However, as a best practice, you shouldn't add local functions inside the method. Instead, you should add private methods to the class. The following example shows valid declarations of two local functions, **localFunc55b** and **localFunc66c**. Calls to the local functions occur after the function declarations in the example, as is required.\n\n    static void G_LocalFuncJob2(Args _args) \n    {\n        int nn = 654;\n        void localFunc55b(int _iNum)  // The local function.\n        {\n            str sInnerString;\n            sInnerString = \"String_in_localFunc55b\";\n            info(strFmt(\"localFunc55b: %1 , %2 , %3\", \n                _iNum, sInnerString, nn));\n        }\n\n        void localFunc66c()\n        {\n            info(\"Printing from inside localFunc66c.\");\n        }\n\n        localFunc55b(55);\n        localFunc66c();\n        // Next print statement would fail to compile,\n        // because sInnerString is restricted to the\n        // scope of the local function in which it is declared.\n        // print sInnerString; \n    }\n    /***  Infolog window display:\n    Message (07:38:54 pm)\n    localFunc55b: 55 , String_in_localFunc55b , 654\n    Printing from inside localFunc66c.\n    ***/\n\n### Declaration of local functions\n\n-   The declarations of local functions must physically precede any non-declaration statements in the method.\n-   You can declare more than one local function in your method. However, all local functions must be declared in an uninterrupted series, and the set must be terminated by one semicolon (;).\n\n### Variable scope\n\n-   Code that is inside the local function can access variables that are declared in the method that contains the local function.\n-   Code that is outside the local function can't access variables that are declared in the local function.\n\n### Calls to local functions\n\n-   A local function can be called only by code in the same method where the local function is declared.\n-   A local function should never call itself. Such recursion can prevent successful compilation.\n\n## The this keyword\nThe **this** keyword is a reference to the instance of the class or table where the **this** keyword is used. The **this** reference is never required, but it can clarify your code and enhances the behavior of IntelliSense in the code editor. All calls to instance methods must be qualified by either the **this** reference or a variable. The **this** reference can be used to qualify the following information:\n\n-   The names of other instance (non-static) methods in the same class where the **this** reference is used. Here is an example: **boolColorChanged = this.colorItOrange();**\n-   The names of methods that are inherited by the **this** object.\n-   The names of fields on the table that contains the method that the **this** keyword is used in.\n\nThe **this** reference can't be used in the following ways:\n\n-   It can't qualify the names of member variables that are declared in the **classDeclaration** code.\n-   It can't be used in a static method.\n-   It can't qualify the names of static methods of the class or table.\n\n## Interfaces\nAn *interface* is a specification for a set of public instance methods. An interface defines and enforces similarities between unrelated classes without having to derive one class from the other. All interfaces are public, even if you don't explicitly add the **public** keyword ****in front of the **interface** keyword ****in the **classDeclaration** code. The methods on an interface are also public. Once again, explicit inclusion of the keyword **public** is optional. To create an interface, follow these steps.\n\n1.  In Server Explorer, right-click the project, and then click **Add**.\n2.  In the **New Item** dialog box, select **Interface**, and then enter a name for the interface.\n3.  Click **Add**.\n\nWhen you add the **implements** keyword on a class declaration, the class must declare the methods that are specified by the interface. A class declaration can implement multiple interfaces. Just list the interfaces after the single occurrence of the **implements** keyword, and separate the interface names by using commas. All interface methods that a class implements must be explicitly declared as **public** by using the **public** keyword in the class. A class that implements an interface must also be declared as **public**. An interface can extend another interface by using the **extends** keyword. However, an interface can't extend more than one interface.\n\n### Interface example\n\nIn the following example, an **Automobile** class implements an **IDrivable** interface. The **is** keyword is supported and lets you test whether a class implements an interface.\n\n    public interface IDrivable\n    {\n        public int getSpeed()\n        {\n        }\n\n        public void setSpeed(int newSpeed)\n        {\n        }\n    }\n\n    class Automobile implements IDrivable\n    {\n        int m_speed;\n\n        public int getSpeed()\n        {\n            return m_speed;\n        }\n\n        public void setSpeed(int newSpeed)\n        {\n            m_speed = newSpeed;\n        }\n    }\n\n    class UseAnAutomobile\n    {\n        void DriveAutomobile()\n        {\n            IDrivable yourIDrivable;\n            Automobile myAutomobile;\n            str sTemp = \"object is not an IDrivable\";\n            \n            myAutomobile = new Automobile();\n            \n            if (myAutomobile is IDrivable)\n            {\n                yourIDrivable = myAutomobile;\n                yourIDrivable.setSpeed(42);\n                sTemp = int2str(yourIDrivable.getSpeed());\n            }\n            \n            Global::info(sTemp);\n            return;\n            // output\n            // Message (06:46:33 pm)\n            // 42\n        }\n    }\n\n## Class library overview\nThere are two kinds of classes: *application classes* and *system classes*.\n\n-   **Application classes** – These classes are implemented in X++. They are available in the **Classes** node in Application Explorer.\n-   **System classes** – These classes are sometimes known as *kernel classes* and are implemented in C++. They are listed under the **System Documentation** &gt; **Classes** node in Application Explorer. However, the source code for these classes isn't available.\n\nFor a list of these classes, see [API, class, and table reference](api-reference.md).\n\n## Substituting application classes for system classes\nYou should call the *substitute application classes* instead of the system classes that they extend. In Application Explorer, under **System Documentation** &gt; **Classes**, several kernel or system classes have names that begin with a lowercase *x*. These classes are known as *x-system classes*. Examples of these system classes are **xApplication** and **xVersionControl**. Some of these classes are extended by application classes. For example, the **Application** class extends the **xApplication** system class. The classes that derive from x-system classes are known as substitute application classes. In Application Explorer, under the **Classes** node, the icon next to the substitute application classes differs from the standard icon.\n\n### x-system classes\n\nSome of the substitute application classes are associated with a special global variable that represents an instance of the class. For example, the **appl** variable references a pre-instantiated object from the **Application** class. The advantage of the **appl** variable is that the system maintains the object throughout the scope of your session. Your code would be less efficient if it repeatedly used the **new Application()** syntax to obtain an instance of the **Application** class. You should not use the **xApplication** system class. Instead, use the **Application** substitute application class. You can reference the static members of the **Application** class by using the following standard syntax: **Application::checkForNewBatchJobs()**. However, to reference the instance members of the **Application** class, you should use that class's **appl** variable, if it exists. This pattern applies to most of the x-system classes. The **Session** substitute application class is one exception, because there is no special global variable for **Session**. The following table lists the x-system classes that have a corresponding substitute application class. The special global variables are also shown for those classes that have one.\n\n| Application class | x-system class  | Global variable    |\n|-------------------|-----------------|--------------------|\n| Args              | xArgs           | Not applicable     |\n| Application       | xApplication    | **appl**           |\n| ClassFactory      | xClassFactory   | **classFactory**   |\n| Company           | xCompany        | **appl.company**   |\n| Global            | xGlobal         | Not applicable     |\n| Info              | xInfo           | **Infolog**        |\n| MenuFunction      | xMenuFunction   | Not applicable     |\n| Session           | xSession        | Not applicable     |\n| VersionControl    | xVersionControl | **versionControl** |\n\n### Example of x-system classes\n\nThe following example shows the syntax for using several special variables that reference instances of the substitute application classes.\n\n    static void UseSpecialSystemVariablesForXJob(Args _a)\n    {\n        TreeNode treeNode2;\n        Args     args3;\n        FormRun  formRun4;\n        // appl variable\n        print appl.buildNo();\n        // company variable\n        appl.company().reloadRights(); // referenced through appl\n        // Infolog variable\n        treeNode2 = infolog.findNode(\"\\\\forms\\\\custTable\");\n        print treeNode2.AOTgetProperty(\"Name\");\n     \n        // classFactory variable\n        args3 = new Args(formstr(vendTable));\n        formRun4 = classFactory.formRunClass(args3);\n        formRun4.init();\n        formRun4.run();\n        formRun4.detach();\n        Global::info(\"Method is ending. This is a message in the Infolog.\");\n    }\n\n## Running startup commands\nYou use the **SysStartupCmd** class framework to run commands at startup. When Finance and Operations starts, calls are made to the **startup** methods on the application-substituted kernel classes **Application** (**Application.startup**) and **Info** (**Info.startup**). The **startup** methods are used for vital system and version-specific calls, and you must never directly modify these methods. Instead, use the **SysStartupCmd** framework. Serious issues can occur if the SYS layer versions of the **startup** methods aren't called. The following example shows the order that calls are run in when Finance and Operations starts.\n\n    appl.startup() // The SysStartupCmd class is instantiated here.\n    sysStartupCmd.applInit()\n    super()\n    sysStartupCmd.applRun()\n    info.startup()\n    sysStartupCmd.infoInit()\n    super()\n    sysStartupCmd.infoRun()\n\n### Commands that are available when Finance and Operations starts\n\nThe **SysStartupCmd.construct** method lists the commands that are available when Finance and Operations starts. Here are some of these commands:\n\n-   AutoRun\n-   AOTImport\n-   Synchronize\n\nThe following example shows how to run a new command when Finance and Operations starts. First, a class that extends **SysStartupCmd** is created. This new class performs your specific task. You then modify the construct method on **SysStartupCmd** to call your class. In the Finance and Operations Configuration Utility, on the **General** tab, in the **Command to run at application startup** field, you can add commands that are run at startup. Alternatively, you can use the **-startupcmd= *MyCommand*** command-line parameter.\n\n    public class SysStartupCmdAutoRun : extends SysStartupCmd \n    {\n        void new(str s, str parm) \n        {\n            // Your code here.\n        }\n    }\n\n    // This is a framework class. Customizing this class may cause problems with future upgrades to the software.\n    class SysStartupCmd\n    {\n        // Code delete for readability\n\n        static SysStartupCmd construct(str startupCommand)\n        {\n            // Code delete for readability\n            switch (s)\n            {\n                // Other cases delete for readability    \n                case 'autorun':\n                    sysStartupCmd = new SysStartupCmdAutoRun(s,parm);\n                    break;\n                // Other cases delete for readability\n            }\n            // Code delete for readability\n        }\n    }\n\n## Batch processing classes\nYou implement classes by using the batch processing system, and by extending the **RunBase** and **RunBaseBatch** classes. To remove the **Recurrence** button from the **Batch processing** dialog box, you use the **Args::parmEnum** method. We recommend that you designate a class to run as a server-bound batch method. Server-bound batch methods are more secure than batch methods that aren't server-bound for the following reasons:\n\n-   The method is run by using the permissions of the user who submitted the method.\n-   The method can use only specific **Info** and **Global** class methods to interact with the client that is processing it. This restriction limits interaction with the client.\n\n### Enable a class to run as a server-bound batch method\n\n1.  Create a class that extends the **RunBaseBatch** class.\n2.  Override the **RunBaseBatch.runsImpersonated** method to return a value of **true**, as shown in the following example.\n\n        public boolean runsImpersonated()\n        {\n            return true;\n        }\n\n3.  Confirm that the class calls only the following **Info** and **Global** class methods:\n    -   add\n    -   Info.copy\n    -   Info.cut\n    -   Info.import\n    -   Info.export\n    -   Info.line\n    -   Info.num\n    -   Global::error\n    -   Global::info\n    -   Global::warning\n\n    **Note:** The **Info.line** and **Info.num** methods are inherited from the **xInfo** class.\n\n### Removing the Recurrence button from the batch processing dialog box\n\nWhen you implement a class by using the batch processing system, you can remove the **Recurrence** button by calling the **Args.parmEnum** method and passing the **NoYes::Yes** system enumeration value. The **NoYes** system enumeration determines whether the **Recurrence** button is removed from the dialog box. The default value is **NoYes::No**. In the following example, the **InventTransferMultiShip** class is implemented. The **BatchDialog::main** method creates the **Batch processing** dialog box.\n\n    static void noRecurrenceButton(Args _args)\n    {\n        Args a;\n        InventTransferMultiShip inventTransferMultiShip;\n        a = new Args();\n        inventTransferMultiShip = InventTransferMultiShip::construct();\n        a.caller(inventTransferMultiShip);\n        a.parmEnum(NoYes::Yes);\n        BatchDialog::main(a);\n    }\n\n## Image manipulation classes\nTwo system classes let you to manipulate graphics and icons: **Image** and **Imagelist**.\n\n-   **Image** – This class lets you load, save, and manipulate individual images. For example, you can capture a screen and save it as an image, crop or rotate an image, or manipulate the color depth.\n-   **Imagelist** – This class lets you work with a set of images that have common properties, such as the size and transparency color. You can view the image lists that are used in Finance and Operations in the **ImageListAppl\\_\\*** application classes.\n\n## Query object model\nThe query object model contains classes that are used to define and run a query. The query objects are used to define the query data source, the fields that are returned, record ranges, and relations to child data sources. The query classes are more visible when you create a dynamic query in code, but they are also used behind the scenes when you create a static query in Application Explorer. The following table describes the classes in the query object model.\n\n| System class         | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n|----------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| QueryRun             | This class runs the query and fetches the data.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\n| Query                | This class holds some properties, and has one or more related data sources. It's the top level of the query definition.                                                                                                                                                                                                                                                                                                                                                                                                                             |\n| QueryBuildDataSource | This class defines access to a single data source in the query. If there is more than one data source at the same level in a query, separate SQL statements are produced and are run sequentially. If one data source is a child of another data source, a join is created between the two data sources.                                                                                                                                                                                                                                            |\n| QueryBuildFieldList  | This class defines the fields that are returned from the database. By default, the field list is dynamic, and all fields are returned from the data source table, map, or view. Each data source has only one **QueryBuildFieldList** object. This object contains information about all selected fields. You can specify aggregate functions, such as **SUM**, **COUNT**, and **AVG**, on the field list object.                                                                                                                                   |\n| QueryBuildRange      | This class defines a subset of records that is returned, based on a single field. A range is translated into a **WHERE** clause in the query SQL statement. If more than one field is used to limit the query (**WHERE** clause), the data source will contain more than one range.                                                                                                                                                                                                                                                                 |\n| QueryBuildDynalink   | This class contains information about a relation (limitation) to an external record. When the query is run, this information is converted to additional entries in the **WHERE** clause of the query SQL statement. This class can exist only on the parent data source of a query. Forms use the function when two data sources are synchronized. The child data source will then contain one or more DLLs to the parent data source. The function is used even if the two data sources are put in two different forms but are still synchronized. |\n| QueryBuildLink       | This class specifies the relation between the two data sources in the join. This class can exist only on a child data source.                                                                                                                                                                                                                                                                                                                                                                                                                       |\n\n## System classes overview\nSystem classes (or kernel classes) are implemented in C++. The source for these classes isn't available. A system class can have the following characteristics:\n\n-   Static methods (or class methods)\n-   Dynamic methods\n-   Properties – These properties are member functions that are used to set properties. An example is **LeftMargin**.\n\nYou can't override system class methods. It isn't our intention that you will use the system classes to design your application objects from scratch. Instead, use them to extend or modify the default functionality in Application Explorer. For example, you can dynamically add extra information to an existing report. Alternatively, you can change the options that are available on a page, based on the user's selection on a previous page.\n\n### Collection classes\n\nThe *collection classes* let you create lists, sets, structs, maps, and arrays.\n\n### Application object classes\n\nThese system classes hold functions that are activated whenever you use Application Explorer to create your application. For example, the system uses the **FormDesign** class when you define the layout of your form in the **Designs** node in Application Explorer. These classes also let you to create and modify application objects.\n\n### Integration classes\n\nThe integration with the environment is typically implemented by classes. Here are some examples of the classes in this category:\n\n-   **COM** – The call of methods on COM objects.\n-   **DLL** – The call of Microsoft Windows DLL functions.\n-   **IO** – Read and write external files.\n-   **ODBCConnection** – An Open Database Connectivity (ODBC) interface to a foreign database.\n\n## Event terminology and keywords\nYou can use the event design pattern to make your code more modular and reusable. The term *event* is a metaphor that explains how delegates are used. When something important occurs during a program run, other modules might have to process the occurrence. These important occurrences are known as *events*. When an event occurs, the program tells its notifier for the event that the notifier must send notifications about the event. A notification must be sent to all the event handlers that are subscribers of the notifier. When the program tells its notifier to send the notifications, we call that process *raising* an event. The following table shows the terms that are used to describe the event metaphor.\n\n| Term          | Description                                                                                                               |\n|---------------|---------------------------------------------------------------------------------------------------------------------------|\n| Event         | An important occurrence in a program module where additional modules must process the occurrence.                         |\n| Notifier      | The program element that sends information about the event to all the event handlers that are subscribed to the notifier. |\n| Subscriber    | The program functions or methods that are subscribed to an event notifier.                                                |\n| Event handler | The methods that subscribe to an event notifier. Only the appropriate kind of methods can be event handlers.              |\n\n### Keywords that are used for programming that uses delegates\n\nThe following table shows the keywords that describe the use of delegates.\n\n| Keyword or term                         | Code                                                                     | Description                                                                                                                                                                                                                                                                             |\n|-----------------------------------------|--------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| delegate                                | delegate myDelegate(str \\_information) {}                                | The code shows what the delegate looks like in the method editor in the Microsoft MorphX client. Because the return type is always **void**, it isn't mentioned in the syntax. No code is allowed inside the braces ({}).                                                               |\n| eventHandler                            | myClassInstance.myDelegate += eventHandler(otherClass.myInstanceMethod); | Although the syntax of the **eventHandler** keyword might give the impression that **eventHandler** is an X++ function, it isn't a function. The **eventHandler** keyword tells the compiler that a method is being subscribed to a delegate.                                           |\n| Subscribe or add a method to a delegate | myClassInstance.myDelegate += eventHandler(OtherClass::aStaticMethod);   | In the code, the static method **OtherClass::aStaticMethod** becomes subscribed to the delegate.                                                                                                                                                                                        |\n| Call a delegate                         | myClassInstance.myDelegate(\"Hello\");                                     | This call to the delegate prompts the delegate to call each method that is subscribed to the delegate. The subscribed methods are called in the same order in which they were added to the delegate. One subscribed method must be completed before the delegate calls the next method. |\n\n\n\n\n\n","nodes":[{"pos":[4,651],"embed":true,"restype":"x-metadata","content":"# required metadata\n\ntitle: X++ classes and methods\ndescription: This topic describes how to create and use classes and interfaces in X++.\nauthor: RobinARH\nmanager: AnnBe\nms.date: 06/20/2017\nms.topic: article\nms.prod: \nms.service: dynamics-ax-platform\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \nms.reviewer: robinr\nms.search.scope: AX 7.0.0, Operations, UnifiedOperations\n# ms.tgt_pltfrm: \nms.custom: 150303\nms.assetid: 1b2d76d1-52d9-46b2-937f-5a3b62f2d516\nms.search.region: Global\n# ms.search.industry: \nms.author: robinr\nms.search.validFrom: 2016-02-28\nms.dyn365.ops.version: AX 7.0.0\n","nodes":[{"content":"X++ classes and methods","nodes":[{"pos":[0,23],"content":"X++ classes and methods","nodes":[{"content":"X++ classes and methods","pos":[0,23]}]}],"path":["title"],"extradata":"MT"},{"content":"This topic describes how to create and use classes and interfaces in X++.","nodes":[{"pos":[0,73],"content":"This topic describes how to create and use classes and interfaces in X++.","nodes":[{"content":"This topic describes how to create and use classes and interfaces in X++.","pos":[0,73]}]}],"path":["description"],"extradata":"MT"}],"header":"# required metadata\n","yml":true},{"pos":[659,682],"content":"X++ classes and methods","linkify":"X++ classes and methods","nodes":[{"content":"X++ classes and methods","pos":[0,23]}]},{"content":"This topic describes how to create and use classes and interfaces in X++.","pos":[728,801]},{"pos":[803,817],"content":"Classes in X++","linkify":"Classes in X++","nodes":[{"content":"Classes in X++","pos":[0,14]}]},{"content":"A <bpt id=\"p1\">*</bpt>class<ept id=\"p1\">*</ept> is a software construct that defines the data and methods of the objects that are later constructed from that class.","pos":[834,960],"source":"A *class* is a software construct that defines the data and methods of the objects that are later constructed from that class."},{"content":"The objects that are constructed are known as <bpt id=\"p1\">*</bpt>instances<ept id=\"p1\">*</ept> or <bpt id=\"p2\">*</bpt>objects<ept id=\"p2\">*</ept>.","pos":[961,1032],"source":" The objects that are constructed are known as *instances* or *objects*."},{"content":"(This topic uses the two terms interchangeably.) The data represents the state of the object, whereas the methods represent the behavior of the object.","pos":[1033,1184]},{"content":"<bpt id=\"p1\">*</bpt>Variables<ept id=\"p1\">*</ept> contain the data for the class.","pos":[1185,1228],"source":"*Variables* contain the data for the class."},{"content":"Variables in a class are specific to objects that are constructed from that class.","pos":[1229,1311]},{"content":"Every object that is constructed from the class declaration has its own copy of the variables.","pos":[1312,1406]},{"content":"These variables are known as <bpt id=\"p1\">*</bpt>instance variables<ept id=\"p1\">*</ept>.","pos":[1407,1457],"source":" These variables are known as *instance variables*."},{"content":"Methods define the behavior of a class.","pos":[1458,1497]},{"content":"They are the sequences of statements that operate on the data.","pos":[1498,1560]},{"content":"Typically, methods are declared to operate on the instance variables of the class.","pos":[1561,1643]},{"content":"These methods are known as <bpt id=\"p1\">*</bpt>instance methods<ept id=\"p1\">*</ept> or <bpt id=\"p2\">*</bpt>object methods<ept id=\"p2\">*</ept>.","pos":[1644,1710],"source":" These methods are known as *instance methods* or *object methods*."},{"content":"You can also declare <bpt id=\"p1\">*</bpt>static methods<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>static fields<ept id=\"p2\">*</ept>.","pos":[1711,1769],"source":" You can also declare *static methods* and *static fields*."},{"pos":[1774,1796],"content":"Declaration of classes","linkify":"Declaration of classes","nodes":[{"content":"Declaration of classes","pos":[0,22]}]},{"pos":[1801,1832],"content":"Create a class in Visual Studio","linkify":"Create a class in Visual Studio","nodes":[{"content":"Create a class in Visual Studio","pos":[0,31]}]},{"content":"Follow these steps to create a class in Microsoft Visual Studio.","pos":[1834,1898]},{"pos":[1904,1972],"content":"In Server Explorer, right-click the project, and then click <bpt id=\"p1\">**</bpt>Add<ept id=\"p1\">**</ept>.","source":"In Server Explorer, right-click the project, and then click **Add**."},{"pos":[1977,2063],"content":"In the <bpt id=\"p1\">**</bpt>New Item<ept id=\"p1\">**</ept> dialog box, select <bpt id=\"p2\">**</bpt>Class<ept id=\"p2\">**</ept>, and then enter a name for the class.","source":"In the **New Item** dialog box, select **Class**, and then enter a name for the class."},{"pos":[2068,2082],"content":"Click <bpt id=\"p1\">**</bpt>Add<ept id=\"p1\">**</ept>.","source":"Click **Add**."},{"content":"All classes are public.","pos":[2084,2107]},{"content":"If you remove the <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept> modifier, the system still treats the class as public.","pos":[2108,2191],"source":" If you remove the **public** modifier, the system still treats the class as public."},{"content":"You can specify other modifiers on the class declaration, such as <bpt id=\"p1\">**</bpt>final<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>extends<ept id=\"p2\">**</ept>.","pos":[2192,2284],"source":" You can specify other modifiers on the class declaration, such as **final** and **extends**."},{"pos":[2290,2319],"content":"Creating variables in a class","linkify":"Creating variables in a class","nodes":[{"content":"Creating variables in a class","pos":[0,29]}]},{"content":"All classes are public, but all member variables are implicitly private.","pos":[2321,2393]},{"content":"However, even though all member variables are private, you can't decorate a member variable with the <bpt id=\"p1\">**</bpt>private<ept id=\"p1\">**</ept> keyword.","pos":[2394,2515],"source":" However, even though all member variables are private, you can't decorate a member variable with the **private** keyword."},{"content":"All member variables belong to only object instances of the class.","pos":[2516,2582]},{"content":"The following example shows how to use accessor methods to make the variable data public.","pos":[2583,2672]},{"pos":[2935,2947],"content":"Constructors","linkify":"Constructors","nodes":[{"content":"Constructors","pos":[0,12]}]},{"content":"To create an instance of a class, you must instantiate it by using a <bpt id=\"p1\">*</bpt>constructor<ept id=\"p1\">*</ept>.","pos":[2948,3031],"source":"To create an instance of a class, you must instantiate it by using a *constructor*."},{"content":"The default constructor is the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> method.","pos":[3032,3078],"source":" The default constructor is the **new** method."},{"content":"As a best practice, you should make the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> method protected.","pos":[3235,3300],"source":"As a best practice, you should make the **new** method protected."},{"content":"Instead, if initialization isn't required, you should use a <bpt id=\"p1\">**</bpt>static construct<ept id=\"p1\">**</ept> method as the public constructor for the class.","pos":[3301,3429],"source":" Instead, if initialization isn't required, you should use a **static construct** method as the public constructor for the class."},{"content":"Otherwise, you should use a <bpt id=\"p1\">**</bpt>static new<ept id=\"p1\">**</ept> method.","pos":[3430,3480],"source":" Otherwise, you should use a **static new** method."},{"pos":[3486,3525],"content":"Creating other objects in a constructor","linkify":"Creating other objects in a constructor","nodes":[{"content":"Creating other objects in a constructor","pos":[0,39]}]},{"content":"A class constructor can instantiate other objects in addition to creating an instance of the class.","pos":[3527,3626]},{"content":"For example, the following code declares a <bpt id=\"p1\">**</bpt>Rectangle<ept id=\"p1\">**</ept> class that uses two <bpt id=\"p2\">**</bpt>Point<ept id=\"p2\">**</ept> objects to define its bounds.","pos":[3627,3743],"source":" For example, the following code declares a **Rectangle** class that uses two **Point** objects to define its bounds."},{"pos":[4067,4078],"content":"Destructors","linkify":"Destructors","nodes":[{"content":"Destructors","pos":[0,11]}]},{"content":"A <bpt id=\"p1\">*</bpt>destructor<ept id=\"p1\">*</ept> is used to explicitly destroy a class object.","pos":[4079,4139],"source":"A *destructor* is used to explicitly destroy a class object."},{"content":"Objects are automatically destroyed when there are no references to them.","pos":[4140,4213]},{"content":"However, you can destroy objects explicitly in the following ways:","pos":[4214,4280]},{"pos":[4286,4314],"content":"Use the <bpt id=\"p1\">**</bpt>finalize<ept id=\"p1\">**</ept> method.","source":"Use the **finalize** method."},{"pos":[4319,4353],"content":"Set the object handle to <bpt id=\"p1\">**</bpt>null<ept id=\"p1\">**</ept>.","source":"Set the object handle to **null**."},{"pos":[4359,4384],"content":"Using the finalize method","linkify":"Using the finalize method","nodes":[{"content":"Using the finalize method","pos":[0,25]}]},{"content":"Use the <bpt id=\"p1\">**</bpt>finalize<ept id=\"p1\">**</ept> method to explicitly destroy an object.","pos":[4386,4446],"source":"Use the **finalize** method to explicitly destroy an object."},{"content":"There are no implicit calls to the <bpt id=\"p1\">**</bpt>finalize<ept id=\"p1\">**</ept> method.","pos":[4447,4502],"source":" There are no implicit calls to the **finalize** method."},{"content":"You must call the method to run the statements in it.","pos":[4503,4556]},{"content":"The following example shows the basic structure for a call to the <bpt id=\"p1\">**</bpt>finalize<ept id=\"p1\">**</ept> method.","pos":[4557,4643],"source":" The following example shows the basic structure for a call to the **finalize** method."},{"content":"In the <bpt id=\"p1\">**</bpt>finalize<ept id=\"p1\">**</ept> method, you should also put any clean-up code that is required.","pos":[4777,4860],"source":"In the **finalize** method, you should also put any clean-up code that is required."},{"content":"For example, if your class uses a dynamic-link library (DLL) module, you can use the <bpt id=\"p1\">**</bpt>finalize<ept id=\"p1\">**</ept> method to release the DLL when you no longer require it.","pos":[4861,5015],"source":" For example, if your class uses a dynamic-link library (DLL) module, you can use the **finalize** method to release the DLL when you no longer require it."},{"content":"Use the <bpt id=\"p1\">**</bpt>finalize<ept id=\"p1\">**</ept> method carefully.","pos":[5016,5054],"source":" Use the **finalize** method carefully."},{"content":"It will destroy an object even if there are references to it.","pos":[5055,5116]},{"pos":[5122,5154],"content":"Setting an object handle to null","linkify":"Setting an object handle to null","nodes":[{"content":"Setting an object handle to null","pos":[0,32]}]},{"content":"Set the object handle to <bpt id=\"p1\">**</bpt>null<ept id=\"p1\">**</ept> to terminate an object.","pos":[5156,5213],"source":"Set the object handle to **null** to terminate an object."},{"content":"This approach destroys an object only if no other object handles point to that object.","pos":[5214,5300]},{"content":"You should verify that other code isn't using the object handle.","pos":[5301,5365]},{"content":"The following example creates an object handle and then sets it to <bpt id=\"p1\">**</bpt>null<ept id=\"p1\">**</ept>.","pos":[5366,5442],"source":" The following example creates an object handle and then sets it to **null**."},{"pos":[5662,5681],"content":"Creating a subclass","linkify":"Creating a subclass","nodes":[{"content":"Creating a subclass","pos":[0,19]}]},{"content":"<bpt id=\"p1\">*</bpt>Subclasses<ept id=\"p1\">*</ept> are classes that extend or inherit from other classes.","pos":[5682,5749],"source":"*Subclasses* are classes that extend or inherit from other classes."},{"content":"A class can extend only one other class.","pos":[5750,5790]},{"content":"Multiple inheritance isn't supported.","pos":[5791,5828]},{"content":"If you extend a class, the subclass inherits all the methods and variables in the parent class (the <bpt id=\"p1\">*</bpt>superclass<ept id=\"p1\">*</ept>).","pos":[5829,5943],"source":" If you extend a class, the subclass inherits all the methods and variables in the parent class (the *superclass*)."},{"content":"Subclasses let you reuse existing code for a more specific purpose.","pos":[5944,6011]},{"content":"Therefore, they help save you time during design, development, and testing.","pos":[6012,6087]},{"content":"To customize the behavior of a superclass, override the methods in a subclass.","pos":[6088,6166]},{"content":"A superclass is often known as a <bpt id=\"p1\">*</bpt>base class<ept id=\"p1\">*</ept>, and a subclass is often known as a <bpt id=\"p2\">*</bpt>derived class<ept id=\"p2\">*</ept>.","pos":[6167,6265],"source":" A superclass is often known as a *base class*, and a subclass is often known as a *derived class*."},{"pos":[6271,6287],"content":"Subclass example","linkify":"Subclass example","nodes":[{"content":"Subclass example","pos":[0,16]}]},{"content":"The following example first creates a class that is named <bpt id=\"p1\">**</bpt>Point<ept id=\"p1\">**</ept>.","pos":[6289,6357],"source":"The following example first creates a class that is named **Point**."},{"content":"It then extends the <bpt id=\"p1\">**</bpt>Point<ept id=\"p1\">**</ept> class to create a new class that is named <bpt id=\"p2\">**</bpt>ThreePoint<ept id=\"p2\">**</ept>.","pos":[6358,6445],"source":" It then extends the **Point** class to create a new class that is named **ThreePoint**."},{"pos":[7033,7061],"content":"Preventing class inheritance","linkify":"Preventing class inheritance","nodes":[{"content":"Preventing class inheritance","pos":[0,28]}]},{"pos":[7063,7140],"content":"You can prevent classes from being inherited by using the <bpt id=\"p1\">**</bpt>final<ept id=\"p1\">**</ept> modifier.","source":"You can prevent classes from being inherited by using the **final** modifier."},{"pos":[7216,7223],"content":"Methods","linkify":"Methods","nodes":[{"content":"Methods","pos":[0,7]}]},{"content":"The following code block types are standard for application classes:","pos":[7224,7292]},{"content":"****classDescription** declaration block** – This declaration block contains class modifiers such as <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>private<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>extends<ept id=\"p3\">**</ept>.","pos":[7298,7440],"source":"****classDescription** declaration block** – This declaration block contains class modifiers such as **public**, **private**, and **extends**."},{"content":"It also contains the field members for objects that are constructed from the class.","pos":[7441,7524]},{"content":"When you type the keyword <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept>, IntelliSense can show a list of the members.","pos":[7525,7605],"source":" When you type the keyword **this**, IntelliSense can show a list of the members."},{"content":"****new** method** – This method creates an instance of the class.","pos":[7610,7676]},{"content":"The constructor can be called only by using the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> keyword.","pos":[7677,7741],"source":" The constructor can be called only by using the **new** keyword."},{"content":"Derived classes can call the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> method of their constructor by calling the <bpt id=\"p2\">**</bpt>super<ept id=\"p2\">**</ept> method reference.","pos":[7742,7849],"source":" Derived classes can call the **new** method of their constructor by calling the **super** method reference."},{"content":"****finalize** method** – This method finalizes an instance of the class.","pos":[7854,7927]},{"content":"This method is the destructor method.","pos":[7928,7965]},{"content":"However, it's a destructor by convention only.","pos":[7966,8012]},{"content":"The system doesn't automatically call the <bpt id=\"p1\">**</bpt>finalize<ept id=\"p1\">**</ept> method during garbage collection.","pos":[8013,8101],"source":" The system doesn't automatically call the **finalize** method during garbage collection."},{"content":"Additional methods for a class have the following types:","pos":[8103,8159]},{"content":"Instance methods","pos":[8165,8181]},{"content":"Static methods","pos":[8186,8200]},{"content":"Main methods","pos":[8205,8217]},{"content":"Methods can be created on many kinds of items.","pos":[8219,8265]},{"content":"Here are some examples:","pos":[8266,8289]},{"content":"Classes","pos":[8295,8302]},{"content":"Maps","pos":[8307,8311]},{"content":"Views","pos":[8316,8321]},{"content":"Data Sets","pos":[8326,8335]},{"content":"Forms","pos":[8340,8345]},{"content":"Queries","pos":[8350,8357]},{"pos":[8363,8379],"content":"Instance methods","linkify":"Instance methods","nodes":[{"content":"Instance methods","pos":[0,16]}]},{"content":"Instance methods, or object methods, are embedded in each object that is created from the class.","pos":[8381,8477]},{"content":"You must instantiate the object before you can use the method.","pos":[8478,8540]},{"content":"If you later convert an instance method to a static method, you must restart the client.","pos":[8541,8629]},{"content":"Otherwise, the compiler doesn't detect the change.","pos":[8630,8680]},{"content":"After you've converted an instance method to a static method, you can no longer call the method from the instance of the class.","pos":[8681,8808]},{"content":"Instead, you must call the method from the class itself.","pos":[8809,8865]},{"content":"Static methods are discussed in the next section.","pos":[8866,8915]},{"content":"You use the following syntax to call instance methods.","pos":[8916,8970]},{"pos":[9062,9076],"content":"Static methods","linkify":"Static methods","nodes":[{"content":"Static methods","pos":[0,14]}]},{"content":"Static methods, which are also known as <bpt id=\"p1\">*</bpt>class methods<ept id=\"p1\">*</ept>, belong to a class and are created by using the keyword <bpt id=\"p2\">**</bpt>static<ept id=\"p2\">**</ept>.","pos":[9078,9201],"source":"Static methods, which are also known as *class methods*, belong to a class and are created by using the keyword **static**."},{"content":"You don't have to instantiate an object before you use static methods.","pos":[9202,9272]},{"content":"Static methods are often used to work with data that is stored in tables.","pos":[9273,9346]},{"content":"Member variables can't be used in a static method.","pos":[9347,9397]},{"content":"You use the following syntax to call static methods.","pos":[9398,9450]},{"pos":[9486,9498],"content":"Main methods","linkify":"Main methods","nodes":[{"content":"Main methods","pos":[0,12]}]},{"content":"A <bpt id=\"p1\">**</bpt>main<ept id=\"p1\">**</ept> method is a class method that is run directly from a menu option.","pos":[9500,9576],"source":"A **main** method is a class method that is run directly from a menu option."},{"content":"The method should only create an instance of the object and then call the required member methods.","pos":[9577,9675]},{"content":"The <bpt id=\"p1\">**</bpt><ph id=\"ph1\">\\_</ph>args<ept id=\"p1\">**</ept> parameter lets you transfer data to the method.","pos":[9676,9738],"source":" The **\\_args** parameter lets you transfer data to the method."},{"pos":[9818,9840],"content":"Declaration of methods","linkify":"Declaration of methods","nodes":[{"content":"Declaration of methods","pos":[0,22]}]},{"content":"Method declarations consist of a header and a body.","pos":[9842,9893]},{"content":"The method header declares the method's name and return type), the method modifiers, and parameters.","pos":[9894,9994]},{"content":"(The return type might be <bpt id=\"p1\">**</bpt>void<ept id=\"p1\">**</ept>.) The method body consists of variable declarations, method declarations, and statements.","pos":[9995,10119],"source":" (The return type might be **void**.) The method body consists of variable declarations, method declarations, and statements."},{"pos":[10125,10136],"content":"Return type","linkify":"Return type","nodes":[{"content":"Return type","pos":[0,11]}]},{"content":"If a method doesn't return anything, you must use the <bpt id=\"p1\">**</bpt>void<ept id=\"p1\">**</ept> keyword.","pos":[10138,10209],"source":"If a method doesn't return anything, you must use the **void** keyword."},{"content":"The following example shows two methods.","pos":[10210,10250]},{"content":"One method has a return type, but the other method doesn't have a return type.","pos":[10251,10329]},{"pos":[10583,10589],"content":"Syntax","linkify":"Syntax","nodes":[{"content":"Syntax","pos":[0,6]}]},{"pos":[10591,11360],"content":"Method declaration = <bpt id=\"p1\">*</bpt>Heading<ept id=\"p1\">*</ept>  <bpt id=\"p2\">*</bpt>Body<ept id=\"p2\">*</ept> Heading = <bpt id=\"p3\">**</bpt><ph id=\"ph1\">\\[</ph><ept id=\"p3\">**</ept> <bpt id=\"p4\">*</bpt>Modifiers<ept id=\"p4\">*</ept> <bpt id=\"p5\">**</bpt><ph id=\"ph2\">\\]</ph><ept id=\"p5\">**</ept>  <bpt id=\"p6\">*</bpt>ReturnType<ept id=\"p6\">*</ept>  <bpt id=\"p7\">*</bpt>MethodName<ept id=\"p7\">*</ept>  <bpt id=\"p8\">**</bpt>(<ept id=\"p8\">**</ept>  <bpt id=\"p9\">*</bpt>ParameterList<ept id=\"p9\">*</ept>  <bpt id=\"p10\">**</bpt>)<ept id=\"p10\">**</ept> Modifiers = <bpt id=\"p11\">**</bpt><ph id=\"ph3\">\\[</ph>client<ph id=\"ph4\">\\]</ph> <ph id=\"ph5\">\\[</ph>server<ph id=\"ph6\">\\]</ph> <ph id=\"ph7\">\\[</ph>edit | display | public | protected | private<ph id=\"ph8\">\\]</ph> <ph id=\"ph9\">\\[</ph>static | abstract | final <ph id=\"ph10\">\\]</ph><ept id=\"p11\">**</ept> ReturnType = <bpt id=\"p12\">*</bpt>Datatype<ept id=\"p12\">*</ept>  <bpt id=\"p13\">**</bpt>| void | anytype<ept id=\"p13\">**</ept> MethodName = <bpt id=\"p14\">*</bpt>Identifier<ept id=\"p14\">*</ept> ParameterList = <bpt id=\"p15\">**</bpt><ph id=\"ph11\">\\[</ph><ept id=\"p15\">**</ept> <bpt id=\"p16\">*</bpt>Parameter<ept id=\"p16\">*</ept>  <bpt id=\"p17\">**</bpt>{ ,<ept id=\"p17\">**</ept>  <bpt id=\"p18\">*</bpt>Parameter<ept id=\"p18\">*</ept>  <bpt id=\"p19\">**</bpt>}<ph id=\"ph12\">\\]</ph><ept id=\"p19\">**</ept> Parameter = <bpt id=\"p20\">*</bpt>Datatype<ept id=\"p20\">*</ept>  <bpt id=\"p21\">*</bpt>Variableidentifier<ept id=\"p21\">*</ept>  <bpt id=\"p22\">**</bpt><ph id=\"ph13\">\\[</ph><ph id=\"ph14\"> =</ph><ept id=\"p22\">**</ept>  <bpt id=\"p23\">*</bpt>Expression<ept id=\"p23\">*</ept>  <bpt id=\"p24\">**</bpt><ph id=\"ph15\">\\]</ph><ept id=\"p24\">**</ept> Body = <bpt id=\"p25\">**</bpt>{ <ph id=\"ph16\">\\[</ph><ept id=\"p25\">**</ept>  <bpt id=\"p26\">*</bpt>VariableDeclarations<ept id=\"p26\">*</ept>  <bpt id=\"p27\">**</bpt><ph id=\"ph17\">\\]</ph> <ph id=\"ph18\">\\[</ph><ept id=\"p27\">**</ept>  <bpt id=\"p28\">*</bpt>EmbeddedFunctionDeclarations<ept id=\"p28\">*</ept>  <bpt id=\"p29\">**</bpt><ph id=\"ph19\">\\]</ph> <ph id=\"ph20\">\\[</ph><ept id=\"p29\">**</ept>  <bpt id=\"p30\">*</bpt>Statements<ept id=\"p30\">*</ept>  <bpt id=\"p31\">**</bpt><ph id=\"ph21\">\\]</ph> }<ept id=\"p31\">**</ept> EmbeddedFunctionDeclaration = <bpt id=\"p32\">*</bpt>Heading<ept id=\"p32\">*</ept>  <bpt id=\"p33\">**</bpt>{<ph id=\"ph22\">\\[</ph><ept id=\"p33\">**</ept>  <bpt id=\"p34\">*</bpt>VariableDeclarations<ept id=\"p34\">*</ept>  <bpt id=\"p35\">**</bpt><ph id=\"ph23\">\\]</ph> <ph id=\"ph24\">\\[</ph><ept id=\"p35\">**</ept>  <bpt id=\"p36\">*</bpt>Statements<ept id=\"p36\">*</ept>  <bpt id=\"p37\">**</bpt><ph id=\"ph25\">\\]</ph>}<ept id=\"p37\">**</ept> If you use the <bpt id=\"p38\">**</bpt>anytype<ept id=\"p38\">**</ept> return type, the method can return any data type.","source":"Method declaration = *Heading*  *Body* Heading = **\\[** *Modifiers* **\\]**  *ReturnType*  *MethodName*  **(**  *ParameterList*  **)** Modifiers = **\\[client\\] \\[server\\] \\[edit | display | public | protected | private\\] \\[static | abstract | final \\]** ReturnType = *Datatype*  **| void | anytype** MethodName = *Identifier* ParameterList = **\\[** *Parameter*  **{ ,**  *Parameter*  **}\\]** Parameter = *Datatype*  *Variableidentifier*  **\\[ =**  *Expression*  **\\]** Body = **{ \\[**  *VariableDeclarations*  **\\] \\[**  *EmbeddedFunctionDeclarations*  **\\] \\[**  *Statements*  **\\] }** EmbeddedFunctionDeclaration = *Heading*  **{\\[**  *VariableDeclarations*  **\\] \\[**  *Statements*  **\\]}** If you use the **anytype** return type, the method can return any data type."},{"pos":[11366,11417],"content":"Example of a method that doesn't have a return type","linkify":"Example of a method that doesn't have a return type","nodes":[{"content":"Example of a method that doesn't have a return type","pos":[0,51]}]},{"pos":[12005,12044],"content":"Example of a method that has parameters","linkify":"Example of a method that has parameters","nodes":[{"content":"Example of a method that has parameters","pos":[0,39]}]},{"pos":[12046,12171],"content":"In the following example, the <bpt id=\"p1\">**</bpt>checkAccountBlocked<ept id=\"p1\">**</ept> method returns a Boolean value and acts on the <bpt id=\"p2\">**</bpt>amountCur<ept id=\"p2\">**</ept> parameter.","source":"In the following example, the **checkAccountBlocked** method returns a Boolean value and acts on the **amountCur** parameter."},{"pos":[12470,12486],"content":"Method modifiers","linkify":"Method modifiers","nodes":[{"content":"Method modifiers","pos":[0,16]}]},{"content":"Several modifiers can be applied to method declarations.","pos":[12487,12543]},{"content":"Some of the modifiers can be combined (for example, <bpt id=\"p1\">**</bpt>final static<ept id=\"p1\">**</ept>).","pos":[12544,12614],"source":" Some of the modifiers can be combined (for example, **final static**)."},{"content":"Here are the method modifier keywords:","pos":[12615,12653]},{"content":"<bpt id=\"p1\">**</bpt>abstract<ept id=\"p1\">**</ept> – The method is declared but isn't implemented in a parent class.","pos":[12659,12737],"source":"**abstract** – The method is declared but isn't implemented in a parent class."},{"content":"The method must be overridden in subclasses.","pos":[12738,12782]},{"content":"If you try to create an object from a subclass where one or more abstract methods that belong to the parent class haven't been overridden, you receive a compiler error.","pos":[12783,12951]},{"content":"Classes can also be abstract.","pos":[12952,12981]},{"content":"Sometimes, a class should not be instantiated even though it represents an abstract concept.","pos":[12982,13074]},{"content":"Only subclasses should be instantiated.","pos":[13075,13114]},{"content":"Base classes of this type can be declared as <bpt id=\"p1\">**</bpt>abstract<ept id=\"p1\">**</ept>.","pos":[13115,13173],"source":" Base classes of this type can be declared as **abstract**."},{"content":"For example, you want to model the concept of an account.","pos":[13174,13231]},{"content":"Accounts are abstract, because only derived classes (ledger accounts and so on) exist in the real world.","pos":[13232,13336]},{"content":"This examples describes a clear case where you should declare the <bpt id=\"p1\">**</bpt>Account<ept id=\"p1\">**</ept> class as <bpt id=\"p2\">**</bpt>abstract<ept id=\"p2\">**</ept>.","pos":[13337,13437],"source":" This examples describes a clear case where you should declare the **Account** class as **abstract**."},{"content":"<bpt id=\"p1\">**</bpt>display<ept id=\"p1\">**</ept> – The method's return value should be shown on a page or a report.","pos":[13442,13520],"source":"**display** – The method's return value should be shown on a page or a report."},{"content":"The value can't be modified on the page or report.","pos":[13521,13571]},{"content":"Typically, the return value is a calculated value, such as a sum.","pos":[13572,13637]},{"content":"<bpt id=\"p1\">**</bpt>edit<ept id=\"p1\">**</ept> – The method's return type should be used to provide information for a field that is used on a page.","pos":[13642,13751],"source":"**edit** – The method's return type should be used to provide information for a field that is used on a page."},{"content":"The value in the field can be modified.","pos":[13752,13791]},{"pos":[13796,13880],"content":"<bpt id=\"p1\">**</bpt>final<ept id=\"p1\">**</ept> – The method can't be overridden in any class that derives from its class.","source":"**final** – The method can't be overridden in any class that derives from its class."},{"content":"<bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept> – Methods that are declared as <bpt id=\"p2\">**</bpt>public<ept id=\"p2\">**</ept> can be accessed anywhere that the class is accessible, and they can be overridden by subclasses.","pos":[13885,14034],"source":"**public** – Methods that are declared as **public** can be accessed anywhere that the class is accessible, and they can be overridden by subclasses."},{"content":"Methods that have no access modifier are implicitly public.","pos":[14035,14094]},{"pos":[14099,14272],"content":"<bpt id=\"p1\">**</bpt>protected<ept id=\"p1\">**</ept> – Methods that are declared as <bpt id=\"p2\">**</bpt>protected<ept id=\"p2\">**</ept> can be called only from methods in the class and in subclasses that extend the class where the method is declared.","source":"**protected** – Methods that are declared as **protected** can be called only from methods in the class and in subclasses that extend the class where the method is declared."},{"pos":[14277,14414],"content":"<bpt id=\"p1\">**</bpt>private<ept id=\"p1\">**</ept> – Methods that are declared as <bpt id=\"p2\">**</bpt>private<ept id=\"p2\">**</ept> can be called only from methods in the class where the private method is declared.","source":"**private** – Methods that are declared as **private** can be called only from methods in the class where the private method is declared."},{"content":"<bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> – The method is a class method and doesn't act on an instance.","pos":[14419,14492],"source":"**static** – The method is a class method and doesn't act on an instance."},{"content":"Static methods can't refer to instance variables.","pos":[14493,14542]},{"content":"They aren't invoked on an instance of the class.","pos":[14543,14591]},{"content":"Instead, the are invoked by using the class name (for example, <bpt id=\"p1\">**</bpt>MyClass::aStaticProcedure()<ept id=\"p1\">**</ept>).","pos":[14592,14688],"source":" Instead, the are invoked by using the class name (for example, **MyClass::aStaticProcedure()**)."},{"pos":[14694,14721],"content":"Methods that have modifiers","linkify":"Methods that have modifiers","nodes":[{"content":"Methods that have modifiers","pos":[0,27]}]},{"pos":[14723,14785],"content":"<bpt id=\"p1\">**</bpt>Note:<ept id=\"p1\">**</ept> The following examples show only the method headers.","source":"**Note:** The following examples show only the method headers."},{"pos":[14987,15007],"content":"Static class members","linkify":"Static class members","nodes":[{"content":"Static class members","pos":[0,20]}]},{"content":"You declare static class members by using the <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> keyword.","pos":[15008,15073],"source":"You declare static class members by using the **static** keyword."},{"content":"The <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> keyword instructs the system to create only one instance of the method, regardless of the number of times that you call <bpt id=\"p2\">**</bpt>new<ept id=\"p2\">**</ept>.","pos":[15074,15217],"source":" The **static** keyword instructs the system to create only one instance of the method, regardless of the number of times that you call **new**."},{"content":"This one instance is used throughout your session.","pos":[15218,15268]},{"content":"In general, static methods are intended for cases where the following criteria are met:","pos":[15269,15356]},{"content":"The method has no reason to access the member variables that are declared in the class.","pos":[15362,15449]},{"content":"The method has no reason to call any instance (non-static) methods of the class.","pos":[15454,15534]},{"pos":[15541,15555],"content":"Static methods","linkify":"Static methods","nodes":[{"content":"Static methods","pos":[0,14]}]},{"content":"This section describes a scenario where a software key type is used to help prevent piracy.","pos":[15557,15648]},{"content":"Each instance of a software key can have its own unique value.","pos":[15649,15711]},{"content":"However, because all software keys must conform to the rules of software key design, the logic that tests for software key conformance is the same for all software keys.","pos":[15712,15881]},{"content":"Therefore, the method that contains the conformance validation logic should be static.","pos":[15882,15968]},{"content":"Here is an example of a method that is declared by using the <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> keyword.","pos":[15969,16049],"source":" Here is an example of a method that is declared by using the **static** keyword."},{"content":"In the following example, you don't have to construct an instance of the <bpt id=\"p1\">**</bpt>SoftwareKey<ept id=\"p1\">**</ept> class before you call a static method on the class.","pos":[16163,16303],"source":"In the following example, you don't have to construct an instance of the **SoftwareKey** class before you call a static method on the class."},{"content":"When you want to call the static <bpt id=\"p1\">**</bpt>validateSoftwareKey<ept id=\"p1\">**</ept> method, the syntax starts with the name of the class that contains the method.","pos":[16304,16439],"source":" When you want to call the static **validateSoftwareKey** method, the syntax starts with the name of the class that contains the method."},{"content":"A pair of colons (::) is used to connect the class name to the static method name.","pos":[16440,16522]},{"pos":[16610,16623],"content":"Static fields","linkify":"Static fields","nodes":[{"content":"Static fields","pos":[0,13]}]},{"content":"Static fields are fields that are declared by using the <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept> keyword.","pos":[16625,16700],"source":"Static fields are fields that are declared by using the **static** keyword."},{"content":"Conceptually, they apply to the class, not to instances of the class.","pos":[16701,16770]},{"pos":[16776,16795],"content":"Static constructors","linkify":"Static constructors","nodes":[{"content":"Static constructors","pos":[0,19]}]},{"content":"Static constructors are guaranteed to run before any static or instance calls are made to the class.","pos":[16797,16897]},{"content":"In C<ph id=\"ph1\">\\#</ph>, the <bpt id=\"p1\">*</bpt>static<ept id=\"p1\">*</ept> concept is related to the whole executing application domain.","pos":[16898,16980],"source":" In C\\#, the *static* concept is related to the whole executing application domain."},{"content":"However, in X++, the execution of the static constructor is relative to the user’s session.","pos":[16981,17072]},{"content":"The static constructor has the following syntax.","pos":[17073,17121]},{"content":"You never explicitly call the static constructor.","pos":[17151,17200]},{"content":"The compiler will generate code to make sure that the constructor is called exactly one time before any other method on the class.","pos":[17201,17331]},{"content":"A static constructor is used to initialize any static data or perform a particular action that must be performed only one time.","pos":[17332,17459]},{"content":"No parameters can be provided for the static constructor, and it must be marked as <bpt id=\"p1\">**</bpt>static<ept id=\"p1\">**</ept>.","pos":[17460,17554],"source":" No parameters can be provided for the static constructor, and it must be marked as **static**."},{"content":"The following example shows how to create a singleton instance by using a static constructor.","pos":[17555,17648]},{"content":"The singleton guarantees that only one instance of the class will ever be called.","pos":[17948,18029]},{"content":"The following example shows how to instantiate the singleton.","pos":[18030,18091]},{"pos":[18154,18175],"content":"Method access control","linkify":"Method access control","nodes":[{"content":"Method access control","pos":[0,21]}]},{"content":"You use the accessor keywords <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>protected<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>private<ept id=\"p3\">**</ept> to control whether the methods in other classes can call the methods on your class.","pos":[18176,18332],"source":"You use the accessor keywords **public**, **protected**, and **private** to control whether the methods in other classes can call the methods on your class."},{"content":"The accessor keywords on methods also interact with the rules for class inheritance.","pos":[18333,18417]},{"content":"Here are the accessor keywords that you use with methods:","pos":[18418,18475]},{"content":"<bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept> – Methods that are declared as <bpt id=\"p2\">**</bpt>public<ept id=\"p2\">**</ept> can be called from anywhere that the class is accessible.","pos":[18481,18591],"source":"**public** – Methods that are declared as **public** can be called from anywhere that the class is accessible."},{"content":"In addition, a public method can be overridden by a subclass, unless the method is declared as <bpt id=\"p1\">**</bpt>final<ept id=\"p1\">**</ept>.","pos":[18592,18697],"source":" In addition, a public method can be overridden by a subclass, unless the method is declared as **final**."},{"pos":[18702,18807],"content":"<bpt id=\"p1\">**</bpt>protected<ept id=\"p1\">**</ept> – Methods that are declared as <bpt id=\"p2\">**</bpt>protected<ept id=\"p2\">**</ept> can be called only from the following methods:","source":"**protected** – Methods that are declared as **protected** can be called only from the following methods:"},{"content":"Methods in the class.","pos":[18816,18837]},{"content":"Methods in a subclass of the class that contains the protected method.","pos":[18846,18916]},{"content":"Methods that are protected can be overridden in subclasses.","pos":[18917,18976]},{"content":"<bpt id=\"p1\">**</bpt>private<ept id=\"p1\">**</ept> – Methods that are declared as <bpt id=\"p2\">**</bpt>private<ept id=\"p2\">**</ept> can be called only from methods in the class where the private method is declared.","pos":[18981,19118],"source":"**private** – Methods that are declared as **private** can be called only from methods in the class where the private method is declared."},{"content":"No private method can be overridden in a subclass.","pos":[19119,19169]},{"content":"By default, when you create a new method, the <bpt id=\"p1\">**</bpt>private<ept id=\"p1\">**</ept> accessor keyword appears in the code editor.","pos":[19170,19272],"source":" By default, when you create a new method, the **private** accessor keyword appears in the code editor."},{"content":"For maximum security, <bpt id=\"p1\">**</bpt>private<ept id=\"p1\">**</ept> is the most conservative default accessor keyword.","pos":[19273,19357],"source":" For maximum security, **private** is the most conservative default accessor keyword."},{"pos":[19363,19390],"content":"Static and instance methods","linkify":"Static and instance methods","nodes":[{"content":"Static and instance methods","pos":[0,27]}]},{"content":"The accessor keywords on methods never restrict calls between two methods that are in the same class, regardless of which method is static or non-static.","pos":[19392,19545]},{"content":"In a static method, calls to the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> constructor method are valid even if the <bpt id=\"p2\">**</bpt>new<ept id=\"p2\">**</ept> constructor method is decorated with the <bpt id=\"p3\">**</bpt>private<ept id=\"p3\">**</ept> modifier.","pos":[19546,19698],"source":" In a static method, calls to the **new** constructor method are valid even if the **new** constructor method is decorated with the **private** modifier."},{"content":"The syntax for these calls requires that the <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> keyword be used.","pos":[19699,19768],"source":" The syntax for these calls requires that the **new** keyword be used."},{"content":"The code in a static method must construct an instance object of its own class before it can call any instance methods on the class.","pos":[19769,19901]},{"pos":[19907,19941],"content":"Increasing access during overrides","linkify":"Increasing access during overrides","nodes":[{"content":"Increasing access during overrides","pos":[0,34]}]},{"content":"When a method is overridden in a subclass, the overriding method must be at least as accessible as the overridden method.","pos":[19943,20064]},{"content":"For example, the following compiler rules apply when a protected method is overridden in a subclass:","pos":[20065,20165]},{"content":"A public method in a superclass can be overridden only by a public method in the subclass.","pos":[20171,20261]},{"content":"In a subclass, a public or protected method can override a protected method of the superclass.","pos":[20266,20360]},{"content":"In a subclass, a private method can't override a protected method of the superclass.","pos":[20365,20449]},{"pos":[20454,20473],"content":"Optional parameters","linkify":"Optional parameters","nodes":[{"content":"Optional parameters","pos":[0,19]}]},{"content":"Parameters can be initialized in the method declaration.","pos":[20474,20530]},{"content":"In this case, the parameter becomes an <bpt id=\"p1\">*</bpt>optional parameter<ept id=\"p1\">*</ept>.","pos":[20531,20591],"source":" In this case, the parameter becomes an *optional parameter*."},{"content":"If no value is supplied in the method call, the default value is used.","pos":[20592,20662]},{"content":"All required parameters must be listed before the first optional parameter.","pos":[20663,20738]},{"content":"The following examples show how to create and call a method that has optional parameters.","pos":[20739,20828]},{"content":"The example of the <bpt id=\"p1\">**</bpt>AddThreeInts<ept id=\"p1\">**</ept> method shows that you can't skip default parameters when you call a method.","pos":[20829,20940],"source":" The example of the **AddThreeInts** method shows that you can't skip default parameters when you call a method."},{"pos":[20946,20977],"content":"Examples of optional parameters","linkify":"Examples of optional parameters","nodes":[{"content":"Examples of optional parameters","pos":[0,31]}]},{"pos":[23433,23449],"content":"Accessor methods","linkify":"Accessor methods","nodes":[{"content":"Accessor methods","pos":[0,16]}]},{"content":"Class variables are private.","pos":[23450,23478]},{"content":"By hiding details of the internal implementation of a class, you can change the implementation of the class later without breaking any code that uses that class.","pos":[23479,23640]},{"content":"To access the data from reference variables, you must create accessor methods.","pos":[23641,23719]},{"content":"The following example defines a <bpt id=\"p1\">**</bpt>Point<ept id=\"p1\">**</ept> class that uses accessor methods to access the variables <bpt id=\"p2\">**</bpt>x<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>y<ept id=\"p3\">**</ept>.","pos":[23720,23835],"source":" The following example defines a **Point** class that uses accessor methods to access the variables **x** and **y**."},{"content":"These method declarations show how the <bpt id=\"p1\">**</bpt>Point<ept id=\"p1\">**</ept> class provides access to its variables from the outside world.","pos":[24392,24503],"source":"These method declarations show how the **Point** class provides access to its variables from the outside world."},{"content":"Other objects can manipulate the instance variables of <bpt id=\"p1\">**</bpt>Point<ept id=\"p1\">**</ept> objects by using the accessor methods.","pos":[24504,24607],"source":" Other objects can manipulate the instance variables of **Point** objects by using the accessor methods."},{"content":"The depth of the call stack is limited to 100.","pos":[24899,24945]},{"pos":[24950,24969],"content":"Overriding a method","linkify":"Overriding a method","nodes":[{"content":"Overriding a method","pos":[0,19]}]},{"content":"The methods in a class are inherited by any class that extends it.","pos":[24970,25036]},{"content":"To change the functionality of an inherited method, you can create a method in the subclass, and then give that method the same name and parameters as the method in the superclass.","pos":[25037,25217]},{"content":"This process is known as <bpt id=\"p1\">*</bpt>overriding<ept id=\"p1\">*</ept> the method.","pos":[25218,25267],"source":" This process is known as *overriding* the method."},{"content":"In the following example, <bpt id=\"p1\">**</bpt>ColorAttribute<ept id=\"p1\">**</ept> is a subclass of <bpt id=\"p2\">**</bpt>Attribute<ept id=\"p2\">**</ept> and therefore inherits the <bpt id=\"p3\">**</bpt>methodAttr<ept id=\"p3\">**</ept> method.","pos":[25268,25393],"source":" In the following example, **ColorAttribute** is a subclass of **Attribute** and therefore inherits the **methodAttr** method."},{"content":"However, because <bpt id=\"p1\">**</bpt>ColorAttribute<ept id=\"p1\">**</ept> defines a method that has the same name and the same number of arguments, the method in the superclass is overridden.","pos":[25394,25547],"source":" However, because **ColorAttribute** defines a method that has the same name and the same number of arguments, the method in the superclass is overridden."},{"pos":[25930,25957],"content":"Preventing method overrides","linkify":"Preventing method overrides","nodes":[{"content":"Preventing method overrides","pos":[0,27]}]},{"content":"Static methods can't be overridden, because they exist per class.","pos":[25959,26024]},{"content":"To protect other sensitive methods, or core methods, from being overridden, use the <bpt id=\"p1\">**</bpt>final<ept id=\"p1\">**</ept> modifier.","pos":[26025,26128],"source":" To protect other sensitive methods, or core methods, from being overridden, use the **final** modifier."},{"content":"In the following example, because <bpt id=\"p1\">**</bpt>methodAtt<ept id=\"p1\">**</ept> is declared as <bpt id=\"p2\">**</bpt>final<ept id=\"p2\">**</ept>, it can't be overridden in any class that extends <bpt id=\"p3\">**</bpt>Attribute<ept id=\"p3\">**</ept>.","pos":[26129,26266],"source":" In the following example, because **methodAtt** is declared as **final**, it can't be overridden in any class that extends **Attribute**."},{"content":"You should not specify <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>finalize<ept id=\"p2\">**</ept> methods as <bpt id=\"p3\">**</bpt>final<ept id=\"p3\">**</ept>.","pos":[26267,26335],"source":" You should not specify **new** or **finalize** methods as **final**."},{"content":"The following example shows how to use the <bpt id=\"p1\">**</bpt>final<ept id=\"p1\">**</ept> keyword.","pos":[26336,26397],"source":" The following example shows how to use the **final** keyword."},{"pos":[26553,26579],"content":"Overriding vs. overloading","linkify":"Overriding vs. overloading","nodes":[{"content":"Overriding vs. overloading","pos":[0,26]}]},{"content":"Overriding occurs when the superclass's implementation of a method is changed by the subclass's implementation of that method, but the signatures of both methods are the same.","pos":[26581,26756]},{"content":"By contrast, <bpt id=\"p1\">*</bpt>overloading<ept id=\"p1\">*</ept> occurs when more than one method has the same name, but the methods have different signatures (return types, parameter lists, or both).","pos":[26757,26919],"source":" By contrast, *overloading* occurs when more than one method has the same name, but the methods have different signatures (return types, parameter lists, or both)."},{"content":"X++ supports overriding, but it doesn't support overloading.","pos":[26920,26980]},{"pos":[26985,26995],"content":"Parameters","linkify":"Parameters","nodes":[{"content":"Parameters","pos":[0,10]}]},{"content":"All methods have their own <bpt id=\"p1\">*</bpt>scope<ept id=\"p1\">*</ept>.","pos":[26996,27031],"source":"All methods have their own *scope*."},{"content":"A method can take one or more parameters.","pos":[27032,27073]},{"content":"Within the scope of the method, these parameters are treated as local variables and are initialized with a value from the parameter in the method call.","pos":[27074,27225]},{"content":"All parameters are passed by value.","pos":[27226,27261]},{"content":"You can't change the value of the original variable.","pos":[27262,27314]},{"content":"You can change only the local variable in the method.","pos":[27315,27368]},{"content":"This local variable is a copy of the original variable.","pos":[27369,27424]},{"pos":[27429,27458],"content":"Scope of variables in methods","linkify":"Scope of variables in methods","nodes":[{"content":"Scope of variables in methods","pos":[0,29]}]},{"content":"A scope defines the area in which an item can be accessed.","pos":[27459,27517]},{"content":"Variables that are defined in a class are available to the methods within that class.","pos":[27518,27603]},{"content":"Variables in methods can be accessed only within the current block.","pos":[27604,27671]},{"pos":[27676,27691],"content":"Local functions","linkify":"Local functions","nodes":[{"content":"Local functions","pos":[0,15]}]},{"content":"You can declare local functions inside a method.","pos":[27692,27740]},{"content":"However, as a best practice, you shouldn't add local functions inside the method.","pos":[27741,27822]},{"content":"Instead, you should add private methods to the class.","pos":[27823,27876]},{"content":"The following example shows valid declarations of two local functions, <bpt id=\"p1\">**</bpt>localFunc55b<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>localFunc66c<ept id=\"p2\">**</ept>.","pos":[27877,27986],"source":" The following example shows valid declarations of two local functions, **localFunc55b** and **localFunc66c**."},{"content":"Calls to the local functions occur after the function declarations in the example, as is required.","pos":[27987,28085]},{"pos":[28953,28983],"content":"Declaration of local functions","linkify":"Declaration of local functions","nodes":[{"content":"Declaration of local functions","pos":[0,30]}]},{"content":"The declarations of local functions must physically precede any non-declaration statements in the method.","pos":[28989,29094]},{"content":"You can declare more than one local function in your method.","pos":[29099,29159]},{"content":"However, all local functions must be declared in an uninterrupted series, and the set must be terminated by one semicolon (;).","pos":[29160,29286]},{"pos":[29292,29306],"content":"Variable scope","linkify":"Variable scope","nodes":[{"content":"Variable scope","pos":[0,14]}]},{"content":"Code that is inside the local function can access variables that are declared in the method that contains the local function.","pos":[29312,29437]},{"content":"Code that is outside the local function can't access variables that are declared in the local function.","pos":[29442,29545]},{"pos":[29551,29575],"content":"Calls to local functions","linkify":"Calls to local functions","nodes":[{"content":"Calls to local functions","pos":[0,24]}]},{"content":"A local function can be called only by code in the same method where the local function is declared.","pos":[29581,29681]},{"content":"A local function should never call itself.","pos":[29686,29728]},{"content":"Such recursion can prevent successful compilation.","pos":[29729,29779]},{"pos":[29784,29800],"content":"The this keyword","linkify":"The this keyword","nodes":[{"content":"The this keyword","pos":[0,16]}]},{"content":"The <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> keyword is a reference to the instance of the class or table where the <bpt id=\"p2\">**</bpt>this<ept id=\"p2\">**</ept> keyword is used.","pos":[29801,29910],"source":"The **this** keyword is a reference to the instance of the class or table where the **this** keyword is used."},{"content":"The <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> reference is never required, but it can clarify your code and enhances the behavior of IntelliSense in the code editor.","pos":[29911,30043],"source":" The **this** reference is never required, but it can clarify your code and enhances the behavior of IntelliSense in the code editor."},{"content":"All calls to instance methods must be qualified by either the <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> reference or a variable.","pos":[30044,30139],"source":" All calls to instance methods must be qualified by either the **this** reference or a variable."},{"content":"The <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> reference can be used to qualify the following information:","pos":[30140,30212],"source":" The **this** reference can be used to qualify the following information:"},{"content":"The names of other instance (non-static) methods in the same class where the <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> reference is used.","pos":[30218,30322],"source":"The names of other instance (non-static) methods in the same class where the **this** reference is used."},{"content":"Here is an example: <bpt id=\"p1\">**</bpt>boolColorChanged = this.colorItOrange();<ept id=\"p1\">**</ept>","pos":[30323,30387],"source":" Here is an example: **boolColorChanged = this.colorItOrange();**"},{"pos":[30392,30455],"content":"The names of methods that are inherited by the <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> object.","source":"The names of methods that are inherited by the **this** object."},{"pos":[30460,30555],"content":"The names of fields on the table that contains the method that the <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> keyword is used in.","source":"The names of fields on the table that contains the method that the **this** keyword is used in."},{"pos":[30557,30616],"content":"The <bpt id=\"p1\">**</bpt>this<ept id=\"p1\">**</ept> reference can't be used in the following ways:","source":"The **this** reference can't be used in the following ways:"},{"pos":[30622,30720],"content":"It can't qualify the names of member variables that are declared in the <bpt id=\"p1\">**</bpt>classDeclaration<ept id=\"p1\">**</ept> code.","source":"It can't qualify the names of member variables that are declared in the **classDeclaration** code."},{"content":"It can't be used in a static method.","pos":[30725,30761]},{"content":"It can't qualify the names of static methods of the class or table.","pos":[30766,30833]},{"pos":[30838,30848],"content":"Interfaces","linkify":"Interfaces","nodes":[{"content":"Interfaces","pos":[0,10]}]},{"content":"An <bpt id=\"p1\">*</bpt>interface<ept id=\"p1\">*</ept> is a specification for a set of public instance methods.","pos":[30849,30920],"source":"An *interface* is a specification for a set of public instance methods."},{"content":"An interface defines and enforces similarities between unrelated classes without having to derive one class from the other.","pos":[30921,31044]},{"content":"All interfaces are public, even if you don't explicitly add the <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept> keyword ****in front of the <bpt id=\"p2\">**</bpt>interface<ept id=\"p2\">**</ept> keyword ****in the <bpt id=\"p3\">**</bpt>classDeclaration<ept id=\"p3\">**</ept> code.","pos":[31045,31207],"source":" All interfaces are public, even if you don't explicitly add the **public** keyword ****in front of the **interface** keyword ****in the **classDeclaration** code."},{"content":"The methods on an interface are also public.","pos":[31208,31252]},{"content":"Once again, explicit inclusion of the keyword <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept> is optional.","pos":[31253,31322],"source":" Once again, explicit inclusion of the keyword **public** is optional."},{"content":"To create an interface, follow these steps.","pos":[31323,31366]},{"pos":[31372,31440],"content":"In Server Explorer, right-click the project, and then click <bpt id=\"p1\">**</bpt>Add<ept id=\"p1\">**</ept>.","source":"In Server Explorer, right-click the project, and then click **Add**."},{"pos":[31445,31539],"content":"In the <bpt id=\"p1\">**</bpt>New Item<ept id=\"p1\">**</ept> dialog box, select <bpt id=\"p2\">**</bpt>Interface<ept id=\"p2\">**</ept>, and then enter a name for the interface.","source":"In the **New Item** dialog box, select **Interface**, and then enter a name for the interface."},{"pos":[31544,31558],"content":"Click <bpt id=\"p1\">**</bpt>Add<ept id=\"p1\">**</ept>.","source":"Click **Add**."},{"content":"When you add the <bpt id=\"p1\">**</bpt>implements<ept id=\"p1\">**</ept> keyword on a class declaration, the class must declare the methods that are specified by the interface.","pos":[31560,31695],"source":"When you add the **implements** keyword on a class declaration, the class must declare the methods that are specified by the interface."},{"content":"A class declaration can implement multiple interfaces.","pos":[31696,31750]},{"content":"Just list the interfaces after the single occurrence of the <bpt id=\"p1\">**</bpt>implements<ept id=\"p1\">**</ept> keyword, and separate the interface names by using commas.","pos":[31751,31884],"source":" Just list the interfaces after the single occurrence of the **implements** keyword, and separate the interface names by using commas."},{"content":"All interface methods that a class implements must be explicitly declared as <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept> by using the <bpt id=\"p2\">**</bpt>public<ept id=\"p2\">**</ept> keyword in the class.","pos":[31885,32018],"source":" All interface methods that a class implements must be explicitly declared as **public** by using the **public** keyword in the class."},{"content":"A class that implements an interface must also be declared as <bpt id=\"p1\">**</bpt>public<ept id=\"p1\">**</ept>.","pos":[32019,32092],"source":" A class that implements an interface must also be declared as **public**."},{"content":"An interface can extend another interface by using the <bpt id=\"p1\">**</bpt>extends<ept id=\"p1\">**</ept> keyword.","pos":[32093,32168],"source":" An interface can extend another interface by using the **extends** keyword."},{"content":"However, an interface can't extend more than one interface.","pos":[32169,32228]},{"pos":[32234,32251],"content":"Interface example","linkify":"Interface example","nodes":[{"content":"Interface example","pos":[0,17]}]},{"content":"In the following example, an <bpt id=\"p1\">**</bpt>Automobile<ept id=\"p1\">**</ept> class implements an <bpt id=\"p2\">**</bpt>IDrivable<ept id=\"p2\">**</ept> interface.","pos":[32253,32341],"source":"In the following example, an **Automobile** class implements an **IDrivable** interface."},{"content":"The <bpt id=\"p1\">**</bpt>is<ept id=\"p1\">**</ept> keyword is supported and lets you test whether a class implements an interface.","pos":[32342,32432],"source":" The **is** keyword is supported and lets you test whether a class implements an interface."},{"pos":[33498,33520],"content":"Class library overview","linkify":"Class library overview","nodes":[{"content":"Class library overview","pos":[0,22]}]},{"pos":[33521,33596],"content":"There are two kinds of classes: <bpt id=\"p1\">*</bpt>application classes<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>system classes<ept id=\"p2\">*</ept>.","source":"There are two kinds of classes: *application classes* and *system classes*."},{"content":"<bpt id=\"p1\">**</bpt>Application classes<ept id=\"p1\">**</ept> – These classes are implemented in X++.","pos":[33602,33665],"source":"**Application classes** – These classes are implemented in X++."},{"content":"They are available in the <bpt id=\"p1\">**</bpt>Classes<ept id=\"p1\">**</ept> node in Application Explorer.","pos":[33666,33733],"source":" They are available in the **Classes** node in Application Explorer."},{"content":"<bpt id=\"p1\">**</bpt>System classes<ept id=\"p1\">**</ept> – These classes are sometimes known as <bpt id=\"p2\">*</bpt>kernel classes<ept id=\"p2\">*</ept> and are implemented in C++.","pos":[33738,33840],"source":"**System classes** – These classes are sometimes known as *kernel classes* and are implemented in C++."},{"content":"They are listed under the <bpt id=\"p1\">**</bpt>System Documentation<ept id=\"p1\">**</ept> <ph id=\"ph1\">&amp;gt;</ph> <bpt id=\"p2\">**</bpt>Classes<ept id=\"p2\">**</ept> node in Application Explorer.","pos":[33841,33938],"source":" They are listed under the **System Documentation** &gt; **Classes** node in Application Explorer."},{"content":"However, the source code for these classes isn't available.","pos":[33939,33998]},{"pos":[34000,34085],"content":"For a list of these classes, see <bpt id=\"p1\">[</bpt>API, class, and table reference<ept id=\"p1\">](api-reference.md)</ept>.","source":"For a list of these classes, see [API, class, and table reference](api-reference.md)."},{"pos":[34090,34141],"content":"Substituting application classes for system classes","linkify":"Substituting application classes for system classes","nodes":[{"content":"Substituting application classes for system classes","pos":[0,51]}]},{"content":"You should call the <bpt id=\"p1\">*</bpt>substitute application classes<ept id=\"p1\">*</ept> instead of the system classes that they extend.","pos":[34142,34242],"source":"You should call the *substitute application classes* instead of the system classes that they extend."},{"content":"In Application Explorer, under <bpt id=\"p1\">**</bpt>System Documentation<ept id=\"p1\">**</ept> <ph id=\"ph1\">&amp;gt;</ph> <bpt id=\"p2\">**</bpt>Classes<ept id=\"p2\">**</ept>, several kernel or system classes have names that begin with a lowercase <bpt id=\"p3\">*</bpt>x<ept id=\"p3\">*</ept>.","pos":[34243,34393],"source":" In Application Explorer, under **System Documentation** &gt; **Classes**, several kernel or system classes have names that begin with a lowercase *x*."},{"content":"These classes are known as <bpt id=\"p1\">*</bpt>x-system classes<ept id=\"p1\">*</ept>.","pos":[34394,34440],"source":" These classes are known as *x-system classes*."},{"content":"Examples of these system classes are <bpt id=\"p1\">**</bpt>xApplication<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>xVersionControl<ept id=\"p2\">**</ept>.","pos":[34441,34519],"source":" Examples of these system classes are **xApplication** and **xVersionControl**."},{"content":"Some of these classes are extended by application classes.","pos":[34520,34578]},{"content":"For example, the <bpt id=\"p1\">**</bpt>Application<ept id=\"p1\">**</ept> class extends the <bpt id=\"p2\">**</bpt>xApplication<ept id=\"p2\">**</ept> system class.","pos":[34579,34660],"source":" For example, the **Application** class extends the **xApplication** system class."},{"content":"The classes that derive from x-system classes are known as substitute application classes.","pos":[34661,34751]},{"content":"In Application Explorer, under the <bpt id=\"p1\">**</bpt>Classes<ept id=\"p1\">**</ept> node, the icon next to the substitute application classes differs from the standard icon.","pos":[34752,34888],"source":" In Application Explorer, under the **Classes** node, the icon next to the substitute application classes differs from the standard icon."},{"pos":[34894,34910],"content":"x-system classes","linkify":"x-system classes","nodes":[{"content":"x-system classes","pos":[0,16]}]},{"content":"Some of the substitute application classes are associated with a special global variable that represents an instance of the class.","pos":[34912,35042]},{"content":"For example, the <bpt id=\"p1\">**</bpt>appl<ept id=\"p1\">**</ept> variable references a pre-instantiated object from the <bpt id=\"p2\">**</bpt>Application<ept id=\"p2\">**</ept> class.","pos":[35043,35146],"source":" For example, the **appl** variable references a pre-instantiated object from the **Application** class."},{"content":"The advantage of the <bpt id=\"p1\">**</bpt>appl<ept id=\"p1\">**</ept> variable is that the system maintains the object throughout the scope of your session.","pos":[35147,35263],"source":" The advantage of the **appl** variable is that the system maintains the object throughout the scope of your session."},{"content":"Your code would be less efficient if it repeatedly used the <bpt id=\"p1\">**</bpt>new Application()<ept id=\"p1\">**</ept> syntax to obtain an instance of the <bpt id=\"p2\">**</bpt>Application<ept id=\"p2\">**</ept> class.","pos":[35264,35404],"source":" Your code would be less efficient if it repeatedly used the **new Application()** syntax to obtain an instance of the **Application** class."},{"content":"You should not use the <bpt id=\"p1\">**</bpt>xApplication<ept id=\"p1\">**</ept> system class.","pos":[35405,35458],"source":" You should not use the **xApplication** system class."},{"content":"Instead, use the <bpt id=\"p1\">**</bpt>Application<ept id=\"p1\">**</ept> substitute application class.","pos":[35459,35521],"source":" Instead, use the **Application** substitute application class."},{"content":"You can reference the static members of the <bpt id=\"p1\">**</bpt>Application<ept id=\"p1\">**</ept> class by using the following standard syntax: <bpt id=\"p2\">**</bpt>Application::checkForNewBatchJobs()<ept id=\"p2\">**</ept>.","pos":[35522,35668],"source":" You can reference the static members of the **Application** class by using the following standard syntax: **Application::checkForNewBatchJobs()**."},{"content":"However, to reference the instance members of the <bpt id=\"p1\">**</bpt>Application<ept id=\"p1\">**</ept> class, you should use that class's <bpt id=\"p2\">**</bpt>appl<ept id=\"p2\">**</ept> variable, if it exists.","pos":[35669,35802],"source":" However, to reference the instance members of the **Application** class, you should use that class's **appl** variable, if it exists."},{"content":"This pattern applies to most of the x-system classes.","pos":[35803,35856]},{"content":"The <bpt id=\"p1\">**</bpt>Session<ept id=\"p1\">**</ept> substitute application class is one exception, because there is no special global variable for <bpt id=\"p2\">**</bpt>Session<ept id=\"p2\">**</ept>.","pos":[35857,35980],"source":" The **Session** substitute application class is one exception, because there is no special global variable for **Session**."},{"content":"The following table lists the x-system classes that have a corresponding substitute application class.","pos":[35981,36083]},{"content":"The special global variables are also shown for those classes that have one.","pos":[36084,36160]},{"content":"Application class","pos":[36164,36181]},{"content":"x-system class","pos":[36184,36198]},{"content":"Global variable","pos":[36202,36217]},{"content":"Args","pos":[36286,36290]},{"content":"xArgs","pos":[36306,36311]},{"content":"Not applicable","pos":[36324,36338]},{"content":"Application","pos":[36347,36358]},{"content":"xApplication","pos":[36367,36379]},{"pos":[36385,36393],"content":"<bpt id=\"p1\">**</bpt>appl<ept id=\"p1\">**</ept>","source":"**appl**"},{"content":"ClassFactory","pos":[36408,36420]},{"content":"xClassFactory","pos":[36428,36441]},{"pos":[36446,36462],"content":"<bpt id=\"p1\">**</bpt>classFactory<ept id=\"p1\">**</ept>","source":"**classFactory**"},{"content":"Company","pos":[36469,36476]},{"content":"xCompany","pos":[36489,36497]},{"pos":[36507,36523],"content":"<bpt id=\"p1\">**</bpt>appl.company<ept id=\"p1\">**</ept>","source":"**appl.company**"},{"content":"Global","pos":[36530,36536]},{"content":"xGlobal","pos":[36550,36557]},{"content":"Not applicable","pos":[36568,36582]},{"content":"Info","pos":[36591,36595]},{"content":"xInfo","pos":[36611,36616]},{"pos":[36629,36640],"content":"<bpt id=\"p1\">**</bpt>Infolog<ept id=\"p1\">**</ept>","source":"**Infolog**"},{"content":"MenuFunction","pos":[36652,36664]},{"content":"xMenuFunction","pos":[36672,36685]},{"content":"Not applicable","pos":[36690,36704]},{"content":"Session","pos":[36713,36720]},{"content":"xSession","pos":[36733,36741]},{"content":"Not applicable","pos":[36751,36765]},{"content":"VersionControl","pos":[36774,36788]},{"content":"xVersionControl","pos":[36794,36809]},{"pos":[36812,36830],"content":"<bpt id=\"p1\">**</bpt>versionControl<ept id=\"p1\">**</ept>","source":"**versionControl**"},{"pos":[36838,36865],"content":"Example of x-system classes","linkify":"Example of x-system classes","nodes":[{"content":"Example of x-system classes","pos":[0,27]}]},{"content":"The following example shows the syntax for using several special variables that reference instances of the substitute application classes.","pos":[36867,37005]},{"pos":[37736,37760],"content":"Running startup commands","linkify":"Running startup commands","nodes":[{"content":"Running startup commands","pos":[0,24]}]},{"content":"You use the <bpt id=\"p1\">**</bpt>SysStartupCmd<ept id=\"p1\">**</ept> class framework to run commands at startup.","pos":[37761,37834],"source":"You use the **SysStartupCmd** class framework to run commands at startup."},{"content":"When Finance and Operations starts, calls are made to the <bpt id=\"p1\">**</bpt>startup<ept id=\"p1\">**</ept> methods on the application-substituted kernel classes <bpt id=\"p2\">**</bpt>Application<ept id=\"p2\">**</ept> (<bpt id=\"p3\">**</bpt>Application.startup<ept id=\"p3\">**</ept>) and <bpt id=\"p4\">**</bpt>Info<ept id=\"p4\">**</ept> (<bpt id=\"p5\">**</bpt>Info.startup<ept id=\"p5\">**</ept>).","pos":[37835,38033],"source":" When Finance and Operations starts, calls are made to the **startup** methods on the application-substituted kernel classes **Application** (**Application.startup**) and **Info** (**Info.startup**)."},{"content":"The <bpt id=\"p1\">**</bpt>startup<ept id=\"p1\">**</ept> methods are used for vital system and version-specific calls, and you must never directly modify these methods.","pos":[38034,38161],"source":" The **startup** methods are used for vital system and version-specific calls, and you must never directly modify these methods."},{"content":"Instead, use the <bpt id=\"p1\">**</bpt>SysStartupCmd<ept id=\"p1\">**</ept> framework.","pos":[38162,38207],"source":" Instead, use the **SysStartupCmd** framework."},{"content":"Serious issues can occur if the SYS layer versions of the <bpt id=\"p1\">**</bpt>startup<ept id=\"p1\">**</ept> methods aren't called.","pos":[38208,38300],"source":" Serious issues can occur if the SYS layer versions of the **startup** methods aren't called."},{"content":"The following example shows the order that calls are run in when Finance and Operations starts.","pos":[38301,38396]},{"pos":[38628,38690],"content":"Commands that are available when Finance and Operations starts","linkify":"Commands that are available when Finance and Operations starts","nodes":[{"content":"Commands that are available when Finance and Operations starts","pos":[0,62]}]},{"content":"The <bpt id=\"p1\">**</bpt>SysStartupCmd.construct<ept id=\"p1\">**</ept> method lists the commands that are available when Finance and Operations starts.","pos":[38692,38804],"source":"The **SysStartupCmd.construct** method lists the commands that are available when Finance and Operations starts."},{"content":"Here are some of these commands:","pos":[38805,38837]},{"content":"AutoRun","pos":[38843,38850]},{"content":"AOTImport","pos":[38855,38864]},{"content":"Synchronize","pos":[38869,38880]},{"content":"The following example shows how to run a new command when Finance and Operations starts.","pos":[38882,38970]},{"content":"First, a class that extends <bpt id=\"p1\">**</bpt>SysStartupCmd<ept id=\"p1\">**</ept> is created.","pos":[38971,39028],"source":" First, a class that extends **SysStartupCmd** is created."},{"content":"This new class performs your specific task.","pos":[39029,39072]},{"content":"You then modify the construct method on <bpt id=\"p1\">**</bpt>SysStartupCmd<ept id=\"p1\">**</ept> to call your class.","pos":[39073,39150],"source":" You then modify the construct method on **SysStartupCmd** to call your class."},{"content":"In the Finance and Operations Configuration Utility, on the <bpt id=\"p1\">**</bpt>General<ept id=\"p1\">**</ept> tab, in the <bpt id=\"p2\">**</bpt>Command to run at application startup<ept id=\"p2\">**</ept> field, you can add commands that are run at startup.","pos":[39151,39329],"source":" In the Finance and Operations Configuration Utility, on the **General** tab, in the **Command to run at application startup** field, you can add commands that are run at startup."},{"content":"Alternatively, you can use the <bpt id=\"p1\">**</bpt>-startupcmd= <bpt id=\"p2\">*</bpt>MyCommand<ept id=\"p2\">*</ept><ept id=\"p1\">**</ept> command-line parameter.","pos":[39330,39413],"source":" Alternatively, you can use the **-startupcmd= *MyCommand*** command-line parameter."},{"pos":[40228,40252],"content":"Batch processing classes","linkify":"Batch processing classes","nodes":[{"content":"Batch processing classes","pos":[0,24]}]},{"content":"You implement classes by using the batch processing system, and by extending the <bpt id=\"p1\">**</bpt>RunBase<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>RunBaseBatch<ept id=\"p2\">**</ept> classes.","pos":[40253,40375],"source":"You implement classes by using the batch processing system, and by extending the **RunBase** and **RunBaseBatch** classes."},{"content":"To remove the <bpt id=\"p1\">**</bpt>Recurrence<ept id=\"p1\">**</ept> button from the <bpt id=\"p2\">**</bpt>Batch processing<ept id=\"p2\">**</ept> dialog box, you use the <bpt id=\"p3\">**</bpt>Args::parmEnum<ept id=\"p3\">**</ept> method.","pos":[40376,40492],"source":" To remove the **Recurrence** button from the **Batch processing** dialog box, you use the **Args::parmEnum** method."},{"content":"We recommend that you designate a class to run as a server-bound batch method.","pos":[40493,40571]},{"content":"Server-bound batch methods are more secure than batch methods that aren't server-bound for the following reasons:","pos":[40572,40685]},{"content":"The method is run by using the permissions of the user who submitted the method.","pos":[40691,40771]},{"content":"The method can use only specific <bpt id=\"p1\">**</bpt>Info<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>Global<ept id=\"p2\">**</ept> class methods to interact with the client that is processing it.","pos":[40776,40897],"source":"The method can use only specific **Info** and **Global** class methods to interact with the client that is processing it."},{"content":"This restriction limits interaction with the client.","pos":[40898,40950]},{"pos":[40956,41008],"content":"Enable a class to run as a server-bound batch method","linkify":"Enable a class to run as a server-bound batch method","nodes":[{"content":"Enable a class to run as a server-bound batch method","pos":[0,52]}]},{"pos":[41014,41069],"content":"Create a class that extends the <bpt id=\"p1\">**</bpt>RunBaseBatch<ept id=\"p1\">**</ept> class.","source":"Create a class that extends the **RunBaseBatch** class."},{"pos":[41074,41193],"content":"Override the <bpt id=\"p1\">**</bpt>RunBaseBatch.runsImpersonated<ept id=\"p1\">**</ept> method to return a value of <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept>, as shown in the following example.","source":"Override the **RunBaseBatch.runsImpersonated** method to return a value of **true**, as shown in the following example."},{"pos":[41287,41373],"content":"Confirm that the class calls only the following <bpt id=\"p1\">**</bpt>Info<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>Global<ept id=\"p2\">**</ept> class methods:","source":"Confirm that the class calls only the following **Info** and **Global** class methods:"},{"content":"add","pos":[41382,41385]},{"content":"Info.copy","pos":[41394,41403]},{"content":"Info.cut","pos":[41412,41420]},{"content":"Info.import","pos":[41429,41440]},{"content":"Info.export","pos":[41449,41460]},{"content":"Info.line","pos":[41469,41478]},{"content":"Info.num","pos":[41487,41495]},{"content":"Global::error","pos":[41504,41517]},{"content":"Global::info","pos":[41526,41538]},{"content":"Global::warning","pos":[41547,41562]},{"pos":[41568,41660],"content":"<bpt id=\"p1\">**</bpt>Note:<ept id=\"p1\">**</ept> The <bpt id=\"p2\">**</bpt>Info.line<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>Info.num<ept id=\"p3\">**</ept> methods are inherited from the <bpt id=\"p4\">**</bpt>xInfo<ept id=\"p4\">**</ept> class.","source":"**Note:** The **Info.line** and **Info.num** methods are inherited from the **xInfo** class."},{"pos":[41666,41733],"content":"Removing the Recurrence button from the batch processing dialog box","linkify":"Removing the Recurrence button from the batch processing dialog box","nodes":[{"content":"Removing the Recurrence button from the batch processing dialog box","pos":[0,67]}]},{"content":"When you implement a class by using the batch processing system, you can remove the <bpt id=\"p1\">**</bpt>Recurrence<ept id=\"p1\">**</ept> button by calling the <bpt id=\"p2\">**</bpt>Args.parmEnum<ept id=\"p2\">**</ept> method and passing the <bpt id=\"p3\">**</bpt>NoYes::Yes<ept id=\"p3\">**</ept> system enumeration value.","pos":[41735,41937],"source":"When you implement a class by using the batch processing system, you can remove the **Recurrence** button by calling the **Args.parmEnum** method and passing the **NoYes::Yes** system enumeration value."},{"content":"The <bpt id=\"p1\">**</bpt>NoYes<ept id=\"p1\">**</ept> system enumeration determines whether the <bpt id=\"p2\">**</bpt>Recurrence<ept id=\"p2\">**</ept> button is removed from the dialog box.","pos":[41938,42047],"source":" The **NoYes** system enumeration determines whether the **Recurrence** button is removed from the dialog box."},{"content":"The default value is <bpt id=\"p1\">**</bpt>NoYes::No<ept id=\"p1\">**</ept>.","pos":[42048,42083],"source":" The default value is **NoYes::No**."},{"content":"In the following example, the <bpt id=\"p1\">**</bpt>InventTransferMultiShip<ept id=\"p1\">**</ept> class is implemented.","pos":[42084,42163],"source":" In the following example, the **InventTransferMultiShip** class is implemented."},{"content":"The <bpt id=\"p1\">**</bpt>BatchDialog::main<ept id=\"p1\">**</ept> method creates the <bpt id=\"p2\">**</bpt>Batch processing<ept id=\"p2\">**</ept> dialog box.","pos":[42164,42241],"source":" The **BatchDialog::main** method creates the **Batch processing** dialog box."},{"pos":[42580,42606],"content":"Image manipulation classes","linkify":"Image manipulation classes","nodes":[{"content":"Image manipulation classes","pos":[0,26]}]},{"pos":[42607,42696],"content":"Two system classes let you to manipulate graphics and icons: <bpt id=\"p1\">**</bpt>Image<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>Imagelist<ept id=\"p2\">**</ept>.","source":"Two system classes let you to manipulate graphics and icons: **Image** and **Imagelist**."},{"content":"<bpt id=\"p1\">**</bpt>Image<ept id=\"p1\">**</ept> – This class lets you load, save, and manipulate individual images.","pos":[42702,42779],"source":"**Image** – This class lets you load, save, and manipulate individual images."},{"content":"For example, you can capture a screen and save it as an image, crop or rotate an image, or manipulate the color depth.","pos":[42780,42898]},{"content":"<bpt id=\"p1\">**</bpt>Imagelist<ept id=\"p1\">**</ept> – This class lets you work with a set of images that have common properties, such as the size and transparency color.","pos":[42903,43034],"source":"**Imagelist** – This class lets you work with a set of images that have common properties, such as the size and transparency color."},{"content":"You can view the image lists that are used in Finance and Operations in the <bpt id=\"p1\">**</bpt>ImageListAppl<ph id=\"ph1\">\\_</ph><ph id=\"ph2\">\\*</ph><ept id=\"p1\">**</ept> application classes.","pos":[43035,43153],"source":" You can view the image lists that are used in Finance and Operations in the **ImageListAppl\\_\\*** application classes."},{"pos":[43158,43176],"content":"Query object model","linkify":"Query object model","nodes":[{"content":"Query object model","pos":[0,18]}]},{"content":"The query object model contains classes that are used to define and run a query.","pos":[43177,43257]},{"content":"The query objects are used to define the query data source, the fields that are returned, record ranges, and relations to child data sources.","pos":[43258,43399]},{"content":"The query classes are more visible when you create a dynamic query in code, but they are also used behind the scenes when you create a static query in Application Explorer.","pos":[43400,43572]},{"content":"The following table describes the classes in the query object model.","pos":[43573,43641]},{"content":"System class","pos":[43645,43657]},{"content":"Description","pos":[43668,43679]},{"content":"QueryRun","pos":[44763,44771]},{"content":"This class runs the query and fetches the data.","pos":[44786,44833]},{"content":"Query","pos":[45322,45327]},{"content":"This class holds some properties, and has one or more related data sources.","pos":[45345,45420]},{"content":"It's the top level of the query definition.","pos":[45421,45464]},{"content":"QueryBuildDataSource","pos":[45881,45901]},{"content":"This class defines access to a single data source in the query.","pos":[45904,45967]},{"content":"If there is more than one data source at the same level in a query, separate SQL statements are produced and are run sequentially.","pos":[45968,46098]},{"content":"If one data source is a child of another data source, a join is created between the two data sources.","pos":[46099,46200]},{"content":"QueryBuildFieldList","pos":[46440,46459]},{"content":"This class defines the fields that are returned from the database.","pos":[46463,46529]},{"content":"By default, the field list is dynamic, and all fields are returned from the data source table, map, or view.","pos":[46530,46638]},{"content":"Each data source has only one <bpt id=\"p1\">**</bpt>QueryBuildFieldList<ept id=\"p1\">**</ept> object.","pos":[46639,46700],"source":" Each data source has only one **QueryBuildFieldList** object."},{"content":"This object contains information about all selected fields.","pos":[46701,46760]},{"content":"You can specify aggregate functions, such as <bpt id=\"p1\">**</bpt>SUM<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>COUNT<ept id=\"p2\">**</ept>, and <bpt id=\"p3\">**</bpt>AVG<ept id=\"p3\">**</ept>, on the field list object.","pos":[46761,46864],"source":" You can specify aggregate functions, such as **SUM**, **COUNT**, and **AVG**, on the field list object."},{"content":"QueryBuildRange","pos":[46999,47014]},{"content":"This class defines a subset of records that is returned, based on a single field.","pos":[47022,47103]},{"content":"A range is translated into a <bpt id=\"p1\">**</bpt>WHERE<ept id=\"p1\">**</ept> clause in the query SQL statement.","pos":[47104,47177],"source":" A range is translated into a **WHERE** clause in the query SQL statement."},{"content":"If more than one field is used to limit the query (<bpt id=\"p1\">**</bpt>WHERE<ept id=\"p1\">**</ept> clause), the data source will contain more than one range.","pos":[47178,47297],"source":" If more than one field is used to limit the query (**WHERE** clause), the data source will contain more than one range."},{"content":"QueryBuildDynalink","pos":[47558,47576]},{"content":"This class contains information about a relation (limitation) to an external record.","pos":[47581,47665]},{"content":"When the query is run, this information is converted to additional entries in the <bpt id=\"p1\">**</bpt>WHERE<ept id=\"p1\">**</ept> clause of the query SQL statement.","pos":[47666,47792],"source":" When the query is run, this information is converted to additional entries in the **WHERE** clause of the query SQL statement."},{"content":"This class can exist only on the parent data source of a query.","pos":[47793,47856]},{"content":"Forms use the function when two data sources are synchronized.","pos":[47857,47919]},{"content":"The child data source will then contain one or more DLLs to the parent data source.","pos":[47920,48003]},{"content":"The function is used even if the two data sources are put in two different forms but are still synchronized.","pos":[48004,48112]},{"content":"QueryBuildLink","pos":[48117,48131]},{"content":"This class specifies the relation between the two data sources in the join.","pos":[48140,48215]},{"content":"This class can exist only on a child data source.","pos":[48216,48265]},{"pos":[48678,48701],"content":"System classes overview","linkify":"System classes overview","nodes":[{"content":"System classes overview","pos":[0,23]}]},{"content":"System classes (or kernel classes) are implemented in C++.","pos":[48702,48760]},{"content":"The source for these classes isn't available.","pos":[48761,48806]},{"content":"A system class can have the following characteristics:","pos":[48807,48861]},{"content":"Static methods (or class methods)","pos":[48867,48900]},{"content":"Dynamic methods","pos":[48905,48920]},{"content":"Properties – These properties are member functions that are used to set properties.","pos":[48925,49008]},{"content":"An example is <bpt id=\"p1\">**</bpt>LeftMargin<ept id=\"p1\">**</ept>.","pos":[49009,49038],"source":" An example is **LeftMargin**."},{"content":"You can't override system class methods.","pos":[49040,49080]},{"content":"It isn't our intention that you will use the system classes to design your application objects from scratch.","pos":[49081,49189]},{"content":"Instead, use them to extend or modify the default functionality in Application Explorer.","pos":[49190,49278]},{"content":"For example, you can dynamically add extra information to an existing report.","pos":[49279,49356]},{"content":"Alternatively, you can change the options that are available on a page, based on the user's selection on a previous page.","pos":[49357,49478]},{"pos":[49484,49502],"content":"Collection classes","linkify":"Collection classes","nodes":[{"content":"Collection classes","pos":[0,18]}]},{"pos":[49504,49583],"content":"The <bpt id=\"p1\">*</bpt>collection classes<ept id=\"p1\">*</ept> let you create lists, sets, structs, maps, and arrays.","source":"The *collection classes* let you create lists, sets, structs, maps, and arrays."},{"pos":[49589,49615],"content":"Application object classes","linkify":"Application object classes","nodes":[{"content":"Application object classes","pos":[0,26]}]},{"content":"These system classes hold functions that are activated whenever you use Application Explorer to create your application.","pos":[49617,49737]},{"content":"For example, the system uses the <bpt id=\"p1\">**</bpt>FormDesign<ept id=\"p1\">**</ept> class when you define the layout of your form in the <bpt id=\"p2\">**</bpt>Designs<ept id=\"p2\">**</ept> node in Application Explorer.","pos":[49738,49880],"source":" For example, the system uses the **FormDesign** class when you define the layout of your form in the **Designs** node in Application Explorer."},{"content":"These classes also let you to create and modify application objects.","pos":[49881,49949]},{"pos":[49955,49974],"content":"Integration classes","linkify":"Integration classes","nodes":[{"content":"Integration classes","pos":[0,19]}]},{"content":"The integration with the environment is typically implemented by classes.","pos":[49976,50049]},{"content":"Here are some examples of the classes in this category:","pos":[50050,50105]},{"pos":[50111,50156],"content":"<bpt id=\"p1\">**</bpt>COM<ept id=\"p1\">**</ept> – The call of methods on COM objects.","source":"**COM** – The call of methods on COM objects."},{"pos":[50161,50215],"content":"<bpt id=\"p1\">**</bpt>DLL<ept id=\"p1\">**</ept> – The call of Microsoft Windows DLL functions.","source":"**DLL** – The call of Microsoft Windows DLL functions."},{"pos":[50220,50259],"content":"<bpt id=\"p1\">**</bpt>IO<ept id=\"p1\">**</ept> – Read and write external files.","source":"**IO** – Read and write external files."},{"pos":[50264,50354],"content":"<bpt id=\"p1\">**</bpt>ODBCConnection<ept id=\"p1\">**</ept> – An Open Database Connectivity (ODBC) interface to a foreign database.","source":"**ODBCConnection** – An Open Database Connectivity (ODBC) interface to a foreign database."},{"pos":[50359,50389],"content":"Event terminology and keywords","linkify":"Event terminology and keywords","nodes":[{"content":"Event terminology and keywords","pos":[0,30]}]},{"content":"You can use the event design pattern to make your code more modular and reusable.","pos":[50390,50471]},{"content":"The term <bpt id=\"p1\">*</bpt>event<ept id=\"p1\">*</ept> is a metaphor that explains how delegates are used.","pos":[50472,50540],"source":" The term *event* is a metaphor that explains how delegates are used."},{"content":"When something important occurs during a program run, other modules might have to process the occurrence.","pos":[50541,50646]},{"content":"These important occurrences are known as <bpt id=\"p1\">*</bpt>events<ept id=\"p1\">*</ept>.","pos":[50647,50697],"source":" These important occurrences are known as *events*."},{"content":"When an event occurs, the program tells its notifier for the event that the notifier must send notifications about the event.","pos":[50698,50823]},{"content":"A notification must be sent to all the event handlers that are subscribers of the notifier.","pos":[50824,50915]},{"content":"When the program tells its notifier to send the notifications, we call that process <bpt id=\"p1\">*</bpt>raising<ept id=\"p1\">*</ept> an event.","pos":[50916,51019],"source":" When the program tells its notifier to send the notifications, we call that process *raising* an event."},{"content":"The following table shows the terms that are used to describe the event metaphor.","pos":[51020,51101]},{"content":"Term","pos":[51105,51109]},{"content":"Description","pos":[51121,51132]},{"content":"Event","pos":[51389,51394]},{"content":"An important occurrence in a program module where additional modules must process the occurrence.","pos":[51405,51502]},{"content":"Notifier","pos":[51531,51539]},{"content":"The program element that sends information about the event to all the event handlers that are subscribed to the notifier.","pos":[51547,51668]},{"content":"Subscriber","pos":[51673,51683]},{"content":"The program functions or methods that are subscribed to an event notifier.","pos":[51689,51763]},{"content":"Event handler","pos":[51815,51828]},{"content":"The methods that subscribe to an event notifier.","pos":[51831,51879]},{"content":"Only the appropriate kind of methods can be event handlers.","pos":[51880,51939]},{"pos":[51960,52018],"content":"Keywords that are used for programming that uses delegates","linkify":"Keywords that are used for programming that uses delegates","nodes":[{"content":"Keywords that are used for programming that uses delegates","pos":[0,58]}]},{"content":"The following table shows the keywords that describe the use of delegates.","pos":[52020,52094]},{"content":"Keyword or term","pos":[52098,52113]},{"content":"Code","pos":[52140,52144]},{"content":"Description","pos":[52215,52226]},{"content":"delegate","pos":[52900,52908]},{"content":"delegate myDelegate(str <ph id=\"ph1\">\\_</ph>information) {}","pos":[52942,52983],"source":"delegate myDelegate(str \\_information) {}"},{"content":"The code shows what the delegate looks like in the method editor in the Microsoft MorphX client.","pos":[53017,53113]},{"content":"Because the return type is always <bpt id=\"p1\">**</bpt>void<ept id=\"p1\">**</ept>, it isn't mentioned in the syntax.","pos":[53114,53191],"source":" Because the return type is always **void**, it isn't mentioned in the syntax."},{"content":"No code is allowed inside the braces ({}).","pos":[53192,53234]},{"content":"eventHandler","pos":[53301,53313]},{"content":"myClassInstance.myDelegate += eventHandler(otherClass.myInstanceMethod);","pos":[53343,53415]},{"content":"Although the syntax of the <bpt id=\"p1\">**</bpt>eventHandler<ept id=\"p1\">**</ept> keyword might give the impression that <bpt id=\"p2\">**</bpt>eventHandler<ept id=\"p2\">**</ept> is an X++ function, it isn't a function.","pos":[53418,53558],"source":"Although the syntax of the **eventHandler** keyword might give the impression that **eventHandler** is an X++ function, it isn't a function."},{"content":"The <bpt id=\"p1\">**</bpt>eventHandler<ept id=\"p1\">**</ept> keyword tells the compiler that a method is being subscribed to a delegate.","pos":[53559,53655],"source":" The **eventHandler** keyword tells the compiler that a method is being subscribed to a delegate."},{"content":"Subscribe or add a method to a delegate","pos":[53702,53741]},{"content":"myClassInstance.myDelegate += eventHandler(OtherClass::aStaticMethod);","pos":[53744,53814]},{"pos":[53819,53915],"content":"In the code, the static method <bpt id=\"p1\">**</bpt>OtherClass::aStaticMethod<ept id=\"p1\">**</ept> becomes subscribed to the delegate.","source":"In the code, the static method **OtherClass::aStaticMethod** becomes subscribed to the delegate."},{"content":"Call a delegate","pos":[54103,54118]},{"content":"myClassInstance.myDelegate(\"Hello\");","pos":[54145,54181]},{"content":"This call to the delegate prompts the delegate to call each method that is subscribed to the delegate.","pos":[54220,54322]},{"content":"The subscribed methods are called in the same order in which they were added to the delegate.","pos":[54323,54416]},{"content":"One subscribed method must be completed before the delegate calls the next method.","pos":[54417,54499]}]}