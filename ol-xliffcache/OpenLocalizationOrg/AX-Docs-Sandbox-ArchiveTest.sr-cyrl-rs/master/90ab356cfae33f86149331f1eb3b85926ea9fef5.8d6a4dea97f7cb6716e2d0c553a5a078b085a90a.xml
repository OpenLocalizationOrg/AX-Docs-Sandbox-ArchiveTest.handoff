{"content":"---\n# required metadata\n\ntitle: X++ and debugger features\ndescription: This tutorial is for developers to use advanced constructs of the X++ language and take advantage of productive debugger features. This is a walkthrough of the new features with exercises included to practice using these features. \nauthor: pvillads\nmanager: AnnBe\nms.date: 06/20/2017\nms.topic: article\nms.prod: \nms.service: dynamics-ax-platform\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \nms.reviewer: robinr\nms.search.scope: AX 7.0.0, Operations, UnifiedOperations\n# ms.tgt_pltfrm: \nms.custom: 26801\nms.assetid: 27c65e79-df74-4249-b684-97e1d40da753\nms.search.region: Global\n# ms.search.industry: \nms.author: pvillads\nms.search.validFrom: 2016-02-28\nms.dyn365.ops.version: AX 7.0.0\n\n---\n\n# X++ and debugger features\n\n[!include[banner](../includes/banner.md)]\n\n\nThis tutorial is for developers to use advanced constructs of the X++ language and take advantage of productive debugger features. This is a walkthrough of the new features with exercises included to practice using these features. \n\nIn previous versions, the X++ code was compiled into pseudo-code, or p-code, that was interpreted on the server or on the client application. This code was then subject to further compilation into CIL. Today the story is much simpler--only CIL is supported, and this code is generated from a new compiler. In this tutorial, we’ll be discussing some of the new features that have been added to the X++ language. As we run through the scenarios, you’ll also see some of the new features in the debugger.\n\n## Declare anywhere\nPreviously, all local variables had to be placed at the start of the method in which they’re used. Now, you have fine-grained control over the scope of your variables. With this new feature, it’s possible to provide smaller scopes for variables, outside of which the variables can’t be referenced. The lifetime of the variable is the scope in which it’s declared. Scopes can be started at the block level (inside compound statements), in for statements, and in using statements as we will see below. There are several advantages to making scopes small.\n\n-   Readability is enhanced.\n-   You can reduce the risk of reusing a variable inappropriately during long-term maintenance of the code.\n-   Refactoring becomes much easier. You can copy code in without having to worry about variables being reused in contexts they shouldn’t.\n\n### Example\n\nIn this example, we declare the loop counter inside the 'for' statement in which it's used.\n\n      void MyMethod()\n      {\n        for (int i = 0; i < 10; i++)\n        {\n          info(strfmt(\"i is %1\", i));\n        }\n      }\n\nThe scope of the variable is the for statement itself, including the condition expression and the loop update parts. The value can’t be used outside this scope. If you attempt to do that, you will get the following.\n\n      void MyMethod()\n      {\n        for (int i = 0; i < 10; i++)\n        {\n          if (i == 7)\n          {\n            break;\n          }\n        }\n        info(strfmt(\"Found: %1\", i));\n      }\n\nThe compiler will issue an error message in the info call: 'i' is not declared.\n\n### Example\n\nThere's another place where scopes can be established: the using statement, which is another newcomer to the X++ language.\n\n      static void AnotherMethod()\n      {\n        str textFromFile;\n\n        using (System.IO.StreamReader sr = new System.IO.StreamReader(\"c:\\\\test.txt\"))\n        {\n          textFromFile = sr.ReadToEnd();\n        }\n      }\n\nAs a rule, when you use an IDisposable object, you should declare and instantiate it in a using statement. The using statement calls the Dispose method on the object in the correct way, even if an exception occurs while you are calling methods on the object. You can achieve the same result by putting the object inside a try block, and then explicitly calling Dispose in a finally block; in fact, this is how the using statement is translated by the compiler. Declarations can now be provided anywhere statements can be provided-- a declaration is syntactically a statement, a declaration statement. You can, therefore, provide declarations immediately prior to the usage. You don’t have to declare the variables all in one place.\n\n### Example\n\nThe following sample shows some of the features described above.\n\n      // loop variable declared within the loop: It will\n      // not be misused outside the loop\n      for(int i = 1; i < 10; i++)\n      {\n      // Because this value is not used from outside the loop,\n      // its declaration belongs in this smaller scope.\n        str s = int2str(i);\n        info(s);\n      }\n\nTo avoid confusion, the X++ compiler will issue an error if you attempt to introduce a variable that would hide another variable in an enclosing scope or even in the same scope. For instance, the following code will cause the compiler to issue the following diagnostic message: A local variable named 'i' cannot be declared in this scope because it would give a different meaning to 'i', which is already used in a parent or current scope to denote something else.\n\n      {\n        int i;\n        {\n          int i;\n        }\n      }\n\nThis aligns well with the rules that are known from C\\#, but is different from the rule in C++ where shadowing is not diagnosed.\n\n### Exercise\n\nAdapt the code in FMVehicleInventoryServiceClass to use smaller scopes.\n\n## Static constructors and static fields\nStatic constructors and static fields are new features in the X++ language. Static constructors are guaranteed to run before any static or instance calls are made to the class. In C\\#, the concept of static relates to the whole executing application domain. The execution of the static constructor is relative to the user’s session. The static constructor has the following profile.\n\n    static void TypeNew() \n\nYou’ll never call the static constructor explicitly; the compiler will generate code to ensure that the constructor is called exactly once prior to any other method on the class. A static constructor is used to initialize any static data, or to perform a particular action that needs to be performed only once. No parameters can be provided for the static constructor, and it must be marked as static. Static fields are fields that are declared using the static keyword. Conceptually they apply to the class, not instances of the class.\n\n### Example\n\nWe'll show how a singleton, called instance in the example below, can be created by using the static constructor.\n\n    public class Singleton\n    {\n      private static Singleton instance;\n\n      private void new()\n      {\n      }\n\n      static void TypeNew()\n      {\n        instance = new Singleton();\n      }\n\n      public static Singleton Instance()\n      {\n        return Singleton::instance;\n      }\n    }\n\nThe singleton will guarantee that only one instance of the class will ever be called, which is consumed by the following.\n\n    {\n        …\n        Singleton i = Singleton::Instance();\n      }\n\n## Assignment of field members inline\nIt's now possible to assign a value to a field inline, i.e. along with the declaration of the field itself. This applies to both static and instance fields. In the following code, the values of field1 and field2 are defined in this fashion.\n\n    public class MyClass2\n    {\n      int field1 = 1;\n      str field2 = \"Banana\";\n\n      void new()\n      {\n        // …\n      }\n    }\n\nThe code above has the same semantic meaning as: public class MyClass2 { int field1; str field2; void new() { this.field1 = 1; this.field2 = \"Banana\"; // … } } The inline assignments work for both static and instance members.\n\n## Consts/Readonly\nThe concept of macros continues to be fully supported in X++. However, using constants instead of \\#defines has a number of benefits.\n\n-   You can add a documentation comment to the const, not to the value of the macro. Ultimately, the language service will pick this up and provide good information to the user.\n-   The const is known by IntelliSense.\n-   The const is cross referenced, so you can find all references of a particular constant. This is not the case for a macro.\n-   The const is subject to access modifiers, either private, protected, or public. The accessibility of macros is not well understood or even rigorously defined.\n-   Consts have scope, while macros do not.\n-   You can see the value of consts and readonly variables in the debugger.\n\nMacros that are defined in class scopes (in class declarations) are effectively available in all methods of all derived classes. This was originally a bug in the legacy compiler macro implementation, but this loophole is now massively exploited by application programmers. The new X++ compiler still honors this, but no new code that uses this should be written. This particular feature also considerably impacts compiler performance. Constants can be declared at the class level as suggested below.\n\n    private const str MyContant = 'SomeValue';\n\nThe constants can then be referenced by using the double-colon syntax.\n\n      str value = MyClass::MyContant;\n\nIf you're in the scope of the class where the const is defined, you can omit the type name prefix (MyClass in the example above). You can easily implement the concept of a macro library this way. The list of macro symbols becomes a class with public const definitions.\n\n### Exercise\n\nThe fleet application contains the FMDataHelper class that contains the following macro defintions.\n\n    public class FMDataHelper\n    {\n      #define.FMSvcTechUserId('FMSvcTec')\n      #define.FMClerkUserId('FMClerk')\n      #define.FMManagerUserId('FMMgr')\n      #define.FMSvcTechUserGrpId('FMSvcTech')\n      #define.FMClerkUserGrpId('FMClerk')\n      #define.FMManagerUserGrpId('FMManager')\n    …\n    }\n\nChange these to const definitions and update the places where the macros are used accordingly.\n\nYou can also define consts solely as variables. The compiler will maintain the invariant that the value can't be modified.\n\n    {\n      const int Blue = 0x0000FF;\n      const int Green = 0x00FF00;\n      const int Red = 0xFF0000;\n    }\n\nRead-only fields can only be assigned a value once, and that value never changes; the field can be assigned its value either inline, at the place where the field is declared, or in the constructor. Currently, that's the only difference between const and read-only.\n\nVar\n---\n\nYou can now declare a variable without explicitly providing the type of the variable, if the compiler can determine the type from the initialization expression. Note that the variable is still strongly-typed into one, unambiguous type. It's only possible to use var on declarations where an initialization expressions are provided (from which the compiler will infer the type). There are situations where this can make code easier to read, but this feature shouldn't be misused. You should consider the following rules:\n\n-   Use var to declare local variables when the type of the variable is obvious from the right side of the assignment, or when the precise type is not important.\n\n         \n        // When the type of a variable is clear from the context, use var \n        // in the declaration. \n        var var1 = \"This is clearly a string.\";\n        var var2 = 27; // This is an integer (not a real).\n        var i = System.Convert::ToInt32(3.4);\n\n-   Don't use var when the type isn't apparent from the initialization expression.\n\n        // When the type of a variable is not clear from the context, use an \n        // explicit type. \n            int var4 = myObject.ResultSoFar();\n\n-   Use var for the declarations of for loop counters.\n-   Use var for disposable objects inside using statements.\n\n## Private and protected member variables\nPreviously, all member variables defined in a class were invariably protected. It's now possible to make the visibility of member variables explicit by adding the private, protected, and public keywords. The interpretation of these modifiers is obvious and aligns with the semantics for methods:\n\n-   A private member can only be used within the class where it's defined.\n-   a protected member can be used in the class where it's defined, and all subclasses thereof.\n-   A public member can be used anywhere: it's visible outside the confines of the class hierarchy in which it's defined.\n\nThe default for member variables that aren't adorned with an explicit modifier is still protected. You should make it a habit of explicitly specifying the visibility. As described, when a member variable is defined as public, it may be consumed outside of the class in which it's defined. In this case, a qualifier designating the object hosting the variable has to be specified, using the dot notation (as is the case for method calls). Reusing the code from above:\n\n    public class MyClass2\n    {\n      int field1;\n      str field2;\n\n      void new()\n      {\n        this.field1 = 1;   // Explicit object designated\n        field2 = \"Banana\";  // 'this' assumed, as usual\n      }\n    }\n\nIn this case, field1 is accessed using the explicit 'this.' qualifier. **Note**: Making a member variable public may not be a good idea since it exposes the internal workings of the class to its consumers, creating a strong dependency between the class implementation and its consumers. You should always strive to only depend on a contract, not an implementation.\n\n## Finally in try/catch statements\nTry/catch statements can now include an optional finally clause. The semantics are the same as they are in C\\# and other managed languages. The statements in the finally clause are executed when control leaves the try block, either normally or through an exception.\n\n      try\n      {\n        // ...\n      }\n      catch\n      {\n        // Executes when any exception is thrown in the dynamic\n        // scope in the try block.\n      }\n      finally\n      {\n        // Executed irrespective of how the try block exits.\n      }\n\n## Event handlers and Pre/Post methods\nIn legacy X++, it was possible to prescribe in metadata that certain methods were to be executed prior to and after the execution of a method. The information about what subscribes call was recorded on the publisher, which isn't useful in the environment. It's now possible to provide Pre and Post handlers through code, by providing the SubscribesTo attribute on the subscribers.\n\n### Example\n\n    [PreHandlerFor(classStr(MyClass2), methodstr(MyClass2, publisher))]\n      public static void PreHandler(XppPrePostArgs arguments)\n      {\n        int arg = arguments.getArg(\"i\");\n      }\n\n      [PostHandlerFor(classStr(MyClass2), methodstr(MyClass2, publisher))]\n      public static void PostHandler(XppPrePostArgs arguments)\n      {\n        int arg = arguments.getArg(\"i\");\n        int retvalFromMethod = arguments.getReturnValue();\n      }\n\n      public int Publisher(int i)\n      {\n        return 1;\n      }\n\nThis example shows a publishing method called Publisher. Two subscribers are enlisted with the PreHandlerFor and PostHandlerFor. The code shows how to access the variables, and the return values. **Note**: This feature is provided for backward compatibility and, because the application code doesn't have many delegates, to publish important application events. Pre and Post handlers can easily break as the result of added or removed parameters, changed parameter types, or because methods are no longer called, or called under different circumstances. Attributes are also used for binding event handlers to delegates:\n\n      [SubscribesTo(\n        classstr(FMRentalCheckoutProcessor),  \n        delegatestr(FMRentalCheckoutProcessor, RentalTransactionAboutTobeFinalizedEvent))]\n      public static void RentalFinalizedEventHandler(\n        FMRental rentalrecord, Struct rentalConfirmation)\n      {\n      }\n\n      delegate void RentalTransactionAboutTobeFinalizedEvent(\n        FMRental fmrentalrecord, struct RentalConfirmation)\n      {\n      }\n\nIn this case, the SubscribesTo attribute specifies that the method RentalFinalizedEventHandler should be called when the FmRentalCheckoutProcessor.RentalTransactionAboutToBeFinalizedEvent delegate is called. Since the binding between the publisher and subscribers is done through attributes, there's no way of specifying the sequence in which subscribers are called.\n\n## Extension methods\nThe extension method feature lets you add extension methods to a target class by writing the methods in a separate extension class. The following rules apply:\n\n-   The extension class must be static.\n-   The name of the extension class must end with the ten-character suffix \\_Extension. However, there's no restriction on the part of the name that precedes the suffix.\n-   Every extension method in the extension class must be declared as public static.\n-   The first parameter in every extension method is the type that the extension method extends. However, when the extension method is called, the caller must not pass in anything for the first parameter. Instead, the system automatically passes in the required object for the first parameter.\n\nIt's perfectly valid to have private or protected static methods in an extension class. These are typically used for implementation details and are not exposed as extensions. The example below illustrates an extension class holding a few extension methods:\n\n    public static class AtlInventLocation_Extension\n    {\n      public static InventLocation refillEnabled(\n        InventLocation _warehouse, \n        boolean _isRefillEnabled = true)\n      {\n        _warehouse.ReqRefill = _isRefillEnabled;\n        return _warehouse;\n      }\n\n      public static InventLocation save(InventLocation _warehouse)\n      {\n        _warehouse.write();\n        return _warehouse;\n      }\n    }\n\n### Why use extension methods?\n\nThe extension method technique doesn't affect the source code of the class it extends. Therefore, the addition to the class can be done without over-layering. Upgrades to the target class are never affected by any existing extension methods. However, if an upgrade to the target class adds a method that has the same name as your extension method, your extension method becomes unreachable through objects of the target class. Extension methods are easy to use. The extension method technique uses the same dot-delimited syntax that you routinely use the call regular instance methods. Extension methods can access all public artifacts of the target class, but they can't access things that are protected or private. In this way, extension methods can be seen as a kind of syntactic sugar.\n\n### Where can extension methods be applied?\n\nThe target of an extension method must be one of the following application object types:\n\n-   Class\n-   Table\n-   View\n-   Map\n\nRegardless of the target type, an extension *class* is used to add extension methods to the type. For example, an extension table is *not* used to add methods to a table, and there's no such thing as an extension table.\n\n## Using clauses\nPreviously, all references to managed artifacts that weren't authored in X++ was done using fully qualified names, including the namespace for each type. This is still possible, but you can now provide using clauses to make the use of such artifacts less onerous. As opposed to a using statement, each using clause precedes the class in which the clause is applied. It's also possible to provide aliases that introduce a short name for a fully qualified name. Aliases can denote namespaces and classes as shown below.\n\n### Example\n\nConsider the following code:\n\n     using System;\n    using IONS=System.IO; // Namespace alias\n    using Alist=System.Collections.ArrayList; // Class alias\n\n    public class MyClass2\n    {\n      public static void Main(Args a)\n      {\n        Int32 I; // Alternative to System.Int32\n        Alist al; // Using a class alias\n\n        al = new Alist();\n        str s;\n\n        al.Add(1);\n\n        s = IONS.Path::ChangeExtension(@\"c:\\tmp\\test.xml\", \".txt\");\n      }\n    }\n\n## Differences between legacy X++ and new X++\nIn this section, we'll see some of the differences between legacy X++ and the new X++.\n\n### Reals are Decimals\n\nThe type used to represent real values has changed from interpreted X++. This won't require you to rewrite any code, because the new type can express all of the values that the old one could. We provide this material in the interest of full disclosure only. All instances of the real type are now implemented as instances of the .NET decimal type (System.Decimal). Just as the real type in previous versions, the decimal type in a binary coded decimal type that, unlike floating point type, is resilient to rounding errors. The range and resolution of the decimal type are different from the original types. The original X++ real type supported 16 digits and an exponent that defined where the decimal point is placed. The new X++ real type can represent decimal numbers ranging from positive 79,228,162,514,264,337,593,543,950,335 (2⁹⁶-1) to negative 79,228,162,514,264,337,593,543,950,335 (-(2⁹⁶-1)). The new real type doesn't eliminate the need for rounding. For example, the following code produces a result of 0.9999999999999999999999999999 instead of 1. This is readily seen when using the debugger to show the value of the variables below.\n\n    public class MyClass2\n    {\n      public static void Main(Args a)\n      {\n        real dividend = 1.0;\n        real divisor = 3.0;\n        str stringvalue;\n        System.Decimal valueAsDecimal;\n\n        real value = dividend/divisor * divisor;\n\n        valueAsDecimal = value;\n        info(valueAsDecimal.ToString(\"G28\"));\n\n      }\n    }\n\nNo number of decimals will suffice to represent the value of 1/3 accurately. The discrepancy obtained here is due to the fact that only a finite number of decimals are provided. You should use the Round function to round to the number of decimals required.\n\n      value = round(value, 2);\n\n## Internal representation\nA decimal number is a floating-point value that consists of a sign, a numeric value where each digit in the value ranges from 0 to 9, and a scaling factor that indicates the position of a floating decimal point that separates the integral and fractional parts of the numeric value. The binary representation of a real value consists of a 1-bit sign, a 96-bit integer number, and a scaling factor used to divide the 96-bit integer and specify what portion of it is a decimal fraction. The scaling factor is implicitly the number 10, raised to an exponent ranging from 0 to 28. Therefore, the binary representation of a decimal value represents ((-2⁹⁶ to 2⁹⁶)/10(0\\\\ to\\\\ 28)), where -(2⁹⁶-1) is equal to the minimum value and 2⁹⁶-1 is equal to the maximum value that can be expressed.\n\n## String truncation\nString truncation is not a new feature. However, when code is executed in IL in previous versions, the automatic string truncation described here doesn’t take place. String values can be declared in X++ to contain a maximum number of characters. Typically, this is achieved by encoding this information in an extended data type, as shown below: Credit card numbers cannot exceed 20 characters. [![StringTruncationSolutionExplorer\\_DebugFeatures](./media/stringtruncationsolutionexplorer_debugfeatures.png)](./media/stringtruncationsolutionexplorer_debugfeatures.png) It's also possible to specify length constraints directly in the X++ syntax:\n\n    str 20 creditCardNumber;\n\nAll assignments to these values are implicitly truncated to this maximum length.\n\n### Exercise\n\nRun the following code in the debugger by including it in a static main method:\n\n    creditCardNumber = \"12345678901234567890Excess string\";\n\n## Casting\nThe previous version of X++ was very permissive in its treatment of type casting. Both up-casting and down-casting were allowed without intervention from the programmer. Some of the casting permitted in legacy X++ can’t be implemented in the confines of the .NET runtime environment. In object oriented programming languages, including X++, casting refers to assignments between variables whose declared types are both in the same inheritance chain. A cast is either a down-cast or an up-cast. To set the stage for this discussion, we introduce a few self-explanatory class hierarchies: [![Casting\\_DebugFeatures](./media/casting_debugfeatures.png)](./media/casting_debugfeatures.png) As you can see, the MotorVehicle class isn't related to the Animal cast. An **up-cast** happens when assigning an expression of a derived type to a base type:\n\n      Animal a = new Horse();\n\nA **down-cast** happens when assigning an expression of a base type to a derived variable.\n\n    Horse h = new Animal();\n\nBoth up-casts and down-casts are supported in X++. However, down-casts are dangerous and should be avoided whenever possible. The example above will fail with an InvalidCastException at runtime, since the assignment doesn't make sense. X++ supports late binding on a handful of types, like object and formrun. This means that the compiler won't diagnose any errors at compile-time when it sees a method being called on those types, if that method isn't declared explicitly on the type,. It's assumed that the developer knows what they're doing. For instance, the following code may be found in a form.\n\n    Object o = element.args().caller();\n      o.MyMethod(3.14, “Banana”);\n\nThe compiler can't check the parameters, return values, etc. for the MyMethod method, since this method isn't declared on the object class. At runtime, the call will be made using reflection, which is orders of magnitude slower than normal calls. note that calls to methods that are actually defined on the late binding types will be naturally checked. For example, the call to ToString():\n\n    o.ToString(45);\n\nwill cause a compilation error:\n\n    'Object.toString' expects 0 argument(s), but 1 specified.\n\nbecause the ToString method is defined on the object class. There's one difference from the implementation of previous version of X++, related to the fact that methods could be called on unrelated objects, as long as the name of the method was correct, even if the parameter profiles weren't entirely correct. This isn't supported in CIL.\n\n### Example\n\n    public class MyClass2\n    {\n      public static void Main(Args a)\n      {\n        Object obj = new Car();\n        Horse horse = obj; // exception now thrown\n        horse.run();    // Used to call car.run()!\n      }\n    }\n\nYou should use the IS and AS operators liberally in your code. The IS operator can be used if the expression provided is of a particular type (including derived types); the AS operator will perform casting into the given type and return null if a cast isn't possible.\n\n## Compiler diagnoses attempts to store objects in containers\nIn previous incarnations of the X++ compiler, it was possible to store object references into containers, even though this would fail at runtime. This is no longer possible. When the compiler sees an attempt to store an object reference into a container:\n\n    container c = [new Query()];\n\nIt will issue the error message:\n\n    Instances of type 'Query' cannot be added to a container.\n\nIf the type of the element that is added to the container is anytype the compiler can't make the determination of whether or not the value is a reference type. The compiler will allow this under the assumption that the user knows what they're doing. The compiler won't diagnose the following code as erroneous:\n\n    anytype a = new Query();\n            container c = [a];\n\nbut an error will be thrown at runtime.\n\n## Cross company clause can contain arbitrary expressions\nThe crosscompany clause can be used on select statements to indicate the companies that the search statement should take into account. The syntax hasn't been enhanced to allow arbitrary expressions (of type container) instead of a single identifier, which is a variable of type container.\n\n      private void SampleMethod()\n      {\n        MyTable t;\n        container mycompanies = ['dat', 'dmo'];\n        select crosscompany: mycompanies t;\n      }\n\nNow, it's possible to provide the expression without having to use a variable for this purpose.\n\n      private void SampleMethod()\n      {\n        MyTable t;\n        container mycompanies = ['dat', 'dmo'];\n        select crosscompany: (['dat'] + ['dmo']) t;\n      }\n\n## The mkDate predefined function no longer accepts shorthand values\nIn legacy systems, it was possible to use \"shorthand\" values for the year argument of the mkDate function. The effect can be seen in the following code sample.\n\n    static void Job16(Args _args)\n    {\n      int y;\n      date d;\n      \n      for (y = 0; y < 150; y++)\n      {\n        d = mkDate(1,1,y);  \n        info(strFmt(\"%1 - %2\", y, year(d)));\n      }\n    }\n\nRunning this code in the legacy system will produce the following values: 0 – 2000 1 – 2001 2 – 2002 … 27 – 2027 28 – 2028 29 – 2029 **30 – 2030** **31 – 1931** 32 – 1932 33 – 1933 … 97 – 1997 98 – 1998 **99 – 1999** **100 – 1900** We no longer support these values. Attempts to use such values will cause the mkDate function to return the null date (1/1/1900).\n\n## Obsolete statement types\nThe following statements are no longer supported.\n\n### Pause and Window statements\n\nThe X++ pause statement is no longer supported because the pop-up **Print Window** that it affected has been removed. the pause and window statement were mainly used for debugging within the MorphX development environment, which was the same as the execution environment. Since the two are now separated, with Visual Studio taking the place of the MorphX environment, these statements are no longer relevant.\n\n### Print statement\n\nThe X++ print statement is another statement that existed only for debugging purposes. It still exists, and its basic idea is unchanged. But print now outputs through System.Diagnostics.WriteLine. The product configuration determines the detail of the written information is sent. [![DebuggingAdmin\\_DebugFeatures](./media/debuggingadmin_debugfeatures.png)](./media/debuggingadmin_debugfeatures.png) You may find that using the Infolog is more compelling, since its output appears in the debugger and the running form.\n\n## The Ignore list\nSince the legacy environment was all interpreted, it was possible to have some parts not compile, and use the rest. As long as you only called methods that compiled correctly, you were fine; however, you would run into trouble if you tried to call methods that weren't successfully compiled. This way of working doesn't work in CIL. Assemblies are generated from successful compilations and the runtime system can't load incomplete assembles. However, there are legitimate scenarios when porting legacy applications into the new environment where it's beneficial to get things running in a staged fashion and where parts of the application need to be tested before everything is ported. While this is useful for this very limited scenario, it shouldn't be used once the application is ready for production, since you would be hiding problems that will occur at runtime, after the system has been deployed. This is how it currently works: You can specify a method in an XML by selecting, \"Edit Best Practice Suppressions,\" from the context menu on the project. This will open an XML document where the exclusions are maintained.\n\n## New Debugger features\nThis section provides information about the new features that we've added to the debugging experience in Visual Studio.\n\n### Adding ToString methods to your classes\n\nIt's often a benefit to add ToString() methods to your classes. The effort spent doing this comes back many times and it's easy to do. This advice also holds true for legacy X++. **Note**: Since ToString methods can be called at unpredictable times, it isn't a good idea to change the state of the object here.\n\n### Identifying unselected fields\n\nIt's a common source of bugs to use fields from a table when these fields don't appear in the field list in a select statement. Such fields will have a default value according to their type. It's now possible in the debugger to see if a value has been selected or not.\n\n#### Exercise\n\nConsider the following code:\n\n    class MyClass\n    {\n      public static void Main(Args a)\n      {\n        FMRental rental;\n\n        select EndMileage, RentalId from rental;\n\n        rental.Comments = \"Something\";\n      }\n    }\n\nSet a breakpoint on the assignment statement. Make your class the startup object in your project, and start by pressing F5. When the breakpoint is encountered, view the rental variable by expanding it in the locals window. You'll see something similar to the following graphic. [![DebuggingAdmin2\\_DebugFeatures](./media/debuggingadmin2_debugfeatures.png)](./media/debuggingadmin2_debugfeatures.png) You can see that the fields that have been selected (EndMileage and RentalId) appear with their selected values, while the unselected fields appear as null. This signifies their value wasn't fetched from the database. Obviously, this is a debugging artifact. The values of the unselected fields will be the default value for the type of the field. Step over this and notice how the debugger changes the rendering to the actual value. **Note**: If the table is set to Cache, the system will always fetch all fields from the entire table, irrespective of the field list provided in the code.\n\n### The Auto and Infolog Windows\n\nThe debugger will allow you to easily access certain parts of the state of the application easily. This information is available in the autos window, where the current company, the partition, the transaction level, and the current user id are listed. [![Autos\\_DebugFeatures](./media/autos_debugfeatures.png)](./media/autos_debugfeatures.png) There is also a window showing the data that is written to the Infolog. [![Infolog\\_DebugFeatures](./media/infolog_debugfeatures.png)](./media/infolog_debugfeatures.png)\n\n### New breakpoint features\n\nThe Visual Studio debugger supports conditional breakpoints and breakpoints that are triggered by hit count. You can also have the system perform specific actions for you as you hit the breakpoint. None of these features were available in the legacy debugger. These are explained below:\n\n-   Hit count enables you to determine how many times the breakpoint is hit before the debugger breaks execution. By default, the debugger breaks execution every time that the breakpoint is hit. You can set a hit count to tell the debugger to break every 2 times the breakpoint is hit, or every 10 times, or every 512 times, or any other number you choose. Hit counts can be useful because some bugs don't appear the first time your program executes a loop, calls a function, or accesses a variable. Sometimes, the bug might not appear until the 100th or the 1000th iteration. To debug such a problem, you can set a breakpoint with a hit count of 100 or 1000.\n-   Condition is an expression that determines whether the breakpoint is hit or skipped. When the debugger reaches the breakpoint, it'll evaluate the condition. The breakpoint will be hit only if the condition is satisfied. You can use a condition with a location breakpoint to stop at a specified location only when a certain condition is true. For example, suppose you're debugging a banking program where the account balance is never allowed to go below zero. You might set breakpoints at certain locations in the code and attach a condition such as balance &lt; 0 to each one. When you run the program, execution will break at those locations only when the balance is less than zero. You can examine variables and program state at the first breakpoint location, and then continue execution to the second breakpoint location, and so on.\n-   Action specifies something that should occur when the breakpoint is hit. By default, the debugger breaks execution, but you can choose to print a message or run a Visual Studio macro instead. If you decide to print a message instead of breaking, the breakpoint has an effect very similar to a Trace statement. This method of using breakpoints is called tracepoints\n\n#### Exercise\n\nConsider the following code:\n\n    class PVsClass\n    {\n      public static void Main(Args a)\n      {\n        int i;\n        for (i = 0; i < 10; i++)\n        {\n          print i;\n        }\n      }\n    }\n\nPut a breakpoint on the print statements by pressing F9 while that statement is selected. This will create a normal, unconditional breakpoint. Now, use the mouse to open the context menu for the breakpoint and select **Condition**. Put in a condition that indicates that the breakpoint should happen when the value of the 'i' variable exceeds 5. Set the class as a startup project, and the class containing the code as the startup item in the project. Run the code. Feel free to modify the value of 'i' using the debugger. Now, remove this breakpoint, and use the Hit count feature to accomplish the same thing. **Note**: A breakpoint can have several conditions. It's often helpful to hover the cursor over the breakpoint, causing an informative tooltip to appear. Tracepoints are often useful tot race execution. Insert a tracepoint on the line in question and log the value of the variable. The trace output will appear in the output window in the debugger.\n\n### The immediate window\n\nThe immediate window is a useful feature in the VS debugger that allows the user to enter expression and statements to evaluate at any given time. This feature isn't currently implemented in the X++ stack, as is the case for many other languages, notably F\\#. However, that doesn't mean that the savvy user can't benefit from the immediate window. It just means that snippets must be expressed in C\\#, not in X++. There's a separate document that describes the details of how this can be done to great effect.\n\n\n\n","nodes":[{"pos":[4,812],"embed":true,"restype":"x-metadata","content":"# required metadata\n\ntitle: X++ and debugger features\ndescription: This tutorial is for developers to use advanced constructs of the X++ language and take advantage of productive debugger features. This is a walkthrough of the new features with exercises included to practice using these features. \nauthor: pvillads\nmanager: AnnBe\nms.date: 06/20/2017\nms.topic: article\nms.prod: \nms.service: dynamics-ax-platform\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \nms.reviewer: robinr\nms.search.scope: AX 7.0.0, Operations, UnifiedOperations\n# ms.tgt_pltfrm: \nms.custom: 26801\nms.assetid: 27c65e79-df74-4249-b684-97e1d40da753\nms.search.region: Global\n# ms.search.industry: \nms.author: pvillads\nms.search.validFrom: 2016-02-28\nms.dyn365.ops.version: AX 7.0.0\n","nodes":[{"content":"X++ and debugger features","nodes":[{"pos":[0,25],"content":"X++ and debugger features","nodes":[{"content":"X++ and debugger features","pos":[0,25]}]}],"path":["title"],"extradata":"MT"},{"content":"This tutorial is for developers to use advanced constructs of the X++ language and take advantage of productive debugger features. This is a walkthrough of the new features with exercises included to practice using these features.","nodes":[{"pos":[0,230],"content":"This tutorial is for developers to use advanced constructs of the X++ language and take advantage of productive debugger features. This is a walkthrough of the new features with exercises included to practice using these features.","nodes":[{"content":"This tutorial is for developers to use advanced constructs of the X++ language and take advantage of productive debugger features. This is a walkthrough of the new features with exercises included to practice using these features.","pos":[0,230],"nodes":[{"content":"This tutorial is for developers to use advanced constructs of the X++ language and take advantage of productive debugger features.","pos":[0,130]},{"content":"This is a walkthrough of the new features with exercises included to practice using these features.","pos":[131,230]}]}]}],"path":["description"],"extradata":"MT"}],"header":"# required metadata\n","yml":true},{"pos":[820,845],"content":"X++ and debugger features","linkify":"X++ and debugger features","nodes":[{"content":"X++ and debugger features","pos":[0,25]}]},{"content":"This tutorial is for developers to use advanced constructs of the X++ language and take advantage of productive debugger features.","pos":[891,1021]},{"content":"This is a walkthrough of the new features with exercises included to practice using these features.","pos":[1022,1121]},{"content":"In previous versions, the X++ code was compiled into pseudo-code, or p-code, that was interpreted on the server or on the client application.","pos":[1124,1265]},{"content":"This code was then subject to further compilation into CIL.","pos":[1266,1325]},{"content":"Today the story is much simpler--only CIL is supported, and this code is generated from a new compiler.","pos":[1326,1429]},{"content":"In this tutorial, we’ll be discussing some of the new features that have been added to the X++ language.","pos":[1430,1534]},{"content":"As we run through the scenarios, you’ll also see some of the new features in the debugger.","pos":[1535,1625]},{"pos":[1630,1646],"content":"Declare anywhere","linkify":"Declare anywhere","nodes":[{"content":"Declare anywhere","pos":[0,16]}]},{"content":"Previously, all local variables had to be placed at the start of the method in which they’re used.","pos":[1647,1745]},{"content":"Now, you have fine-grained control over the scope of your variables.","pos":[1746,1814]},{"content":"With this new feature, it’s possible to provide smaller scopes for variables, outside of which the variables can’t be referenced.","pos":[1815,1944]},{"content":"The lifetime of the variable is the scope in which it’s declared.","pos":[1945,2010]},{"content":"Scopes can be started at the block level (inside compound statements), in for statements, and in using statements as we will see below.","pos":[2011,2146]},{"content":"There are several advantages to making scopes small.","pos":[2147,2199]},{"content":"Readability is enhanced.","pos":[2205,2229]},{"content":"You can reduce the risk of reusing a variable inappropriately during long-term maintenance of the code.","pos":[2234,2337]},{"content":"Refactoring becomes much easier.","pos":[2342,2374]},{"content":"You can copy code in without having to worry about variables being reused in contexts they shouldn’t.","pos":[2375,2476]},{"pos":[2482,2489],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"In this example, we declare the loop counter inside the 'for' statement in which it's used.","pos":[2491,2582]},{"content":"The scope of the variable is the for statement itself, including the condition expression and the loop update parts.","pos":[2718,2834]},{"content":"The value can’t be used outside this scope.","pos":[2835,2878]},{"content":"If you attempt to do that, you will get the following.","pos":[2879,2933]},{"content":"The compiler will issue an error message in the info call: 'i' is not declared.","pos":[3134,3213]},{"pos":[3219,3226],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"There's another place where scopes can be established: the using statement, which is another newcomer to the X++ language.","pos":[3228,3350]},{"content":"As a rule, when you use an IDisposable object, you should declare and instantiate it in a using statement.","pos":[3578,3684]},{"content":"The using statement calls the Dispose method on the object in the correct way, even if an exception occurs while you are calling methods on the object.","pos":[3685,3836]},{"content":"You can achieve the same result by putting the object inside a try block, and then explicitly calling Dispose in a finally block; in fact, this is how the using statement is translated by the compiler.","pos":[3837,4038]},{"content":"Declarations can now be provided anywhere statements can be provided-- a declaration is syntactically a statement, a declaration statement.","pos":[4039,4178]},{"content":"You can, therefore, provide declarations immediately prior to the usage.","pos":[4179,4251]},{"content":"You don’t have to declare the variables all in one place.","pos":[4252,4309]},{"pos":[4315,4322],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"The following sample shows some of the features described above.","pos":[4324,4388]},{"content":"To avoid confusion, the X++ compiler will issue an error if you attempt to introduce a variable that would hide another variable in an enclosing scope or even in the same scope.","pos":[4703,4880]},{"content":"For instance, the following code will cause the compiler to issue the following diagnostic message: A local variable named 'i' cannot be declared in this scope because it would give a different meaning to 'i', which is already used in a parent or current scope to denote something else.","pos":[4881,5167]},{"content":"This aligns well with the rules that are known from C<ph id=\"ph1\">\\#</ph>, but is different from the rule in C++ where shadowing is not diagnosed.","pos":[5238,5366],"source":"This aligns well with the rules that are known from C\\#, but is different from the rule in C++ where shadowing is not diagnosed."},{"pos":[5372,5380],"content":"Exercise","linkify":"Exercise","nodes":[{"content":"Exercise","pos":[0,8]}]},{"content":"Adapt the code in FMVehicleInventoryServiceClass to use smaller scopes.","pos":[5382,5453]},{"pos":[5458,5495],"content":"Static constructors and static fields","linkify":"Static constructors and static fields","nodes":[{"content":"Static constructors and static fields","pos":[0,37]}]},{"content":"Static constructors and static fields are new features in the X++ language.","pos":[5496,5571]},{"content":"Static constructors are guaranteed to run before any static or instance calls are made to the class.","pos":[5572,5672]},{"content":"In C<ph id=\"ph1\">\\#</ph>, the concept of static relates to the whole executing application domain.","pos":[5673,5753],"source":" In C\\#, the concept of static relates to the whole executing application domain."},{"content":"The execution of the static constructor is relative to the user’s session.","pos":[5754,5828]},{"content":"The static constructor has the following profile.","pos":[5829,5878]},{"content":"You’ll never call the static constructor explicitly; the compiler will generate code to ensure that the constructor is called exactly once prior to any other method on the class.","pos":[5908,6086]},{"content":"A static constructor is used to initialize any static data, or to perform a particular action that needs to be performed only once.","pos":[6087,6218]},{"content":"No parameters can be provided for the static constructor, and it must be marked as static.","pos":[6219,6309]},{"content":"Static fields are fields that are declared using the static keyword.","pos":[6310,6378]},{"content":"Conceptually they apply to the class, not instances of the class.","pos":[6379,6444]},{"pos":[6450,6457],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"We'll show how a singleton, called instance in the example below, can be created by using the static constructor.","pos":[6459,6572]},{"content":"The singleton will guarantee that only one instance of the class will ever be called, which is consumed by the following.","pos":[6872,6993]},{"pos":[7068,7102],"content":"Assignment of field members inline","linkify":"Assignment of field members inline","nodes":[{"content":"Assignment of field members inline","pos":[0,34]}]},{"content":"It's now possible to assign a value to a field inline, i.e. along with the declaration of the field itself.","pos":[7103,7210]},{"content":"This applies to both static and instance fields.","pos":[7211,7259]},{"content":"In the following code, the values of field1 and field2 are defined in this fashion.","pos":[7260,7343]},{"content":"The code above has the same semantic meaning as: public class MyClass2 { int field1; str field2; void new() { this.field1 = 1; this.field2 = \"Banana\"; // …","pos":[7482,7637]},{"content":"} } The inline assignments work for both static and instance members.","pos":[7638,7707]},{"pos":[7712,7727],"content":"Consts/Readonly","linkify":"Consts/Readonly","nodes":[{"content":"Consts/Readonly","pos":[0,15]}]},{"content":"The concept of macros continues to be fully supported in X++.","pos":[7728,7789]},{"content":"However, using constants instead of <ph id=\"ph1\">\\#</ph>defines has a number of benefits.","pos":[7790,7861],"source":" However, using constants instead of \\#defines has a number of benefits."},{"content":"You can add a documentation comment to the const, not to the value of the macro.","pos":[7867,7947]},{"content":"Ultimately, the language service will pick this up and provide good information to the user.","pos":[7948,8040]},{"content":"The const is known by IntelliSense.","pos":[8045,8080]},{"content":"The const is cross referenced, so you can find all references of a particular constant.","pos":[8085,8172]},{"content":"This is not the case for a macro.","pos":[8173,8206]},{"content":"The const is subject to access modifiers, either private, protected, or public.","pos":[8211,8290]},{"content":"The accessibility of macros is not well understood or even rigorously defined.","pos":[8291,8369]},{"content":"Consts have scope, while macros do not.","pos":[8374,8413]},{"content":"You can see the value of consts and readonly variables in the debugger.","pos":[8418,8489]},{"content":"Macros that are defined in class scopes (in class declarations) are effectively available in all methods of all derived classes.","pos":[8491,8619]},{"content":"This was originally a bug in the legacy compiler macro implementation, but this loophole is now massively exploited by application programmers.","pos":[8620,8763]},{"content":"The new X++ compiler still honors this, but no new code that uses this should be written.","pos":[8764,8853]},{"content":"This particular feature also considerably impacts compiler performance.","pos":[8854,8925]},{"content":"Constants can be declared at the class level as suggested below.","pos":[8926,8990]},{"content":"The constants can then be referenced by using the double-colon syntax.","pos":[9040,9110]},{"content":"If you're in the scope of the class where the const is defined, you can omit the type name prefix (MyClass in the example above).","pos":[9151,9280]},{"content":"You can easily implement the concept of a macro library this way.","pos":[9281,9346]},{"content":"The list of macro symbols becomes a class with public const definitions.","pos":[9347,9419]},{"pos":[9425,9433],"content":"Exercise","linkify":"Exercise","nodes":[{"content":"Exercise","pos":[0,8]}]},{"content":"The fleet application contains the FMDataHelper class that contains the following macro defintions.","pos":[9435,9534]},{"content":"Change these to const definitions and update the places where the macros are used accordingly.","pos":[9839,9933]},{"content":"You can also define consts solely as variables.","pos":[9935,9982]},{"content":"The compiler will maintain the invariant that the value can't be modified.","pos":[9983,10057]},{"content":"Read-only fields can only be assigned a value once, and that value never changes; the field can be assigned its value either inline, at the place where the field is declared, or in the constructor.","pos":[10171,10368]},{"content":"Currently, that's the only difference between const and read-only.","pos":[10369,10435]},{"pos":[10437,10440],"content":"Var","linkify":"Var","nodes":[{"content":"Var","pos":[0,3]}]},{"content":"You can now declare a variable without explicitly providing the type of the variable, if the compiler can determine the type from the initialization expression.","pos":[10446,10606]},{"content":"Note that the variable is still strongly-typed into one, unambiguous type.","pos":[10607,10681]},{"content":"It's only possible to use var on declarations where an initialization expressions are provided (from which the compiler will infer the type).","pos":[10682,10823]},{"content":"There are situations where this can make code easier to read, but this feature shouldn't be misused.","pos":[10824,10924]},{"content":"You should consider the following rules:","pos":[10925,10965]},{"content":"Use var to declare local variables when the type of the variable is obvious from the right side of the assignment, or when the precise type is not important.","pos":[10971,11128]},{"content":"Don't use var when the type isn't apparent from the initialization expression.","pos":[11405,11483]},{"content":"Use var for the declarations of for loop counters.","pos":[11642,11692]},{"content":"Use var for disposable objects inside using statements.","pos":[11697,11752]},{"pos":[11757,11795],"content":"Private and protected member variables","linkify":"Private and protected member variables","nodes":[{"content":"Private and protected member variables","pos":[0,38]}]},{"content":"Previously, all member variables defined in a class were invariably protected.","pos":[11796,11874]},{"content":"It's now possible to make the visibility of member variables explicit by adding the private, protected, and public keywords.","pos":[11875,11999]},{"content":"The interpretation of these modifiers is obvious and aligns with the semantics for methods:","pos":[12000,12091]},{"content":"A private member can only be used within the class where it's defined.","pos":[12097,12167]},{"content":"a protected member can be used in the class where it's defined, and all subclasses thereof.","pos":[12172,12263]},{"content":"A public member can be used anywhere: it's visible outside the confines of the class hierarchy in which it's defined.","pos":[12268,12385]},{"content":"The default for member variables that aren't adorned with an explicit modifier is still protected.","pos":[12387,12485]},{"content":"You should make it a habit of explicitly specifying the visibility.","pos":[12486,12553]},{"content":"As described, when a member variable is defined as public, it may be consumed outside of the class in which it's defined.","pos":[12554,12675]},{"content":"In this case, a qualifier designating the object hosting the variable has to be specified, using the dot notation (as is the case for method calls).","pos":[12676,12824]},{"content":"Reusing the code from above:","pos":[12825,12853]},{"content":"In this case, field1 is accessed using the explicit 'this.'","pos":[13077,13136]},{"content":"qualifier.","pos":[13137,13147]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>: Making a member variable public may not be a good idea since it exposes the internal workings of the class to its consumers, creating a strong dependency between the class implementation and its consumers.","pos":[13148,13363],"source":"**Note**: Making a member variable public may not be a good idea since it exposes the internal workings of the class to its consumers, creating a strong dependency between the class implementation and its consumers."},{"content":"You should always strive to only depend on a contract, not an implementation.","pos":[13364,13441]},{"pos":[13446,13477],"content":"Finally in try/catch statements","linkify":"Finally in try/catch statements","nodes":[{"content":"Finally in try/catch statements","pos":[0,31]}]},{"content":"Try/catch statements can now include an optional finally clause.","pos":[13478,13542]},{"content":"The semantics are the same as they are in C<ph id=\"ph1\">\\#</ph> and other managed languages.","pos":[13543,13617],"source":" The semantics are the same as they are in C\\# and other managed languages."},{"content":"The statements in the finally clause are executed when control leaves the try block, either normally or through an exception.","pos":[13618,13743]},{"pos":[14008,14043],"content":"Event handlers and Pre/Post methods","linkify":"Event handlers and Pre/Post methods","nodes":[{"content":"Event handlers and Pre/Post methods","pos":[0,35]}]},{"content":"In legacy X++, it was possible to prescribe in metadata that certain methods were to be executed prior to and after the execution of a method.","pos":[14044,14186]},{"content":"The information about what subscribes call was recorded on the publisher, which isn't useful in the environment.","pos":[14187,14299]},{"content":"It's now possible to provide Pre and Post handlers through code, by providing the SubscribesTo attribute on the subscribers.","pos":[14300,14424]},{"pos":[14430,14437],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"This example shows a publishing method called Publisher.","pos":[14955,15011]},{"content":"Two subscribers are enlisted with the PreHandlerFor and PostHandlerFor.","pos":[15012,15083]},{"content":"The code shows how to access the variables, and the return values.","pos":[15084,15150]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>: This feature is provided for backward compatibility and, because the application code doesn't have many delegates, to publish important application events.","pos":[15151,15316],"source":"**Note**: This feature is provided for backward compatibility and, because the application code doesn't have many delegates, to publish important application events."},{"content":"Pre and Post handlers can easily break as the result of added or removed parameters, changed parameter types, or because methods are no longer called, or called under different circumstances.","pos":[15317,15508]},{"content":"Attributes are also used for binding event handlers to delegates:","pos":[15509,15574]},{"content":"In this case, the SubscribesTo attribute specifies that the method RentalFinalizedEventHandler should be called when the FmRentalCheckoutProcessor.RentalTransactionAboutToBeFinalizedEvent delegate is called.","pos":[16003,16210]},{"content":"Since the binding between the publisher and subscribers is done through attributes, there's no way of specifying the sequence in which subscribers are called.","pos":[16211,16369]},{"pos":[16374,16391],"content":"Extension methods","linkify":"Extension methods","nodes":[{"content":"Extension methods","pos":[0,17]}]},{"content":"The extension method feature lets you add extension methods to a target class by writing the methods in a separate extension class.","pos":[16392,16523]},{"content":"The following rules apply:","pos":[16524,16550]},{"content":"The extension class must be static.","pos":[16556,16591]},{"content":"The name of the extension class must end with the ten-character suffix <ph id=\"ph1\">\\_</ph>Extension.","pos":[16596,16679],"source":"The name of the extension class must end with the ten-character suffix \\_Extension."},{"content":"However, there's no restriction on the part of the name that precedes the suffix.","pos":[16680,16761]},{"content":"Every extension method in the extension class must be declared as public static.","pos":[16766,16846]},{"content":"The first parameter in every extension method is the type that the extension method extends.","pos":[16851,16943]},{"content":"However, when the extension method is called, the caller must not pass in anything for the first parameter.","pos":[16944,17051]},{"content":"Instead, the system automatically passes in the required object for the first parameter.","pos":[17052,17140]},{"content":"It's perfectly valid to have private or protected static methods in an extension class.","pos":[17142,17229]},{"content":"These are typically used for implementation details and are not exposed as extensions.","pos":[17230,17316]},{"content":"The example below illustrates an extension class holding a few extension methods:","pos":[17317,17398]},{"pos":[17827,17853],"content":"Why use extension methods?","linkify":"Why use extension methods?","nodes":[{"content":"Why use extension methods?","pos":[0,26]}]},{"content":"The extension method technique doesn't affect the source code of the class it extends.","pos":[17855,17941]},{"content":"Therefore, the addition to the class can be done without over-layering.","pos":[17942,18013]},{"content":"Upgrades to the target class are never affected by any existing extension methods.","pos":[18014,18096]},{"content":"However, if an upgrade to the target class adds a method that has the same name as your extension method, your extension method becomes unreachable through objects of the target class.","pos":[18097,18281]},{"content":"Extension methods are easy to use.","pos":[18282,18316]},{"content":"The extension method technique uses the same dot-delimited syntax that you routinely use the call regular instance methods.","pos":[18317,18440]},{"content":"Extension methods can access all public artifacts of the target class, but they can't access things that are protected or private.","pos":[18441,18571]},{"content":"In this way, extension methods can be seen as a kind of syntactic sugar.","pos":[18572,18644]},{"pos":[18650,18689],"content":"Where can extension methods be applied?","linkify":"Where can extension methods be applied?","nodes":[{"content":"Where can extension methods be applied?","pos":[0,39]}]},{"content":"The target of an extension method must be one of the following application object types:","pos":[18691,18779]},{"content":"Class","pos":[18785,18790]},{"content":"Table","pos":[18795,18800]},{"content":"View","pos":[18805,18809]},{"content":"Map","pos":[18814,18817]},{"content":"Regardless of the target type, an extension <bpt id=\"p1\">*</bpt>class<ept id=\"p1\">*</ept> is used to add extension methods to the type.","pos":[18819,18916],"source":"Regardless of the target type, an extension *class* is used to add extension methods to the type."},{"content":"For example, an extension table is <bpt id=\"p1\">*</bpt>not<ept id=\"p1\">*</ept> used to add methods to a table, and there's no such thing as an extension table.","pos":[18917,19038],"source":" For example, an extension table is *not* used to add methods to a table, and there's no such thing as an extension table."},{"pos":[19043,19056],"content":"Using clauses","linkify":"Using clauses","nodes":[{"content":"Using clauses","pos":[0,13]}]},{"content":"Previously, all references to managed artifacts that weren't authored in X++ was done using fully qualified names, including the namespace for each type.","pos":[19057,19210]},{"content":"This is still possible, but you can now provide using clauses to make the use of such artifacts less onerous.","pos":[19211,19320]},{"content":"As opposed to a using statement, each using clause precedes the class in which the clause is applied.","pos":[19321,19422]},{"content":"It's also possible to provide aliases that introduce a short name for a fully qualified name.","pos":[19423,19516]},{"content":"Aliases can denote namespaces and classes as shown below.","pos":[19517,19574]},{"pos":[19580,19587],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"Consider the following code:","pos":[19589,19617]},{"pos":[20061,20103],"content":"Differences between legacy X++ and new X++","linkify":"Differences between legacy X++ and new X++","nodes":[{"content":"Differences between legacy X++ and new X++","pos":[0,42]}]},{"content":"In this section, we'll see some of the differences between legacy X++ and the new X++.","pos":[20104,20190]},{"pos":[20196,20214],"content":"Reals are Decimals","linkify":"Reals are Decimals","nodes":[{"content":"Reals are Decimals","pos":[0,18]}]},{"content":"The type used to represent real values has changed from interpreted X++.","pos":[20216,20288]},{"content":"This won't require you to rewrite any code, because the new type can express all of the values that the old one could.","pos":[20289,20407]},{"content":"We provide this material in the interest of full disclosure only.","pos":[20408,20473]},{"content":"All instances of the real type are now implemented as instances of the .NET decimal type (System.Decimal).","pos":[20474,20580]},{"content":"Just as the real type in previous versions, the decimal type in a binary coded decimal type that, unlike floating point type, is resilient to rounding errors.","pos":[20581,20739]},{"content":"The range and resolution of the decimal type are different from the original types.","pos":[20740,20823]},{"content":"The original X++ real type supported 16 digits and an exponent that defined where the decimal point is placed.","pos":[20824,20934]},{"content":"The new X++ real type can represent decimal numbers ranging from positive 79,228,162,514,264,337,593,543,950,335 (2⁹⁶-1) to negative 79,228,162,514,264,337,593,543,950,335 (-(2⁹⁶-1)).","pos":[20935,21118]},{"content":"The new real type doesn't eliminate the need for rounding.","pos":[21119,21177]},{"content":"For example, the following code produces a result of 0.9999999999999999999999999999 instead of 1.","pos":[21178,21275]},{"content":"This is readily seen when using the debugger to show the value of the variables below.","pos":[21276,21362]},{"content":"No number of decimals will suffice to represent the value of 1/3 accurately.","pos":[21708,21784]},{"content":"The discrepancy obtained here is due to the fact that only a finite number of decimals are provided.","pos":[21785,21885]},{"content":"You should use the Round function to round to the number of decimals required.","pos":[21886,21964]},{"pos":[22001,22024],"content":"Internal representation","linkify":"Internal representation","nodes":[{"content":"Internal representation","pos":[0,23]}]},{"content":"A decimal number is a floating-point value that consists of a sign, a numeric value where each digit in the value ranges from 0 to 9, and a scaling factor that indicates the position of a floating decimal point that separates the integral and fractional parts of the numeric value.","pos":[22025,22306]},{"content":"The binary representation of a real value consists of a 1-bit sign, a 96-bit integer number, and a scaling factor used to divide the 96-bit integer and specify what portion of it is a decimal fraction.","pos":[22307,22508]},{"content":"The scaling factor is implicitly the number 10, raised to an exponent ranging from 0 to 28.","pos":[22509,22600]},{"content":"Therefore, the binary representation of a decimal value represents ((-2⁹⁶ to 2⁹⁶)/10(0<ph id=\"ph1\">\\\\</ph> to<ph id=\"ph2\">\\\\</ph> 28)), where -(2⁹⁶-1) is equal to the minimum value and 2⁹⁶-1 is equal to the maximum value that can be expressed.","pos":[22601,22808],"source":" Therefore, the binary representation of a decimal value represents ((-2⁹⁶ to 2⁹⁶)/10(0\\\\ to\\\\ 28)), where -(2⁹⁶-1) is equal to the minimum value and 2⁹⁶-1 is equal to the maximum value that can be expressed."},{"pos":[22813,22830],"content":"String truncation","linkify":"String truncation","nodes":[{"content":"String truncation","pos":[0,17]}]},{"content":"String truncation is not a new feature.","pos":[22831,22870]},{"content":"However, when code is executed in IL in previous versions, the automatic string truncation described here doesn’t take place.","pos":[22871,22996]},{"content":"String values can be declared in X++ to contain a maximum number of characters.","pos":[22997,23076]},{"content":"Typically, this is achieved by encoding this information in an extended data type, as shown below: Credit card numbers cannot exceed 20 characters.","pos":[23077,23224]},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">![</ph>StringTruncationSolutionExplorer<ph id=\"ph2\">\\_</ph>DebugFeatures<ept id=\"p1\">](./media/stringtruncationsolutionexplorer_debugfeatures.png)](./media/stringtruncationsolutionexplorer_debugfeatures.png)</ept> It's also possible to specify length constraints directly in the X++ syntax:","pos":[23225,23474],"source":"[![StringTruncationSolutionExplorer\\_DebugFeatures](./media/stringtruncationsolutionexplorer_debugfeatures.png)](./media/stringtruncationsolutionexplorer_debugfeatures.png) It's also possible to specify length constraints directly in the X++ syntax:"},{"content":"All assignments to these values are implicitly truncated to this maximum length.","pos":[23506,23586]},{"pos":[23592,23600],"content":"Exercise","linkify":"Exercise","nodes":[{"content":"Exercise","pos":[0,8]}]},{"content":"Run the following code in the debugger by including it in a static main method:","pos":[23602,23681]},{"pos":[23747,23754],"content":"Casting","linkify":"Casting","nodes":[{"content":"Casting","pos":[0,7]}]},{"content":"The previous version of X++ was very permissive in its treatment of type casting.","pos":[23755,23836]},{"content":"Both up-casting and down-casting were allowed without intervention from the programmer.","pos":[23837,23924]},{"content":"Some of the casting permitted in legacy X++ can’t be implemented in the confines of the .NET runtime environment.","pos":[23925,24038]},{"content":"In object oriented programming languages, including X++, casting refers to assignments between variables whose declared types are both in the same inheritance chain.","pos":[24039,24204]},{"content":"A cast is either a down-cast or an up-cast.","pos":[24205,24248]},{"content":"To set the stage for this discussion, we introduce a few self-explanatory class hierarchies: <bpt id=\"p1\">[</bpt><ph id=\"ph1\">![</ph>Casting<ph id=\"ph2\">\\_</ph>DebugFeatures<ept id=\"p1\">](./media/casting_debugfeatures.png)](./media/casting_debugfeatures.png)</ept> As you can see, the MotorVehicle class isn't related to the Animal cast.","pos":[24249,24512],"source":" To set the stage for this discussion, we introduce a few self-explanatory class hierarchies: [![Casting\\_DebugFeatures](./media/casting_debugfeatures.png)](./media/casting_debugfeatures.png) As you can see, the MotorVehicle class isn't related to the Animal cast."},{"content":"An <bpt id=\"p1\">**</bpt>up-cast<ept id=\"p1\">**</ept> happens when assigning an expression of a derived type to a base type:","pos":[24513,24598],"source":" An **up-cast** happens when assigning an expression of a derived type to a base type:"},{"pos":[24631,24721],"content":"A <bpt id=\"p1\">**</bpt>down-cast<ept id=\"p1\">**</ept> happens when assigning an expression of a base type to a derived variable.","source":"A **down-cast** happens when assigning an expression of a base type to a derived variable."},{"content":"Both up-casts and down-casts are supported in X++.","pos":[24752,24802]},{"content":"However, down-casts are dangerous and should be avoided whenever possible.","pos":[24803,24877]},{"content":"The example above will fail with an InvalidCastException at runtime, since the assignment doesn't make sense.","pos":[24878,24987]},{"content":"X++ supports late binding on a handful of types, like object and formrun.","pos":[24988,25061]},{"content":"This means that the compiler won't diagnose any errors at compile-time when it sees a method being called on those types, if that method isn't declared explicitly on the type,.","pos":[25062,25238]},{"content":"It's assumed that the developer knows what they're doing.","pos":[25239,25296]},{"content":"For instance, the following code may be found in a form.","pos":[25297,25353]},{"content":"The compiler can't check the parameters, return values, etc. for the MyMethod method, since this method isn't declared on the object class.","pos":[25430,25569]},{"content":"At runtime, the call will be made using reflection, which is orders of magnitude slower than normal calls.","pos":[25570,25676]},{"content":"note that calls to methods that are actually defined on the late binding types will be naturally checked.","pos":[25677,25782]},{"content":"For example, the call to ToString():","pos":[25783,25819]},{"content":"will cause a compilation error:","pos":[25842,25873]},{"content":"because the ToString method is defined on the object class.","pos":[25938,25997]},{"content":"There's one difference from the implementation of previous version of X++, related to the fact that methods could be called on unrelated objects, as long as the name of the method was correct, even if the parameter profiles weren't entirely correct.","pos":[25998,26247]},{"content":"This isn't supported in CIL.","pos":[26248,26276]},{"pos":[26282,26289],"content":"Example","linkify":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"content":"You should use the IS and AS operators liberally in your code.","pos":[26518,26580]},{"content":"The IS operator can be used if the expression provided is of a particular type (including derived types); the AS operator will perform casting into the given type and return null if a cast isn't possible.","pos":[26581,26785]},{"pos":[26790,26848],"content":"Compiler diagnoses attempts to store objects in containers","linkify":"Compiler diagnoses attempts to store objects in containers","nodes":[{"content":"Compiler diagnoses attempts to store objects in containers","pos":[0,58]}]},{"content":"In previous incarnations of the X++ compiler, it was possible to store object references into containers, even though this would fail at runtime.","pos":[26849,26994]},{"content":"This is no longer possible.","pos":[26995,27022]},{"content":"When the compiler sees an attempt to store an object reference into a container:","pos":[27023,27103]},{"content":"It will issue the error message:","pos":[27139,27171]},{"content":"If the type of the element that is added to the container is anytype the compiler can't make the determination of whether or not the value is a reference type.","pos":[27236,27395]},{"content":"The compiler will allow this under the assumption that the user knows what they're doing.","pos":[27396,27485]},{"content":"The compiler won't diagnose the following code as erroneous:","pos":[27486,27546]},{"content":"but an error will be thrown at runtime.","pos":[27609,27648]},{"pos":[27653,27707],"content":"Cross company clause can contain arbitrary expressions","linkify":"Cross company clause can contain arbitrary expressions","nodes":[{"content":"Cross company clause can contain arbitrary expressions","pos":[0,54]}]},{"content":"The crosscompany clause can be used on select statements to indicate the companies that the search statement should take into account.","pos":[27708,27842]},{"content":"The syntax hasn't been enhanced to allow arbitrary expressions (of type container) instead of a single identifier, which is a variable of type container.","pos":[27843,27996]},{"content":"Now, it's possible to provide the expression without having to use a variable for this purpose.","pos":[28160,28255]},{"pos":[28430,28495],"content":"The mkDate predefined function no longer accepts shorthand values","linkify":"The mkDate predefined function no longer accepts shorthand values","nodes":[{"content":"The mkDate predefined function no longer accepts shorthand values","pos":[0,65]}]},{"content":"In legacy systems, it was possible to use \"shorthand\" values for the year argument of the mkDate function.","pos":[28496,28602]},{"content":"The effect can be seen in the following code sample.","pos":[28603,28655]},{"content":"Running this code in the legacy system will produce the following values: 0 – 2000 1 – 2001 2 – 2002 …","pos":[28860,28962]},{"content":"27 – 2027 28 – 2028 29 – 2029 <bpt id=\"p1\">**</bpt>30 – 2030<ept id=\"p1\">**</ept> <bpt id=\"p2\">**</bpt>31 – 1931<ept id=\"p2\">**</ept> 32 – 1932 33 – 1933 …","pos":[28963,29042],"source":" 27 – 2027 28 – 2028 29 – 2029 **30 – 2030** **31 – 1931** 32 – 1932 33 – 1933 …"},{"content":"97 – 1997 98 – 1998 <bpt id=\"p1\">**</bpt>99 – 1999<ept id=\"p1\">**</ept> <bpt id=\"p2\">**</bpt>100 – 1900<ept id=\"p2\">**</ept> We no longer support these values.","pos":[29043,29126],"source":" 97 – 1997 98 – 1998 **99 – 1999** **100 – 1900** We no longer support these values."},{"content":"Attempts to use such values will cause the mkDate function to return the null date (1/1/1900).","pos":[29127,29221]},{"pos":[29226,29250],"content":"Obsolete statement types","linkify":"Obsolete statement types","nodes":[{"content":"Obsolete statement types","pos":[0,24]}]},{"content":"The following statements are no longer supported.","pos":[29251,29300]},{"pos":[29306,29333],"content":"Pause and Window statements","linkify":"Pause and Window statements","nodes":[{"content":"Pause and Window statements","pos":[0,27]}]},{"content":"The X++ pause statement is no longer supported because the pop-up <bpt id=\"p1\">**</bpt>Print Window<ept id=\"p1\">**</ept> that it affected has been removed.","pos":[29335,29452],"source":"The X++ pause statement is no longer supported because the pop-up **Print Window** that it affected has been removed."},{"content":"the pause and window statement were mainly used for debugging within the MorphX development environment, which was the same as the execution environment.","pos":[29453,29606]},{"content":"Since the two are now separated, with Visual Studio taking the place of the MorphX environment, these statements are no longer relevant.","pos":[29607,29743]},{"pos":[29749,29764],"content":"Print statement","linkify":"Print statement","nodes":[{"content":"Print statement","pos":[0,15]}]},{"content":"The X++ print statement is another statement that existed only for debugging purposes.","pos":[29766,29852]},{"content":"It still exists, and its basic idea is unchanged.","pos":[29853,29902]},{"content":"But print now outputs through System.Diagnostics.WriteLine.","pos":[29903,29962]},{"content":"The product configuration determines the detail of the written information is sent.","pos":[29963,30046]},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">![</ph>DebuggingAdmin<ph id=\"ph2\">\\_</ph>DebugFeatures<ept id=\"p1\">](./media/debuggingadmin_debugfeatures.png)](./media/debuggingadmin_debugfeatures.png)</ept> You may find that using the Infolog is more compelling, since its output appears in the debugger and the running form.","pos":[30047,30284],"source":"[![DebuggingAdmin\\_DebugFeatures](./media/debuggingadmin_debugfeatures.png)](./media/debuggingadmin_debugfeatures.png) You may find that using the Infolog is more compelling, since its output appears in the debugger and the running form."},{"pos":[30289,30304],"content":"The Ignore list","linkify":"The Ignore list","nodes":[{"content":"The Ignore list","pos":[0,15]}]},{"content":"Since the legacy environment was all interpreted, it was possible to have some parts not compile, and use the rest.","pos":[30305,30420]},{"content":"As long as you only called methods that compiled correctly, you were fine; however, you would run into trouble if you tried to call methods that weren't successfully compiled.","pos":[30421,30596]},{"content":"This way of working doesn't work in CIL.","pos":[30597,30637]},{"content":"Assemblies are generated from successful compilations and the runtime system can't load incomplete assembles.","pos":[30638,30747]},{"content":"However, there are legitimate scenarios when porting legacy applications into the new environment where it's beneficial to get things running in a staged fashion and where parts of the application need to be tested before everything is ported.","pos":[30748,30991]},{"content":"While this is useful for this very limited scenario, it shouldn't be used once the application is ready for production, since you would be hiding problems that will occur at runtime, after the system has been deployed.","pos":[30992,31210]},{"content":"This is how it currently works: You can specify a method in an XML by selecting, \"Edit Best Practice Suppressions,\" from the context menu on the project.","pos":[31211,31364]},{"content":"This will open an XML document where the exclusions are maintained.","pos":[31365,31432]},{"pos":[31437,31458],"content":"New Debugger features","linkify":"New Debugger features","nodes":[{"content":"New Debugger features","pos":[0,21]}]},{"content":"This section provides information about the new features that we've added to the debugging experience in Visual Studio.","pos":[31459,31578]},{"pos":[31584,31623],"content":"Adding ToString methods to your classes","linkify":"Adding ToString methods to your classes","nodes":[{"content":"Adding ToString methods to your classes","pos":[0,39]}]},{"content":"It's often a benefit to add ToString() methods to your classes.","pos":[31625,31688]},{"content":"The effort spent doing this comes back many times and it's easy to do.","pos":[31689,31759]},{"content":"This advice also holds true for legacy X++.","pos":[31760,31803]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>: Since ToString methods can be called at unpredictable times, it isn't a good idea to change the state of the object here.","pos":[31804,31935],"source":"**Note**: Since ToString methods can be called at unpredictable times, it isn't a good idea to change the state of the object here."},{"pos":[31941,31970],"content":"Identifying unselected fields","linkify":"Identifying unselected fields","nodes":[{"content":"Identifying unselected fields","pos":[0,29]}]},{"content":"It's a common source of bugs to use fields from a table when these fields don't appear in the field list in a select statement.","pos":[31972,32099]},{"content":"Such fields will have a default value according to their type.","pos":[32100,32162]},{"content":"It's now possible in the debugger to see if a value has been selected or not.","pos":[32163,32240]},{"pos":[32247,32255],"content":"Exercise","linkify":"Exercise","nodes":[{"content":"Exercise","pos":[0,8]}]},{"content":"Consider the following code:","pos":[32257,32285]},{"content":"Set a breakpoint on the assignment statement.","pos":[32487,32532]},{"content":"Make your class the startup object in your project, and start by pressing F5.","pos":[32533,32610]},{"content":"When the breakpoint is encountered, view the rental variable by expanding it in the locals window.","pos":[32611,32709]},{"content":"You'll see something similar to the following graphic.","pos":[32710,32764]},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">![</ph>DebuggingAdmin2<ph id=\"ph2\">\\_</ph>DebugFeatures<ept id=\"p1\">](./media/debuggingadmin2_debugfeatures.png)](./media/debuggingadmin2_debugfeatures.png)</ept> You can see that the fields that have been selected (EndMileage and RentalId) appear with their selected values, while the unselected fields appear as null.","pos":[32765,33043],"source":"[![DebuggingAdmin2\\_DebugFeatures](./media/debuggingadmin2_debugfeatures.png)](./media/debuggingadmin2_debugfeatures.png) You can see that the fields that have been selected (EndMileage and RentalId) appear with their selected values, while the unselected fields appear as null."},{"content":"This signifies their value wasn't fetched from the database.","pos":[33044,33104]},{"content":"Obviously, this is a debugging artifact.","pos":[33105,33145]},{"content":"The values of the unselected fields will be the default value for the type of the field.","pos":[33146,33234]},{"content":"Step over this and notice how the debugger changes the rendering to the actual value.","pos":[33235,33320]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>: If the table is set to Cache, the system will always fetch all fields from the entire table, irrespective of the field list provided in the code.","pos":[33321,33476],"source":"**Note**: If the table is set to Cache, the system will always fetch all fields from the entire table, irrespective of the field list provided in the code."},{"pos":[33482,33510],"content":"The Auto and Infolog Windows","linkify":"The Auto and Infolog Windows","nodes":[{"content":"The Auto and Infolog Windows","pos":[0,28]}]},{"content":"The debugger will allow you to easily access certain parts of the state of the application easily.","pos":[33512,33610]},{"content":"This information is available in the autos window, where the current company, the partition, the transaction level, and the current user id are listed.","pos":[33611,33762]},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">![</ph>Autos<ph id=\"ph2\">\\_</ph>DebugFeatures<ept id=\"p1\">](./media/autos_debugfeatures.png)](./media/autos_debugfeatures.png)</ept> There is also a window showing the data that is written to the Infolog.","pos":[33763,33926],"source":"[![Autos\\_DebugFeatures](./media/autos_debugfeatures.png)](./media/autos_debugfeatures.png) There is also a window showing the data that is written to the Infolog."},{"content":"<bpt id=\"p1\">[</bpt><ph id=\"ph1\">![</ph>Infolog<ph id=\"ph2\">\\_</ph>DebugFeatures<ept id=\"p1\">](./media/infolog_debugfeatures.png)](./media/infolog_debugfeatures.png)</ept>","pos":[33927,34024],"source":"[![Infolog\\_DebugFeatures](./media/infolog_debugfeatures.png)](./media/infolog_debugfeatures.png)"},{"pos":[34030,34053],"content":"New breakpoint features","linkify":"New breakpoint features","nodes":[{"content":"New breakpoint features","pos":[0,23]}]},{"content":"The Visual Studio debugger supports conditional breakpoints and breakpoints that are triggered by hit count.","pos":[34055,34163]},{"content":"You can also have the system perform specific actions for you as you hit the breakpoint.","pos":[34164,34252]},{"content":"None of these features were available in the legacy debugger.","pos":[34253,34314]},{"content":"These are explained below:","pos":[34315,34341]},{"content":"Hit count enables you to determine how many times the breakpoint is hit before the debugger breaks execution.","pos":[34347,34456]},{"content":"By default, the debugger breaks execution every time that the breakpoint is hit.","pos":[34457,34537]},{"content":"You can set a hit count to tell the debugger to break every 2 times the breakpoint is hit, or every 10 times, or every 512 times, or any other number you choose.","pos":[34538,34699]},{"content":"Hit counts can be useful because some bugs don't appear the first time your program executes a loop, calls a function, or accesses a variable.","pos":[34700,34842]},{"content":"Sometimes, the bug might not appear until the 100th or the 1000th iteration.","pos":[34843,34919]},{"content":"To debug such a problem, you can set a breakpoint with a hit count of 100 or 1000.","pos":[34920,35002]},{"content":"Condition is an expression that determines whether the breakpoint is hit or skipped.","pos":[35007,35091]},{"content":"When the debugger reaches the breakpoint, it'll evaluate the condition.","pos":[35092,35163]},{"content":"The breakpoint will be hit only if the condition is satisfied.","pos":[35164,35226]},{"content":"You can use a condition with a location breakpoint to stop at a specified location only when a certain condition is true.","pos":[35227,35348]},{"content":"For example, suppose you're debugging a banking program where the account balance is never allowed to go below zero.","pos":[35349,35465]},{"content":"You might set breakpoints at certain locations in the code and attach a condition such as balance <ph id=\"ph1\">&amp;lt;</ph> 0 to each one.","pos":[35466,35583],"source":" You might set breakpoints at certain locations in the code and attach a condition such as balance &lt; 0 to each one."},{"content":"When you run the program, execution will break at those locations only when the balance is less than zero.","pos":[35584,35690]},{"content":"You can examine variables and program state at the first breakpoint location, and then continue execution to the second breakpoint location, and so on.","pos":[35691,35842]},{"content":"Action specifies something that should occur when the breakpoint is hit.","pos":[35847,35919]},{"content":"By default, the debugger breaks execution, but you can choose to print a message or run a Visual Studio macro instead.","pos":[35920,36038]},{"content":"If you decide to print a message instead of breaking, the breakpoint has an effect very similar to a Trace statement.","pos":[36039,36156]},{"content":"This method of using breakpoints is called tracepoints","pos":[36157,36211]},{"pos":[36218,36226],"content":"Exercise","linkify":"Exercise","nodes":[{"content":"Exercise","pos":[0,8]}]},{"content":"Consider the following code:","pos":[36228,36256]},{"content":"Put a breakpoint on the print statements by pressing F9 while that statement is selected.","pos":[36431,36520]},{"content":"This will create a normal, unconditional breakpoint.","pos":[36521,36573]},{"content":"Now, use the mouse to open the context menu for the breakpoint and select <bpt id=\"p1\">**</bpt>Condition<ept id=\"p1\">**</ept>.","pos":[36574,36662],"source":" Now, use the mouse to open the context menu for the breakpoint and select **Condition**."},{"content":"Put in a condition that indicates that the breakpoint should happen when the value of the 'i' variable exceeds 5.","pos":[36663,36776]},{"content":"Set the class as a startup project, and the class containing the code as the startup item in the project.","pos":[36777,36882]},{"content":"Run the code.","pos":[36883,36896]},{"content":"Feel free to modify the value of 'i' using the debugger.","pos":[36897,36953]},{"content":"Now, remove this breakpoint, and use the Hit count feature to accomplish the same thing.","pos":[36954,37042]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>: A breakpoint can have several conditions.","pos":[37043,37094],"source":"**Note**: A breakpoint can have several conditions."},{"content":"It's often helpful to hover the cursor over the breakpoint, causing an informative tooltip to appear.","pos":[37095,37196]},{"content":"Tracepoints are often useful tot race execution.","pos":[37197,37245]},{"content":"Insert a tracepoint on the line in question and log the value of the variable.","pos":[37246,37324]},{"content":"The trace output will appear in the output window in the debugger.","pos":[37325,37391]},{"pos":[37397,37417],"content":"The immediate window","linkify":"The immediate window","nodes":[{"content":"The immediate window","pos":[0,20]}]},{"content":"The immediate window is a useful feature in the VS debugger that allows the user to enter expression and statements to evaluate at any given time.","pos":[37419,37565]},{"content":"This feature isn't currently implemented in the X++ stack, as is the case for many other languages, notably F<ph id=\"ph1\">\\#</ph>.","pos":[37566,37678],"source":" This feature isn't currently implemented in the X++ stack, as is the case for many other languages, notably F\\#."},{"content":"However, that doesn't mean that the savvy user can't benefit from the immediate window.","pos":[37679,37766]},{"content":"It just means that snippets must be expressed in C<ph id=\"ph1\">\\#</ph>, not in X++.","pos":[37767,37832],"source":" It just means that snippets must be expressed in C\\#, not in X++."},{"content":"There's a separate document that describes the details of how this can be done to great effect.","pos":[37833,37928]}]}