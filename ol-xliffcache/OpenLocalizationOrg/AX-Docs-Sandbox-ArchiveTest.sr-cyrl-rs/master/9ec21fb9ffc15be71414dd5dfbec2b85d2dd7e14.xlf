<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="sr-cyrl-rs">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-5a646d1" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9ec21fb9ffc15be71414dd5dfbec2b85d2dd7e14</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">dev-itpro\dev-ref\xpp-cs-comparison.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">developer-content</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">HT</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e10c0e9e2de1ec78b115a473803a7dac0c3823c9</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7696cc58257c4d7e4eb88b613a79a4237ee6983e</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" extradata="MT" restype="x-metadata">
          <source>X++ and C# comparison</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" restype="x-metadata">
          <source>This topic compares X++ and C# syntax and programming.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>X++ and C# comparison</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>This topic compares X++ and C# syntax and programming.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>X++, C# Comparison: Hello World</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This section compares the simplest X++ program to its counterpart in C#.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>X++ to C# Comparisons</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The following sections describe some basic similarities and differences between X++ and C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Similarities</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The following X++ features are the same for C#:</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Single line (<ph id="ph1">`//`</ph>) and multi-line (/<ph id="ph2">\*</ph> <ph id="ph3">\*</ph>/) comments.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`==`</ph> (equal) operator for determining whether two values are equal.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>!= (not equal to) operator for determining whether two values are not equivalent.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>(plus sign) operator for string concatenation.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Differences</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The following table lists X++ features that are different in C#.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Feature</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>X++</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Declarations</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>All declarations must be at the start of the method, before any X++ statements.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Declarations can occur anywhere in the method.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Both languages permit multiple variables of the same type to be listed together in one declaration.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Both languages allow you to assign an initial value in the declaration statement.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`if`</ph> and <ph id="ph2">`else`</ph> conditional statements</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`if`</ph> statement accepts any type of expression that it can automatically convert to a Boolean.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Common examples include an <ph id="ph1">`int`</ph> for which 0 means false, or an object for which null means false.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`if`</ph> statement requires a Boolean expression.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The syntax structure regarding curly braces and parentheses is exactly the same between X++ and C#.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Literal string</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>A literal string can be delimited by either of the following:</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>A pair of double quotation mark (") characters.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>A pair of single quotation mark (') characters.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>A literal string must be delimited by a pair of double quotation mark (") characters.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>For X++, the double quotation mark characters are usually used to delimit strings.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>However, it is convenient delimit a string with single quotation mark characters when your string must contain a double quotation mark character.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>char <ph id="ph1">`type`</ph></source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>There is no <ph id="ph1">`char`</ph> or character type in X++.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>You can declare a <ph id="ph1">`str`</ph> of length one, but it is still a string:</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>There is a <ph id="ph1">`char`</ph> in C#.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>You cannot pass a <ph id="ph1">`char`</ph> as the parameter to a method that inputs a <ph id="ph2">`string`</ph> parameter, although you can first explicitly convert the <ph id="ph3">`char`</ph> to a <ph id="ph4">`string`</ph>.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>For more information about X++ data types, see Primitive Data Types.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Output of messages</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>X++ delivers messages to the user in the Infolog window.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Common methods include the following:</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>print<ept id="p1">&lt;/strong&gt;</ept> statement:</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>static methods on the <ph id="ph1">`Global`</ph> class:</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Global::info</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Global::warning</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Global::error</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>For a command line C# program, messages can be delivered to the console.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Common methods include the following:</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>print<ept id="p1">&lt;/strong&gt;</ept> statement is not a function nor a method.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Recommended use would be <ph id="ph1">`print mystring;`</ph> rather than <ph id="ph2">`print(mystring);`</ph>.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`pause;`</ph> statement is always useful shortly after a <bpt id="p1">&lt;strong&gt;</bpt>print<ept id="p1">&lt;/strong&gt;</ept> statement.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The print statement is convenient for testing because it automatically converts <bpt id="p1">&lt;strong&gt;</bpt>int<ept id="p1">&lt;/strong&gt;</ept> and other primitive values to strings for display.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>For more information, see Print Statements.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Global`</ph> class has special recognition in the X++ compiler.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`info`</ph> method can be called without including the Global:: prefix.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>X++ and C++ Samples</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>This section contains two simple code samples.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>One sample is written in X++, and the other is in C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Both samples achieve the same result.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The following X++ features are demonstrated:</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`//`</ph> single line comment</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><ph id="ph1">/</ph><ph id="ph2">\*</ph> <ph id="ph3">\*</ph>/ multi-line comment</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`if`</ph> statement</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`==`</ph> operator</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>!= operator</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>operator to concatenate strings</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Global::info for message output, with and without the Global:: prefix</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Global::error for message output</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The use of single and double quotation characters (' and ") as string delimiters.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>: The best practice is to use double quotation marks for any string that might be displayed to the user.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>X++ Sample</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>This X++ code sample is in the form of a job.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>There is a node titled Jobs in the Application Object Tree (AOT).</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This sample can be added under the Jobs node, and then the job can be run.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Here is the output from the Infolog window: Message (09:49:48) Hello World, 1.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Hello World, 2.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>This is like info, but is for warnings, 3.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>This is like info, but is for errors, 4.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>C# Sample</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The following C# program is a rewrite of the previous X++ program.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The differences between X++ and C# are highlighted by commenting out the X++ lines, and replacing them with the C# syntax.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Here is the actual output to the C# console:</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>X++, C# Comparison: Loops</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>This section compares the loop features between X++ and C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Similarities</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The following features are the same in X++ and C<ph id="ph1">\#</ph>:</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Declarations for variables of the int primitive data type.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>Declarations for other primitive types are almost the same, but the types might have different names.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>while statement for loops.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>break statement to exit a loop.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>continue statement to jump up to the top of a loop.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>&lt;= (less than or equal) comparison operator.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Differences</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>The following table lists X++ features that are different in C#.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Features</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>X++</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`for`</ph> statement.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The for statement is available for loops.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The C# <ph id="ph1">`for`</ph> statement is slightly different from <ph id="ph2">`for`</ph> in X++.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>In C# you can declare the counter integer in the <ph id="ph1">`for`</ph> statement.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>But in X++ the counter must declared outside the <ph id="ph1">`for`</ph> statement.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>++ increment operator.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>An ++ increment operator is available in X++.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>But an <bpt id="p1">&lt;strong&gt;</bpt>int<ept id="p1">&lt;/strong&gt;</ept> variable that is decorated with ++ can only be used as a statement, not as an expression.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>For example, the following lines of X++ code would not compile:</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>However, the following lines of X++ code would compile:</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The C# ++ operator is more flexible than in X++.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The following lines of code are the same in both languages:</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>++ myInteger;</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>myInteger++;</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>But the following lines of code have a different effect from each other, and are valid only in C#:</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>yourInt = ++myInt;</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>yourInt = myInt++;</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>modulo operator.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>In X++ the modulo operator is mod.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>In C# the modulo operator is %.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>The symbols for the modulo operator are different, but their behavior is the same in both languages.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Temporarily suspend a console program that has already begun.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`pause`</ph> statement.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>In C#, a command line program can be paused by the following line of code:</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>In X++ you continue by clicking an OK button on a modal dialog box.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>In C# you continue by pressing any keyboard on the keyboard.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Display a message.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>In X++, the <ph id="ph1">`print`</ph> statement displays a message in the Print window.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>In C# a message can be displayed on the console by the following line of code:</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The X++ <ph id="ph1">`print`</ph> function is used only when you test.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>An X++ program that uses <ph id="ph1">`print`</ph> almost always uses the <ph id="ph2">`pause`</ph> statement somewhere later in the code.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>For production X++ code, use the Global::info Method instead of <ph id="ph1">`print`</ph>.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`strfmt`</ph> function is often used together with <ph id="ph2">`info`</ph>.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>There is no reason to use <ph id="ph1">`pause`</ph> after <ph id="ph2">`info`</ph>.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>Make a sound.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The beep function makes a sound that you can hear.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>In C# a sound that you can hear is issued by the following line of code:</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>The statements each produce a short tone.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Print and Global::info</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The X++ code samples for loops use the <ph id="ph1">`print`</ph> function to display results.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>In X++ you can use the <ph id="ph1">`print`</ph> statement can display any primitive data type without having to call functions that convert it to a string first.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>This makes <ph id="ph1">`print`</ph> useful in quick test situations.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Generally the Global::info method is used more often than <ph id="ph1">`print`</ph>.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`info`</ph> method can only display strings.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Therefore the strfmt function is often used together with <ph id="ph1">`info`</ph>.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>A limitation of <ph id="ph1">`print`</ph> is that you cannot copy the contents of the Print window to the clipboard (such as with Ctrl+C).</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Global::info writes to the Infolog window which does support copy to the clipboard.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Example 1: The while Loop</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>while<ept id="p1">**</ept> keyword supports looping in both X++ and C#.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>X++ Sample of while</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>}</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>The output in the X++ Print window is as follows:</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>C# Sample of while</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>The console output from the C# program is as follows:</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Example 2: The for Loop</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>for<ept id="p1">**</ept> keyword supports looping in both X++ and C#.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>X++ Sample of for</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>In X++ the counter variable cannot be declared as part of the <bpt id="p1">**</bpt>for<ept id="p1">**</ept> statement.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>}</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The output in the X++ Print window is as follows:</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>C# Sample of for</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The console output from the C# program is as follows: 1 (Press any key to resume.) 2 (Press any key to resume.) 3 (Press any key to resume.) 4 (Press any key to resume.) (Press any key to resume.)</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>X++, C# Comparison: Switch</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>In both X++ and C#, the <bpt id="p1">**</bpt>switch<ept id="p1">**</ept> statement involves the keywords <bpt id="p2">**</bpt>case<ept id="p2">**</ept>, <bpt id="p3">**</bpt>break<ept id="p3">**</ept>, and <bpt id="p4">**</bpt>default<ept id="p4">**</ept>.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>The following table lists the differences in the <bpt id="p1">**</bpt>switch<ept id="p1">**</ept> statement between X++ and C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>Feature</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>X++</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`break;`</ph> at the end of each case block</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>In X++, when any <bpt id="p1">**</bpt>case<ept id="p1">**</ept> block matches the expression value on the <bpt id="p2">**</bpt>switch<ept id="p2">**</ept> clause, all other <bpt id="p3">**</bpt>case<ept id="p3">**</ept> and <bpt id="p4">**</bpt>default<ept id="p4">**</ept> blocks are executed until a <ph id="ph1">`break;`</ph> statement is reached.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>No <ph id="ph1">`break;`</ph> statement is ever required in an X++ <bpt id="p1">**</bpt>switch<ept id="p1">**</ept> statement, but <ph id="ph2">`break;`</ph> statements are important in almost all practical situations.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>In C<ph id="ph1">\#</ph>, a <ph id="ph2">`break;`</ph> statement is always needed after the statements in a <bpt id="p1">**</bpt>case<ept id="p1">**</ept> or <bpt id="p2">**</bpt>default<ept id="p2">**</ept> block.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>If a <bpt id="p1">**</bpt>case<ept id="p1">**</ept> clause has no statements between itself and the next <bpt id="p2">**</bpt>case<ept id="p2">**</ept> clause, a <ph id="ph1">`break;`</ph> statement is not required between the two <bpt id="p3">**</bpt>case<ept id="p3">**</ept> clauses.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>We recommend against omitting the <ph id="ph1">`break;`</ph> statement after any case <bpt id="p1">**</bpt>block<ept id="p1">**</ept>, because it can confuse the next programmer who edits the code.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`break;`</ph> at the end of the <bpt id="p1">**</bpt>default<ept id="p1">**</ept> block</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>In X++ there is no effect of adding a <ph id="ph1">`break;`</ph> statement at the end of the <bpt id="p1">**</bpt>default<ept id="p1">**</ept> block.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>In C<ph id="ph1">\#</ph> the compiler requires a <ph id="ph2">`break;`</ph> statement at the end of the <bpt id="p1">**</bpt>default<ept id="p1">**</ept> block.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>For more information, see Switch Statements.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Only constant values on a <bpt id="p1">**</bpt>case<ept id="p1">**</ept> block</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>In X++ you can specify either a literal value or a variable on a case block.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>For example, you can write case myInteger:.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>In C<ph id="ph1">\#</ph> you must specify exactly one literal value on each <bpt id="p1">**</bpt>case<ept id="p1">**</ept> block, and no variables are allowed.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>No comments.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Multiple values on one <bpt id="p1">**</bpt>case<ept id="p1">**</ept> block</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>In X++ you can specify multiple values on each case block.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>The values must be separated by a comma.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>For example, you can write <ph id="ph1">`case 4,5,myInteger:`</ph>.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>In C<ph id="ph1">\#</ph> you must specify exactly one value on each <bpt id="p1">**</bpt>case<ept id="p1">**</ept> block.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>In X++ it is better to write multiple values on one <bpt id="p1">**</bpt>case<ept id="p1">**</ept> block than to omit the <ph id="ph1">`break;`</ph> statement at the end of one or more case blocks.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Code Examples for switch</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>The following sections show comparable switch statements in X++ and C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>X++ switch Example</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>The X++ switch example shows the following:</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>case iTemp: and case (93-90): to show that <bpt id="p1">**</bpt>case<ept id="p1">**</ept> expressions are not limited to constants, as they are in C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`//break;`</ph> to show that <ph id="ph2">`break;`</ph> statements are not required in X++, although they are almost always desirable.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>case 2, (93-90), 5: to show that multiple expressions can be listed on on <bpt id="p1">**</bpt>case<ept id="p1">**</ept> clause in X++.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>X++</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>C# switch Example</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>The C<ph id="ph1">\#</ph> switch example shows the following:</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>case 1: has a comment explaining that only constant expressions can be given on a <bpt id="p1">**</bpt>case<ept id="p1">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`break;`</ph> statements occur after the last statement in each <bpt id="p1">**</bpt>case<ept id="p1">**</ept> block that has statements, as is required by C<ph id="ph2">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>X++, C# Comparison: String Case and Delimiters</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>This section compares the treatment of strings with mixed casing in X++ and C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>It also explains the string delimiters that are available in X++.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Similarities</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>The following X++ features are the same as in C<ph id="ph1">\#</ph>:</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>The backslash (<ph id="ph1">\\</ph>) is the escape operator for string delimiters.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>The at sign (@) nullifies the escape effect of the backslash when the at sign is written immediately before the open quotation mark of a string.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>The plus sign (+) is the string concatenation operator.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Differences</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>X++ features that are different in C<ph id="ph1">\#</ph> are listed in the following table.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Feature</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>X++</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`== `</ph>comparison operator</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>Insensitive: the <ph id="ph1">`==`</ph> operator is insensitive to differences in string casing.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>In C#, the <ph id="ph1">`==`</ph> operator is sensitive to differences in string casing.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>In X++ you can use the strCmp Function for case sensitive comparisons between strings.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>String delimiters</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>In X++ you can use either the single (') or double (<ph id="ph1">`"`</ph>) quotation mark as the string delimiter.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>: Usually the best practice is to use double quotation marks for strings that might be displayed to the user.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>However, it is convenient to delimit a string with single quotation marks when a double quotation mark is one of the characters in the string.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>In C# you must use the double quotation mark as the string delimiter.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>This refers to the type <ph id="ph1">`System.String`</ph>.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>In X++ and C# you have the option of embedding a delimiter in a literal string and escaping it with \.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>In X++ you also have the alternative of embedding single quotation marks in a string that is delimited by double quotation marks (or the reverse), without having to use the escape.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>Character delimiters</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>X++ has a string data type (<ph id="ph1">`str`</ph>), but no character type.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>In C# you must use the single quotation mark as the character delimiter.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>This refers to the type <ph id="ph1">`System.Char`</ph>.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>In the .NET Framework, a <ph id="ph1">`System.String`</ph> of length one is a different data type than a <ph id="ph2">`System.Char`</ph> character.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Example 1: Case Sensitivity of the == Operator</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`==`</ph> and != operators are case insensitive in X++, but are case sensitive in C<ph id="ph2">\#</ph>, as is illustrated by the following example.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>X++</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>True in X++.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>False in C#.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Different case comparisons between X++ and C#.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>Example 2: The + String Concatenation Operator</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>The + and += operators are used to concatenate strings in both X++ and C<ph id="ph1">\#</ph>, as is shown by the examples in the following table.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>X++</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Result is equality:</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>(Same as for X++.)</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>In both X++ and C#, the behavior of the + operator depends on the data type of its operands.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>The operator concatenates strings, or adds numbers.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Result is equality: <ph id="ph1">`myString2 == "Hello world"`</ph></source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>(Same as for X++.)</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>In both X++ and C#, the following statements are equivalent:</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Example 3: Embedding and Escaping String Delimiters</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>Either single or double quotation marks can be used to delimit strings in X++.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>The escape character (<ph id="ph1">\\</ph>) can be used to embed delimiters in a string.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>These are illustrated in the following table.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>X++</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>Result:</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>(Same as for X++.)</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>The escape character enables you to embed string delimiters inside strings.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>Result:</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>C# syntax does not allow for single quotation marks to delimit strings.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>For strings that may be seen by the user, it is considered a best practice to use the escape character instead of the single quotation marks as shown in the example.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>Result:</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>(Same as for X++.)</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>In X++, the single quotation marks are not treated as delimiters unless the string starts with a single quotation mark delimiter.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>In C# the single quotation mark has no special meaning for strings, and it cannot be used to delimit strings.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>In C# the single quotation mark is the required delimiter for literals of type <ph id="ph1">`System.Char`</ph>.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>X++ has no character data type.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>Here the single quotation is a string delimiter.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Here the single quotation mark is a <ph id="ph1">`System.Char`</ph> delimiter, not a <ph id="ph2">`System.String`</ph> delimiter.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>X++ has no data type that corresponds to <ph id="ph1">`System.Char`</ph> in the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>An X++ string that is limited to a length of one is still a string, not a character data type.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>Example 4: Single Escape Character</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>Examples that illustrate the single escape character in either the input or the output are shown in the following table.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>X++</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Result:</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>A literal string in C# cannot contain the two character sequence of escape followed by a space, such as "\ ".</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>A compiler error occurs.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>When the X++ compiler encounters the two character sequence of "\ ", it discards the single escape character.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>Result:</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>(Same as for X++.)</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>In a pair of escape characters, the first negates the special meaning of the second.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source>Comparison: Array Syntax</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>There are similarities and differences in the features and syntax for arrays in X++ versus C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve">
          <source>Similarities</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>Overall there is much similarity in the syntax and treatment of arrays in X++ and C#.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>However there are many differences.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source>Differences</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>The following table lists areas in the [] syntax for arrays that are different for X++ and C#.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>Category</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>X++</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>Declaration</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve">
          <source>An array is declared with square brackets appended to the variable name.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source>An array is declared with square brackets appended to the data type.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>: An X++ array cannot be a parameter in a method.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve">
          <source>Declaration</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>The array syntax supports only primitive data types, such as <ph id="ph1">`int`</ph> and <ph id="ph2">`str`</ph>.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>The syntax does not support classes or tables.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>The array syntax supports primitive data types and classes.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>In X++ you can use the <ph id="ph1">`Array`</ph> Array for an array of objects.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source>Declaration</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source>X++ is limited to single dimension arrays (myStrings[8]).</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>C# adds support for multi-dimensional arrays (myStrings[8,3]) and for jagged arrays (myStrings[8][3]).</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source>In X++ you cannot have an array of arrays.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>However, there is advanced syntax for limiting the amount of active memory that a large array can consume, which looks like the multi-dimensional syntax in C#: int intArray[1024,16];.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source>For more information, see Best Practice Performance Optimizations: Swapping Arrays to Disk.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>Declaration</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>In X++ an array is a special construct but it is not an object.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve">
          <source>In C# all arrays are objects regardless of syntax variations.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>X++ does have an Array class, but its underlying mechanism differs from arrays created by using the [] syntax.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>In C# all arrays use the same underlying mechanism, regardless of whether [] syntax of the <ph id="ph1">`System.Array`</ph> class is used in your code.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>Length</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>In X++ the length of a static sized array is determined in the declaration syntax.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>In C# the size of an array is determined when the array object is constructed.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>When you use the [] declaration syntax in X++, no more preparation is needed before you assign values to the array.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>In C# you must declare and then construct the array before assigning to it.</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source>Length</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>An X++ array can have a dynamic length that can be increased even after population has begun.</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>This applies only when the array is declared without a number inside the [].</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>Performance might be slowed if the length of the dynamic array is increased many times.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source>In C# the length of an array cannot be changed after the length is set.</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>In the following fragment of X++ code, only the <ph id="ph1">`myInts`</ph> array is dynamic and can increase in size.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve">
          <source>Length</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve">
          <source>You can get the length of some arrays by using the <ph id="ph1">`dimOf`</ph> function.</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>C# arrays are objects that have a <ph id="ph1">`Length`</ph> property.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>No comments.</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>Indexing</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>Array indexing is 1 based.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>Array indexing is 0 based.</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>mtIntArray[0] would cause an error in X++.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>Constant</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>In X++ a constant value is best achieved by using the <bpt id="p1">&lt;strong&gt;</bpt>#define<ept id="p1">&lt;/strong&gt;</ept> precompiler directive.</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve">
          <source>In C# you can decorate your variable declaration with the keyword <bpt id="p1">&lt;strong&gt;</bpt>const<ept id="p1">&lt;/strong&gt;</ept>, to achieve a constant value.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve">
          <source>X++ has no <bpt id="p1">&lt;strong&gt;</bpt>const<ept id="p1">&lt;/strong&gt;</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>C# cannot assign values to variables that are created by its #define precompiler directive.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>X++ and C<ph id="ph1">\#</ph> Samples</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve">
          <source>The following code samples show how arrays of primitive data types are handled.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve">
          <source>The first sample is in X++, and the second sample is in C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>Both samples achieve the same results.</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>X++ Sample</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>The output to the Infolog is as follows:</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>C<ph id="ph1">\#</ph> Sample</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>The output from the C# program to the command line console is as follows:</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>Additional array-like X++ features</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>container<ept id="p1">**</ept> is a special data type that is available in X++.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>It can be considered as similar to an array, or similar to a <ph id="ph1">`List`</ph> collection.</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source>Comparison: Collections</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>Finance and Operations provides the X++ <ph id="ph1">`List`</ph> collection class.</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>The .NET Framework that is used in C# has a similar class named <ph id="ph1">`System.Collections.Generic.List`</ph>.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>Comparing the Use of the List Classes</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>The following table compares methods on the X++ <ph id="ph1">`List`</ph> class to the methods on <ph id="ph2">`System.Collections.Generic.List`</ph> from the .NET Framework and C<ph id="ph3">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>Feature</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>X++</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>Declaration of collection</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>The X++ declaration does not include the type of elements to be stored.</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>Declaration of iterator</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>IEnumerator<ph id="ph1">&amp;lt;</ph>string<ph id="ph2">&amp;gt;</ph> iter;</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve">
          <source>In X++ the <ph id="ph1">`ListIterator`</ph> object has methods that can <ph id="ph2">`insert`</ph> and <ph id="ph3">`delete`</ph> items from the <ph id="ph4">`List`</ph>.</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>The X++ <ph id="ph1">`ListEnumerator`</ph> cannot modify the contents of the <ph id="ph2">`List`</ph>.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>In X++ the <ph id="ph1">`ListEnumerator`</ph> object is always created on the same tier as the <ph id="ph2">`List`</ph>.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>This is not always true for <ph id="ph1">`ListIterator`</ph>.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>Obtaining an iterator</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>In both X++ and C#, the List object has a getter method for an associated enumerator.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>Constructor</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>Information about the type of objects to be stored inside the <ph id="ph1">`List`</ph> classes is given to the constructor in both X++ and C#.</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>Updating data</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>Enumerator  the enumerator becomes invalid if any items in the <ph id="ph1">`List`</ph> are added or removed.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>Iterator  the iterator has methods that insert and delete items from the <ph id="ph1">`List`</ph>.</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source>The iterator remains valid.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>Enumerator  the enumerator becomes invalid if any items in the <ph id="ph1">`List`</ph> are added or removed.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>Enumerators become invalid after items are added or deleted from the <ph id="ph1">`List`</ph>, in both X++ and C#.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>Updating data</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve">
          <source>In X++ the <ph id="ph1">`List`</ph> class has methods for adding items at the start or end of the list.</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve">
          <source>In C# the <ph id="ph1">`List`</ph> class has methods for adding members at any position in the list.</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>It also has methods for removing items from any position.</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>In X++ items can be removed from the <ph id="ph1">`List`</ph> only by an iterator.</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>Example 1: Declaration of a List</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>The following table displays code examples in X++ and C# that declare <ph id="ph1">`List`</ph> collections.</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>Example 2: Construction of a List</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>In both languages, the type of items that the collection stores must be specified at the time of construction.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve">
          <source>For class types, X++ can get no more specific than whether the type is a class (Types::Class).</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve">
          <source>Code examples are in the following table.</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>Example 3: Add Items to a List</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>In both X++ and C#, the collection provides a method for appending an item to the end of the collection, and for inserting an item the start.</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>In C# the collection provides a method for inserting at any point in the collection based on an index value.</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>In X++ a collection iterator can insert an item at its current position.</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>Code examples are in the following table.</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>Example 4: Iterate Through a List</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source>Both X++ and C<ph id="ph1">\#</ph> have iterator classes that you can use to step through the items in a collection.</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>Code examples are in the following table.</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>Example 4b: foreach in C<ph id="ph1">\#</ph></source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>In C<ph id="ph1">\#</ph> the <bpt id="p1">**</bpt>foreach<ept id="p1">**</ept> keyword is often used to simplify the task of iterating through a list.</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve">
          <source>The following code example behaves the same as the previous C<ph id="ph1">\#</ph> example.</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve">
          <source>Example 5: Delete the Second Item</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>The following table contains code examples that delete the second item from the collection.</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>In X++ this requires an iterator.</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>In C<ph id="ph1">\#</ph> the collection itself provides the method for removing an item.</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>Example 6: Combine Two Collections</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>The following table contains code examples that combine the contents of two collections into one.</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>Comparison: Collections of keys with values</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>Finance and Operations provides the <ph id="ph1">`Map`</ph> collection class.</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Map`</ph> collection holds pairs of values, the key value plus a data value.</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>This resembles the .NET Framework class named <ph id="ph1">`System.Collections.Generic.Dictionary`</ph>.</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>Similarities</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve">
          <source>The following list describes similarities between X++ and C<ph id="ph1">\#</ph> regarding their collections that store key-value pairs:</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve">
          <source>Both prevent duplicate keys.</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>Both use an enumerator (or iterator) to loop through the items.</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>Both key-value collection objects are constructed with designations of the types that are stored as key and value.</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source>Both can store class objects, and are not limited to storing primitives like <bpt id="p1">**</bpt>int<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>Differences</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source>The following table describes differences between X++ and C<ph id="ph1">\#</ph> regarding their collections classes that store key-value pairs:</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>Feature</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve">
          <source>X++</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>Duplicate keys</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>In X++ the <ph id="ph1">`Map`</ph> class prevents duplicate keys by implicitly treating your call to its <ph id="ph2">`insert`</ph> method as an operation to update only the value associated with the key.</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>In C<ph id="ph1">\#</ph> the <ph id="ph2">`Dictionary`</ph> class throws an exception when you try to add a duplicate key.</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>Duplicate keys are prevented in both languages, although by different techniques.</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve">
          <source>Delete items</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve">
          <source>In X++ the <ph id="ph1">`delete`</ph> method on an iterator object is used to remove an unwanted key-value pair from a <ph id="ph2">`Map`</ph>.</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve">
          <source>In C<ph id="ph1">\#</ph> the <ph id="ph2">`Dictionary`</ph> class has a <ph id="ph3">`remove`</ph> method.</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>In both languages, an enumerator is made invalid if the collection item count is modified during the life of the enumerator.</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>Example 1: Declaration of a Key-Value Collection</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>In both languages, the type of items that the key-value collection stores must be specified.</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>In X++ the type is specified at time of construction.</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source>In C<ph id="ph1">\#</ph> the type is specified at both the time of declaration and the time of construction.</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>Code examples are in the following table.</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve">
          <source>Example 2: Construction of the Collection</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve">
          <source>In both languages, the type of items that the key-value collection stores specified during construction.</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve">
          <source>For class types, X++ can get no more specific than whether the type is a class (Types::Class).</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>Code examples are in the following table.</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>Example 3: Add an Item to the Collection</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>There is almost no difference in how an item is added to a key-value collection, in X++ and C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>Code examples are in the following table.</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>Example 4: Iterate Through a Key-Value Collection</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source>Enumerators are used to loop through the key-value collections in both X++ and C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>Code examples are in the following table.</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source>Example 5: Update the Value Associated with a Key</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>The syntax is very different between the two languages for an update of the value associated to a given key.</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source>Code examples for the key 102 are in the following table.</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>Example 6: Delete One Item</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve">
          <source>The syntax is very different between the two languages to delete one key-value pair from a collection, while iterating through the collection members.</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve">
          <source>Code examples for the key 102 are shown below.</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>Comparison: Exceptions</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>There are some similarities but many differences when we compare exception related behavior between X++ and C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>try<ept id="p1">**</ept>, <bpt id="p2">**</bpt>catch<ept id="p2">**</ept>, and <bpt id="p3">**</bpt>throw<ept id="p3">**</ept> keywords behave the same in X++ and C#.</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>But the types of exceptions thrown and caught are different for the two languages.</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>Similarities</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve">
          <source>Similarities between X++ and C<ph id="ph1">\#</ph> regarding their exception features include the following:</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve">
          <source>Both languages have the same <bpt id="p1">**</bpt>try<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve">
          <source>Both have the same <bpt id="p1">**</bpt>catch<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>Both enable for a <bpt id="p1">**</bpt>catch<ept id="p1">**</ept> statement that does not specify any particular exception.</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>Such a <bpt id="p1">**</bpt>catch<ept id="p1">**</ept> statement catches all exceptions that reach it.</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source>Both have the same <bpt id="p1">**</bpt>throw<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>Differences</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve">
          <source>Exception-related differences between X++ and C<ph id="ph1">\#</ph> are described in the following table.</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve">
          <source>Feature</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve">
          <source>X++</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;strong&gt;</bpt>retry<ept id="p1">&lt;/strong&gt;</ept></source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>Jumps to the first instruction in the associated <bpt id="p1">&lt;strong&gt;</bpt>try<ept id="p1">&lt;/strong&gt;</ept> block.</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source>For more information, see Exception Handling with try and catch Keywords.</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>The functionality of the <bpt id="p1">&lt;strong&gt;</bpt>retry<ept id="p1">&lt;/strong&gt;</ept> keyword can be mimicked in C# code, but there is no corresponding keyword.</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve">
          <source>Only X++ has a <bpt id="p1">&lt;strong&gt;</bpt>retry<ept id="p1">&lt;/strong&gt;</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve">
          <source>C# has no counterpart.</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>For more information, see X++, C# Comparison: Automated Retry After an Exception.</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;strong&gt;</bpt>finally<ept id="p1">&lt;/strong&gt;</ept></source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`finally`</ph> keyword is supported to follow the <ph id="ph2">`try`</ph> and <ph id="ph3">`catch`</ph> keywords.</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>finally<ept id="p1">&lt;/strong&gt;</ept> keyword marks a block of code that follows the <bpt id="p2">&lt;strong&gt;</bpt>try<ept id="p2">&lt;/strong&gt;</ept> and <bpt id="p3">&lt;strong&gt;</bpt>catch<ept id="p3">&lt;/strong&gt;</ept> blocks.</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source>The finally will be executed regardless of whether any exception is thrown or caught.</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source>The semantics are identical to the semantics in C#.</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>Specific exceptions</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve">
          <source>In X++ an exception is an element of the <ph id="ph1">`Exception`</ph> enum, such as <bpt id="p1">**</bpt>Error<ept id="p1">**</ept>, <bpt id="p2">**</bpt>Deadlock<ept id="p2">**</ept>, or <bpt id="p3">**</bpt>CodeAccessSecurity<ept id="p3">**</ept>.No exception can contain another.</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve">
          <source>In C# an exception is an instance of the <ph id="ph1">`System.Exception`</ph> base class, or any class that inherits from it.</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>An exception can be contained in the <ph id="ph1">`InnerException`</ph> property of the thrown exception.</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve">
          <source>In X++ each thrown exception is a value of the Exception enum.</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve">
          <source>For more information, see Exception Enumeration.</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>Exception message</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>In X++ the message that is created when an exception is raised is available only in the Infolog, and the message is not directly tied to the exception.</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source>In C# the message is the <ph id="ph1">`Message`</ph> member of the <ph id="ph2">`System.Exception`</ph> object.</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>In X++ the Global::error method is the mechanism that display exception messages in the Infolog.</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source>For more information, see Exception Handling with try and catch Keywords.</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source>Exception conditions</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>In X++ an error occurs when you call an instance method on an object variable that has not yet had anything assigned to it.</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve">
          <source>However, no exception is raised along with this error.</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve">
          <source>Therefore no <ph id="ph1">`catch`</ph> block can gain control even if the unassigned variable is misused in a <ph id="ph2">`try`</ph> block.</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve">
          <source>In the following code example, the error caused by the code <ph id="ph1">`box4.toString();`</ph> does not cause control to transfer to any <ph id="ph2">`catch`</ph> block: <ph id="ph3">`DialogBox box4;`</ph> <ph id="ph4">`try`</ph> { <ph id="ph5">` box4.toString();`</ph> <ph id="ph6">` info("toString did not error, but expected an error.");`</ph> } catch (Exception::Error) // No Exception value catches this.</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve">
          <source>{ <ph id="ph1">` info("Invalid use of box4 gave control to catch, unexpected.");`</ph> }</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve">
          <source>In C# a <ph id="ph1">`System.NullReferenceException`</ph> is raised when an uninitialized variable is treated as an object reference.</source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve">
          <source>There might be several other differences in the conditions that raise exceptions.</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve">
          <source>SQL transactions</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve">
          <source>In X++ when an SQL exception occurs in a <bpt id="p1">&lt;strong&gt;</bpt>ttsBegin<ept id="p1">&lt;/strong&gt;</ept><ph id="ph1"> - </ph><bpt id="p2">&lt;strong&gt;</bpt>ttsCommit<ept id="p2">&lt;/strong&gt;</ept> transaction, no <bpt id="p3">&lt;strong&gt;</bpt>catch<ept id="p3">&lt;/strong&gt;</ept> statement inside the transaction block can process the exception.</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve">
          <source>In C# a catch block inside an SQL transaction can catch the exception.</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>Examples</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source>The following X++ features are demonstrated:</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>try<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>catch<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>The behavior after an Exception::Error exception occurs.</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve">
          <source>X++ Example</source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve">
          <source>Here is the output from the Infolog window:</source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve">
          <source>C# Sample</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve">
          <source>The following C<ph id="ph1">\#</ph> program is a rewrite of the previous X++ program.</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve">
          <source>Here is the actual output to the C<ph id="ph1">\#</ph> console:</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve">
          <source>Comparison: Automated Retry After an Exception</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve">
          <source>Sometimes you can write code in a catch block that fixes the cause of an exception that occurs during run time.</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve">
          <source>X++ provides a <bpt id="p1">**</bpt>retry<ept id="p1">**</ept> keyword that can be used only inside a <bpt id="p2">**</bpt>catch<ept id="p2">**</ept> block.</source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>retry<ept id="p1">**</ept> keyword enables a program to jump back to the start of the <bpt id="p2">**</bpt>try<ept id="p2">**</ept> block after the problem has been corrected by code in the <bpt id="p3">**</bpt>catch<ept id="p3">**</ept> block.</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>C# does not have a <bpt id="p1">**</bpt>retry<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source>However, C# code can be written to provide equivalent behavior.</source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source>Code Samples for Retry</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source>The following X++ sample program causes an Exception::Error to be raised.</source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>This occurs when it first tries to read an element from the <ph id="ph1">`sStrings`</ph> array by using an invalid index value.</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source>When the exception is caught, corrective action is taken during run time inside the <bpt id="p1">**</bpt>catch<ept id="p1">**</ept> block.</source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source>The retry statement then jumps back to the first statement in the <bpt id="p1">**</bpt>try<ept id="p1">**</ept> block.</source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>This second iteration works without encountering any exception.</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>Here is the output to the Print window:</source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source>C# Sample</source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>The following C<ph id="ph1">\#</ph> sample is not a line-by-line translation from the previous X++ sample.</source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve">
          <source>Instead the C<ph id="ph1">\#</ph> program has a different structure so that it mimics the behavior of the <bpt id="p1">**</bpt>retry<ept id="p1">**</ept> keyword that the X++ program relies on.</source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>try<ept id="p1">**</ept> and <bpt id="p2">**</bpt>catch<ept id="p2">**</ept> blocks are in a called method.</source>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve">
          <source>The variables that are used in the <bpt id="p1">**</bpt>try<ept id="p1">**</ept> block are stored in the caller method.</source>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve">
          <source>The caller method passes the variables as parameters that are decorated with the <bpt id="p1">**</bpt>ref<ept id="p1">**</ept> keyword, so that their values can be corrected inside the <bpt id="p2">**</bpt>catch<ept id="p2">**</ept> block of the called method.</source>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve">
          <source>The called method captures all exceptions, and returns a <bpt id="p1">**</bpt>boolean<ept id="p1">**</ept> to communicate back to the caller whether a second call is required.</source>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve">
          <source>.Rs008b_CSharp_ExceptionsAndRetry_Callee (ref iIndex); } else { break; } } Console.WriteLine("End of C# caller method."); } private bool Rs008b_CSharp_ExceptionsAndRetry_Callee (ref int iIndex) { bool bReturnCode = true; // Means call this method again.</source>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve">
          <source>string[] sStrings = new string[4]; string sTemp; sStrings[0] = "First array element."; try { Console.WriteLine("At top of try block: " + iIndex.ToString()); sTemp = sStrings[iIndex]; Console.WriteLine( "The array element is: " + sTemp ); bReturnCode = false; // Means do not call this method again.</source>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve">
          <source>} catch (Exception) { Console.WriteLine ("In catch of -- Exception.</source>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve">
          <source>Entering catch."); ++iIndex; // The 'ref' parameter in C#.</source>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve">
          <source>Console.WriteLine ("In catch of -- Exception.</source>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve">
          <source>Leaving catch."); //retry; // In C# we let the caller method do the work // that the retry keyword does in X++.</source>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source>} Console.WriteLine("End of C# callee method."); return bReturnCode; } }</source>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>Output</source>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve">
          <source>Here is the output to the console:</source>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve">
          <source>Comparison: Operators</source>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve">
          <source>This section compares the operators between X++ and C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve">
          <source>Assignment Operators</source>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve">
          <source>The following table displays the differences between the assignment operators in X++ and C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve">
          <source>X++ and C#</source>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve">
          <source>Differences</source>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve">
          <source>In X++ this operator causes an implicit conversion whenever a loss of precision might occur, such for an assignment from an <bpt id="p1">&lt;strong&gt;</bpt>int64<ept id="p1">&lt;/strong&gt;</ept> to an <bpt id="p2">&lt;strong&gt;</bpt>int<ept id="p2">&lt;/strong&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve">
          <source>But in C# the assignment causes a compile error.</source>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`+=`</ph> and <ph id="ph2">`-=`</ph></source>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve">
          <source>The only difference is that in C# these operators are also used in delegate manipulation.</source>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source>++ and --</source>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source>These are the increment and decrement operators in both languages.</source>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>The following line is identical in both languages:</source>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source>But in X++ these two operators are for statements, not for expressions.</source>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>Therefore the following lines generate compile errors in X++:</source>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators</source>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve">
          <source>The following table lists the arithmetic operators.</source>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>X++ and C#</source>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>Differences</source>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve">
          <source>As the multiplication operator, there are no differences.</source>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>: The asterisk is also used in the SQL statements that are part of the X++ language.</source>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve">
          <source>In these SQL statements the asterisk can also be one of the following:</source>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve">
          <source>A wildcard indicating that all the columns should be returned.</source>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve">
          <source>A wildcard for characters in a string that is used on a <bpt id="p1">&lt;strong&gt;</bpt>like<ept id="p1">&lt;/strong&gt;</ept> clause.</source>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve">
          <source>The division operator is the same in X++ and C#.</source>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve">
          <source>For modulo operations, the only difference is that the % symbol is used in C#.</source>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve">
          <source>The addition operator is the same in X++ and C#.</source>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>The plus sign is also used for string concatenation.</source>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve">
          <source>This operator adds numbers and concatenates strings in both languages.</source>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve">
          <source>The subtraction operator is the same in X++ and C#.</source>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve">
          <source>Bitwise Operators</source>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve">
          <source>The following table compares the bitwise operators between X++ and C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve">
          <source>X++ and C<ph id="ph1">\#</ph></source>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source>Differences</source>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve">
          <source>The left shift operator is the same in X++ and C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve">
          <source>The right shift operator is the same in X++ and C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve">
          <source>The bitwise NOT operator is the same in X++ and C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve">
          <source>The binary AND operator is the same in X++ and C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve">
          <source>The binary XOR operator is the same in X++ and C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve">
          <source>The binary OR operator is the same in X++ and C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source>Relational Operators</source>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source>The following relational operators are the same in X++ and C<ph id="ph1">\#</ph>:</source>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source>Comparison: Events</source>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve">
          <source>There are some differences in how X++ and C# implement the event design pattern.</source>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve">
          <source>For more information, see Event Terminology and Keywords.</source>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve">
          <source>Comparison of Events between X++ and C<ph id="ph1">\#</ph></source>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve">
          <source>There are differences in the way delegates are used for events in X++ versus C#.</source>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve">
          <source>Concept</source>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve">
          <source>X++</source>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;strong&gt;</bpt>delegate<ept id="p1">&lt;/strong&gt;</ept></source>
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve">
          <source>In X++, a delegate can be declared only as a member on a class.</source>
        </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve">
          <source>A delegate cannot be a member on a table.</source>
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve">
          <source>All delegates are instance members of their class, not <bpt id="p1">&lt;strong&gt;</bpt>static<ept id="p1">&lt;/strong&gt;</ept> members.</source>
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve">
          <source>No access modifier can be used on a delegate declaration, because all delegates are <bpt id="p1">&lt;strong&gt;</bpt>protected<ept id="p1">&lt;/strong&gt;</ept> members.</source>
        </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve">
          <source>Therefore, the event can be raised only by code within the same class where the delegate is a member.</source>
        </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve">
          <source>However, the one exception to the private nature of a delegate is that code outside their class can operate on the delegates by using the += and -= operators.</source>
        </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve">
          <source>In C#, each <bpt id="p1">&lt;strong&gt;</bpt>delegate<ept id="p1">&lt;/strong&gt;</ept> is a type, just as every <bpt id="p2">&lt;strong&gt;</bpt>class<ept id="p2">&lt;/strong&gt;</ept> is a type.</source>
        </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve">
          <source>A delegate is declared independently of any class.</source>
        </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve">
          <source>Without the <bpt id="p1">&lt;strong&gt;</bpt>event<ept id="p1">&lt;/strong&gt;</ept> keyword, you can have a delegate as a parameter type on a method, just as you can have a class as a parameter type.</source>
        </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve">
          <source>You can construct an instance of a delegate to pass in for the parameter value.</source>
        </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve">
          <source>In X++, each class is a type, but no delegate is a type.</source>
        </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve">
          <source>You cannot construct an instance of a delegate.</source>
        </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve">
          <source>No delegate can be a parameter for a method.</source>
        </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve">
          <source>But you can create a class that has a delegate member, and you can pass instances of the class as parameter values.</source>
        </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve">
          <source>For more information, see X++ Keywords.</source>
        </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;strong&gt;</bpt>event<ept id="p1">&lt;/strong&gt;</ept></source>
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve">
          <source>In X++ code, an event is one of the following:</source>
        </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve">
          <source>An explicit call to a delegate.</source>
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve">
          <source>The start or end of a method.</source>
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve">
          <source>There is no <bpt id="p1">&lt;strong&gt;</bpt>event<ept id="p1">&lt;/strong&gt;</ept> keyword in X++.</source>
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve">
          <source>In C#, the <bpt id="p1">&lt;strong&gt;</bpt>event<ept id="p1">&lt;/strong&gt;</ept> keyword is used to declare a <bpt id="p2">&lt;strong&gt;</bpt>delegate<ept id="p2">&lt;/strong&gt;</ept> type as a member of a class.</source>
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve">
          <source>The effect of the <bpt id="p1">&lt;strong&gt;</bpt>event<ept id="p1">&lt;/strong&gt;</ept> keyword is to make the delegate <bpt id="p2">&lt;strong&gt;</bpt>protected<ept id="p2">&lt;/strong&gt;</ept>, yet still accessible for the += and -= operators.</source>
        </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve">
          <source>You can subscribe event handler methods to an <bpt id="p1">&lt;strong&gt;</bpt>event<ept id="p1">&lt;/strong&gt;</ept> by using the += operator.</source>
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;strong&gt;</bpt>delegate<ept id="p1">&lt;/strong&gt;</ept> can be useful without the <bpt id="p2">&lt;strong&gt;</bpt>event<ept id="p2">&lt;/strong&gt;</ept> keyword, as a technique for passing a function pointer as a parameter into a method.</source>
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve">
          <source>The automatic events that occur before the start of a method, and after the end of a method, can be subscribed to only by using the AOT.</source>
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve">
          <source>+= and -= operators</source>
        </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source>In X++, you use the += operator to subscribe methods to a <bpt id="p1">&lt;strong&gt;</bpt>delegate<ept id="p1">&lt;/strong&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve">
          <source>The -= operator unsubscribes a method from a delegate.</source>
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve">
          <source>In C#, you use the += operator to subscribe methods to an <bpt id="p1">&lt;strong&gt;</bpt>event<ept id="p1">&lt;/strong&gt;</ept>, or to a <bpt id="p2">&lt;strong&gt;</bpt>delegate<ept id="p2">&lt;/strong&gt;</ept> that is not used with the <bpt id="p3">&lt;strong&gt;</bpt>event<ept id="p3">&lt;/strong&gt;</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve">
          <source>The delegate contains a reference to all the objects that have methods subscribed to the delegate.</source>
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve">
          <source>Those objects are not eligible for garbage collection while delegate holds those references.</source>
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve">
          <source>In X++, the <bpt id="p1">&lt;strong&gt;</bpt>eventHandler<ept id="p1">&lt;/strong&gt;</ept> keyword is required when you use either the += or -= operator to subscribe or unsubscribe a method from a delegate.</source>
        </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`System.EventHandler`</ph> is a delegate type in the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve">
          <source>This term is used differently in X++ than it is in C# or the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve">
          <source>For more information, see X++ Keywords.</source>
        </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve">
          <source>X++ Example</source>
        </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve">
          <source>The important things to notice in the X++ example are the following:</source>
        </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`XppClass`</ph> has a delegate member that is named <ph id="ph2">`myDelegate`</ph>.</source>
        </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>: The AOT contains a node for the delegate.</source>
        </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve">
          <source>The node is located at AOT &gt; Classes &gt; XppClass &gt; myDelegate.</source>
        </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve">
          <source>Several event handler nodes can be located under the myDelegate node.</source>
        </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve">
          <source>Event handlers that are represented by nodes in the AOT cannot be removed by the -= operator during run time.</source>
        </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve">
          <source>The {} braces at the end of the delegate declaration are required, but they cannot have any code in them.</source>
        </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`XppClass`</ph> has two methods whose parameter signatures are compatible with the delegate.</source>
        </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve">
          <source>One method is static.</source>
        </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve">
          <source>The two compatible methods are added to the delegate with the += operator and the <bpt id="p1">**</bpt>eventHandler<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve">
          <source>These statements do not call the event handler methods, the statements only add the methods to the delegate.</source>
        </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve">
          <source>The event is raised by one call to the delegate.</source>
        </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve">
          <source>The parameter value that passed in to the delegate is received by each event handler method.</source>
        </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve">
          <source>The short X++ job at the top of the example starts the test.</source>
        </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve">
          <source>The output from the previous X++ job is as follows:</source>
        </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve">
          <source>C# Sample</source>
        </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve">
          <source>This section contains a C<ph id="ph1">\#</ph> code sample for the event design pattern of the previous X++ sample.</source>
        </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve">
          <source>The output from the previous C<ph id="ph1">\#</ph> sample is as follows:</source>
        </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve">
          <source>Events and the AOT</source>
        </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve">
          <source>Finance and Operations has other event systems that apply only to items in the AOT.</source>
        </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve">
          <source>For more information, see Event Handler Nodes in the AOT.</source>
        </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve">
          <source>Comparison: Precompiler Directives</source>
        </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve">
          <source>X++ and C# share some keywords for their precompiler directive syntax, but the meanings are not always the same.</source>
        </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve">
          <source>Similarities</source>
        </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve">
          <source>The X++ and C<ph id="ph1">\#</ph> compilers recognize many of the same keywords.</source>
        </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve">
          <source>In most cases, the keywords mean the same for both language compilers.</source>
        </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve">
          <source>Differences</source>
        </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve">
          <source>A fundamental difference between the precompiler directives in X++ versus C<ph id="ph1">\#</ph> is the <ph id="ph2">\#</ph>define keyword that both language precompilers recognize.</source>
        </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve">
          <source>Unlike C<ph id="ph1">\#</ph>, in X++ the <ph id="ph2">\#</ph>define directive requires a dot in its syntax.</source>
        </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve">
          <source>In X++, parentheses can be used to give the defined symbol a value.</source>
        </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve">
          <source>These differences are shown in the following examples:</source>
        </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve">
          <source>In X++: <ph id="ph1">\#</ph>define.InitialYear(2003)</source>
        </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>In C<ph id="ph1">\#</ph>: <ph id="ph2">\#</ph>define InitialYear</source>
        </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve">
          <source>A minor difference is that in C<ph id="ph1">\#</ph> there can be spaces and tab characters between the <ph id="ph2">\#</ph> character and the directive keyword, such as <ph id="ph3">\#</ph> define Testing.</source>
        </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve">
          <source>Identical Keywords</source>
        </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve">
          <source>The following table lists precompiler directives that are similar in X++ and C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve">
          <source>Keyword</source>
        </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve">
          <source>X++</source>
        </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve">
          <source>In X++, a precompiler variable name can be defined, and a value can be given to that variable.</source>
        </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve">
          <source>In C<ph id="ph1">\#</ph>, a precompiler variable name can be defined, but no value can be given to that variable.</source>
        </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve">
          <source>Also, any <ph id="ph1">\#</ph>define in C<ph id="ph2">\#</ph> must occur at the top of the file, and cannot occur after any code such as a using statement or a class declaration.</source>
        </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve">
          <source>The C<ph id="ph1">\#</ph> compiler can input a command line parameter of <ph id="ph2">`/define`</ph> to define a precompiler variable name without defining the variable in any C<ph id="ph3">\#</ph> code file.</source>
        </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve">
          <source>The X++ compiler has no counterpart to <ph id="ph1">`/define`</ph>.</source>
        </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve">
          <source>In X++, <ph id="ph1">\#</ph>if can determine whether a precompiler variable exists, and whether the variable has a given value.</source>
        </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve">
          <source>In C<ph id="ph1">\#</ph>, <ph id="ph2">\#</ph>if can only determine whether a precompiler variable exists.</source>
        </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve">
          <source>It cannot test for any value because no value can be assigned.</source>
        </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve">
          <source>In X++, <ph id="ph1">\#</ph>endif marks the end of an <ph id="ph2">\#</ph>if block.</source>
        </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve">
          <source>It also ends an <ph id="ph1">\#</ph>ifnot block.</source>
        </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve">
          <source>In C<ph id="ph1">\#</ph>, <ph id="ph2">\#</ph>endif marks the end of an <ph id="ph3">\#</ph>if block, regardless of whether the block includes a <ph id="ph4">\#</ph>else.</source>
        </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve">
          <source>Different Keywords with the Same Processing Result</source>
        </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve">
          <source>The following table lists precompiler directives that are named differently in X++ and C<ph id="ph1">\#</ph>, but that give the same results when processed.</source>
        </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve">
          <source>X++</source>
        </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\#</ph>ifnot</source>
        </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\#</ph>if <ph id="ph2">\#</ph>else</source>
        </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve">
          <source>There is no <ph id="ph1">\#</ph>else directive in X++, but the <ph id="ph2">\#</ph>ifnot provides similar functionality.</source>
        </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve">
          <source>In X++, <ph id="ph1">\#</ph>ifnot can determine whether a precompiler variable exists, and whether the variable does not have a specific given value.</source>
        </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve">
          <source>In C<ph id="ph1">\#</ph>, <ph id="ph2">\#</ph>if can determine whether a precompiler variable exists when the !</source>
        </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve">
          <source>symbol is prefixed to the variable name.</source>
        </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\#</ph>pragma warning</source>
        </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve">
          <source>These X++ and C<ph id="ph1">\#</ph> entries are not equivalent, but there is a partial similarity.</source>
        </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve">
          <source>Both suppress compiler warning messages.</source>
        </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\#</ph>macrolib</source>
        </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve">
          <source>.HPP file in C++</source>
        </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve">
          <source>There is a partial similarity between the X++ directive <ph id="ph1">\#</ph>macrolib versus an .HPP file in C++.</source>
        </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve">
          <source>Both can contain several <ph id="ph1">\#</ph>define statements.</source>
        </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve">
          <source>Precompiler Directives Exclusive to X++</source>
        </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve">
          <source>The following table lists X++ precompiler directives that have no direct counterpart in C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve">
          <source>X++</source>
        </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\#</ph>linenumber</source>
        </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">\#</ph>linenumber directive is for obtaining the line number, so that it can be output to the Infolog.</source>
        </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve">
          <source>The C<ph id="ph1">\#</ph> directive <ph id="ph2">\#</ph>line is different because its purpose is for setting the line number.</source>
        </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\#</ph>defdec <ph id="ph2">\#</ph>definc</source>
        </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\#</ph>globaldefine</source>
        </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve">
          <source>In X++, there is a small difference between <ph id="ph1">\#</ph>globaldefine versus <ph id="ph2">\#</ph>define.</source>
        </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve">
          <source>The difference is that <ph id="ph1">\#</ph>globaldefine never overwrites a current nonnull value that was assigned to a precompiler variable by <ph id="ph2">\#</ph>define.</source>
        </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve">
          <source>C<ph id="ph1">\#</ph> has nothing similar to this difference, because in C<ph id="ph2">\#</ph>, a precompiler variable name cannot be given a value.</source>
        </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\#</ph>localmacro <ph id="ph2">\#</ph>macro</source>
        </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve">
          <source>In X++, <ph id="ph1">\#</ph>localmacro enables you to assign a multiline value to a precompiler variable.</source>
        </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\#</ph>macro is a synonym, but <ph id="ph2">\#</ph>localmacro is recommended.</source>
        </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve">
          <source>In C<ph id="ph1">\#</ph>, the <ph id="ph2">\#</ph>define directive has part of this functionality, but it cannot assign a value to a precompiler variable.</source>
        </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve">
          <source><ph id="ph1">\#</ph>globalmacro</source>
        </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve">
          <source>In X++, <ph id="ph1">\#</ph>globalmacro is almost the same as the preferred <ph id="ph2">\#</ph>localmacro.</source>
        </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve">
          <source>Comparison: Object Oriented Programming</source>
        </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve">
          <source>The object oriented programming (OOP) principles of X++ differ from C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve">
          <source>Conceptual Comparisons</source>
        </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve">
          <source>The following table compares the implementation of OOP principles between X++ and C<ph id="ph1">\#</ph>.</source>
        </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve">
          <source>Feature</source>
        </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve">
          <source>X++</source>
        </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve">
          <source>Casting</source>
        </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve">
          <source>The X++ language has the keywords <bpt id="p1">&lt;strong&gt;</bpt>is<ept id="p1">&lt;/strong&gt;</ept> and <bpt id="p2">&lt;strong&gt;</bpt>as<ept id="p2">&lt;/strong&gt;</ept>, which are used to make downcasts safe and explicit.</source>
        </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Tip<ept id="p1">**</ept>: X++ does not require the use of the <bpt id="p2">&lt;strong&gt;</bpt>as<ept id="p2">&lt;/strong&gt;</ept> keyword when you downcast a base class variable to a derived class variable.</source>
        </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve">
          <source>However, we recommend that all downcast statements use the <bpt id="p1">&lt;strong&gt;</bpt>as<ept id="p1">&lt;/strong&gt;</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve">
          <source>An object can be cast either up or down the inheritance path.</source>
        </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve">
          <source>Downcasts require the <bpt id="p1">&lt;strong&gt;</bpt>as<ept id="p1">&lt;/strong&gt;</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve">
          <source>For more information about the X++ keywords <bpt id="p1">&lt;strong&gt;</bpt>is<ept id="p1">&lt;/strong&gt;</ept> and <bpt id="p2">&lt;strong&gt;</bpt>as<ept id="p2">&lt;/strong&gt;</ept>, see Expression Operators: Is and As for Inheritance.</source>
        </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve">
          <source>Local functions</source>
        </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve">
          <source>A method can contain a declaration and code body for zero or more local functions.</source>
        </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve">
          <source>Only that method can have calls to the local function.</source>
        </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve">
          <source>C# 3.0 supports lambda expressions, which have some similarity to anonymous functions and local functions.</source>
        </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve">
          <source>Lambda expressions are often used with delegates.</source>
        </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve">
          <source>Method overloading</source>
        </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve">
          <source>Method overloading is not supported.</source>
        </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve">
          <source>A method name can occur only one time per class.</source>
        </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve">
          <source>Method overloading is supported.</source>
        </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve">
          <source>A method name can occur multiple times in one class, with different parameter signatures in each case.</source>
        </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve">
          <source>X++ does support optional parameters on methods.</source>
        </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve">
          <source>Optional parameters can partially mimic method overloading.</source>
        </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve">
          <source>For more information, see the row for optional parameters in this table.</source>
        </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve">
          <source>Method overriding</source>
        </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve">
          <source>Method overriding is supported.</source>
        </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve">
          <source>A derived class can have a method by the same name as in the base class, as long as the parameter signature is the same in both cases.</source>
        </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve">
          <source>The only exception is that the overriding method can add a default value to a parameter.</source>
        </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve">
          <source>Method overriding is supported.</source>
        </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>virtual<ept id="p1">&lt;/strong&gt;</ept> keyword must be applied to a method before the method can be overridden in a derived class.</source>
        </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve">
          <source>The concept of overriding a method includes the method name, its parameter signature, and its return type.</source>
        </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve">
          <source>The concept of method overriding does not apply if the base method and the overriding method differ in any of these aspects.</source>
        </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve">
          <source>Optional parameters</source>
        </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve">
          <source>A parameter declaration can be followed by a default value assignment.</source>
        </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve">
          <source>The method caller has the option of passing a value for that parameter, or ignoring the parameter to accept the default value.</source>
        </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve">
          <source>This feature mimics method overloading because two calls to the same method name can pass different numbers of parameters.</source>
        </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve">
          <source>Each parameter that has a default value must follow the last parameter that does not have a default value.</source>
        </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve">
          <source>Optional parameters are supported by the <bpt id="p1">&lt;strong&gt;</bpt>params<ept id="p1">&lt;/strong&gt;</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve">
          <source>Even without the <bpt id="p1">&lt;strong&gt;</bpt>params<ept id="p1">&lt;/strong&gt;</ept> keyword, from the point of view of the caller, method overloading can provide partially similar functionality.</source>
        </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve">
          <source>For more information, see Parameters and Scoping and Using Optional Parameters.</source>
        </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve">
          <source>Single inheritance</source>
        </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve">
          <source>You can derive your X++ class from another X++ class by using the <bpt id="p1">&lt;strong&gt;</bpt>extends<ept id="p1">&lt;/strong&gt;</ept> keyword in the classDeclaration node of your class, in the AOT.</source>
        </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve">
          <source>No class implicitly derives directly from another class.</source>
        </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve">
          <source>If you want your class to directly derive from the <ph id="ph1">`Object`</ph> class, you must use the <bpt id="p1">&lt;strong&gt;</bpt>extends<ept id="p1">&lt;/strong&gt;</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve">
          <source>You can specify only one class on the <bpt id="p1">&lt;strong&gt;</bpt>extends<ept id="p1">&lt;/strong&gt;</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Caution<ept id="p1">**</ept>: When you modify an X++ base class that other classes derive from, you must recompile that base class using the Compile forward.</source>
        </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve">
          <source>This option ensures that the derived classes are also recompiled.</source>
        </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve">
          <source>To ensure the derived classes are also recompiled, right-click the base class node, and then click Add-Ins &gt; Compile forward.</source>
        </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve">
          <source>The alternative of clicking Build &gt; Compile (or pressing the F7 key) is sometimes insufficientfor a base class change.</source>
        </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve">
          <source>A class can implement zero to many interfaces.</source>
        </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve">
          <source>An X++ table implicitly inherits from the <ph id="ph1">`Common`</ph> table, and from the <ph id="ph2">`xRecord`</ph> class.</source>
        </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve">
          <source>C# uses the <bpt id="p1">&lt;strong&gt;</bpt>extends<ept id="p1">&lt;/strong&gt;</ept> keyword to derive from another class.</source>
        </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve">
          <source>All .NET Framework classes implicitly derive from the <ph id="ph1">`System.Object`</ph> class, unless they explicitly derive from another class.</source>
        </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve">
          <source>Keyword Comparisons</source>
        </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve">
          <source>The following table lists the OOP-related keywords in X++ and C#.</source>
        </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve">
          <source>Keyword</source>
        </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve">
          <source>X++</source>
        </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;strong&gt;</bpt>abstract<ept id="p1">&lt;/strong&gt;</ept></source>
        </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve">
          <source>No difference.</source>
        </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;strong&gt;</bpt>class<ept id="p1">&lt;/strong&gt;</ept></source>
        </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve">
          <source>The modifiers <bpt id="p1">&lt;strong&gt;</bpt>public<ept id="p1">&lt;/strong&gt;</ept> and <bpt id="p2">&lt;strong&gt;</bpt>private<ept id="p2">&lt;/strong&gt;</ept> are ignored on class declarations.</source>
        </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve">
          <source>There is no concept of a namespace grouping of classes.</source>
        </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve">
          <source>There are no dots (.) in any class names.</source>
        </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve">
          <source>The modifiers <bpt id="p1">&lt;strong&gt;</bpt>public<ept id="p1">&lt;/strong&gt;</ept> and <bpt id="p2">&lt;strong&gt;</bpt>private<ept id="p2">&lt;/strong&gt;</ept> can be used to modify class declarations.</source>
        </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve">
          <source>C# also has the keyword <bpt id="p1">&lt;strong&gt;</bpt>internal<ept id="p1">&lt;/strong&gt;</ept>, which relates to how classes are grouped together in assembly files.</source>
        </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve">
          <source>There is no concept of a <bpt id="p1">&lt;strong&gt;</bpt>protected<ept id="p1">&lt;/strong&gt;</ept> class, only <bpt id="p2">&lt;strong&gt;</bpt>protected<ept id="p2">&lt;/strong&gt;</ept> members of a class.</source>
        </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;strong&gt;</bpt>extends<ept id="p1">&lt;/strong&gt;</ept></source>
        </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve">
          <source>A class declaration can inherit from another class by using the <bpt id="p1">&lt;strong&gt;</bpt>extends<ept id="p1">&lt;/strong&gt;</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve">
          <source>A colon (:) is used where the keywords <bpt id="p1">&lt;strong&gt;</bpt>extends<ept id="p1">&lt;/strong&gt;</ept> and <bpt id="p2">&lt;strong&gt;</bpt>implements<ept id="p2">&lt;/strong&gt;</ept> are used in X++.</source>
        </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;strong&gt;</bpt>final<ept id="p1">&lt;/strong&gt;</ept></source>
        </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;strong&gt;</bpt>final<ept id="p1">&lt;/strong&gt;</ept> method cannot be overridden in a derived class.</source>
        </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">&lt;strong&gt;</bpt>final<ept id="p1">&lt;/strong&gt;</ept> class cannot be extended.</source>
        </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve">
          <source>The keyword <bpt id="p1">&lt;strong&gt;</bpt>sealed<ept id="p1">&lt;/strong&gt;</ept> on a class means the same thing that <bpt id="p2">&lt;strong&gt;</bpt>final<ept id="p2">&lt;/strong&gt;</ept> means on an X++ class.</source>
        </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;strong&gt;</bpt>implements<ept id="p1">&lt;/strong&gt;</ept></source>
        </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve">
          <source>A class declaration can implement an <bpt id="p1">&lt;strong&gt;</bpt>interface<ept id="p1">&lt;/strong&gt;</ept> by using the <bpt id="p2">&lt;strong&gt;</bpt>implements<ept id="p2">&lt;/strong&gt;</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;strong&gt;</bpt>interface<ept id="p1">&lt;/strong&gt;</ept></source>
        </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">&lt;strong&gt;</bpt>interface<ept id="p1">&lt;/strong&gt;</ept> can specify methods that the class must implement.</source>
        </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">&lt;strong&gt;</bpt>interface<ept id="p1">&lt;/strong&gt;</ept> can specify methods that the class must implement.</source>
        </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;strong&gt;</bpt>new<ept id="p1">&lt;/strong&gt;</ept></source>
        </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>new<ept id="p1">&lt;/strong&gt;</ept> keyword is used to allocate a new instance of a class.</source>
        </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve">
          <source>Then the constructor is automatically called.</source>
        </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve">
          <source>Each class has exactly one constructor, and the constructor is named <ph id="ph1">`new`</ph>.</source>
        </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve">
          <source>You can decide what parameters the constructor should input.</source>
        </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>new<ept id="p1">&lt;/strong&gt;</ept> keyword is used to create a new instance of a class.</source>
        </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve">
          <source>Then the constructor is automatically called.</source>
        </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve">
          <source>Constructor methods themselves are not named <ph id="ph1">`new`</ph>, they have the same name as the class.</source>
        </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>: The <bpt id="p2">&lt;strong&gt;</bpt>new<ept id="p2">&lt;/strong&gt;</ept> keyword can also be used on a method, to modify the way in which the method overrides the same method in the base class.</source>
        </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve">
          <source>Both X++ and C# assume a default constructor for classes that have no constructor explicitly written in their code.</source>
        </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;strong&gt;</bpt>null<ept id="p1">&lt;/strong&gt;</ept></source>
        </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve">
          <source>No difference.</source>
        </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;strong&gt;</bpt>private<ept id="p1">&lt;/strong&gt;</ept> and <bpt id="p2">&lt;strong&gt;</bpt>protected<ept id="p2">&lt;/strong&gt;</ept></source>
        </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>private<ept id="p1">&lt;/strong&gt;</ept> and <bpt id="p2">&lt;strong&gt;</bpt>protected<ept id="p2">&lt;/strong&gt;</ept> keywords can be used to modify the declaration of a class member.</source>
        </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>private<ept id="p1">&lt;/strong&gt;</ept> and <bpt id="p2">&lt;strong&gt;</bpt>protected<ept id="p2">&lt;/strong&gt;</ept> keywords can be used to modify the declaration of a class member.</source>
        </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;strong&gt;</bpt>public<ept id="p1">&lt;/strong&gt;</ept></source>
        </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve">
          <source>A method that is not modified with <bpt id="p1">&lt;strong&gt;</bpt>public<ept id="p1">&lt;/strong&gt;</ept>, <bpt id="p2">&lt;strong&gt;</bpt>protected<ept id="p2">&lt;/strong&gt;</ept>, or <bpt id="p3">&lt;strong&gt;</bpt>private<ept id="p3">&lt;/strong&gt;</ept> has the default access level of <bpt id="p4">&lt;strong&gt;</bpt>public<ept id="p4">&lt;/strong&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve">
          <source>A method that is not modified with <bpt id="p1">&lt;strong&gt;</bpt>public<ept id="p1">&lt;/strong&gt;</ept>, <bpt id="p2">&lt;strong&gt;</bpt>protected<ept id="p2">&lt;/strong&gt;</ept>, or <bpt id="p3">&lt;strong&gt;</bpt>private<ept id="p3">&lt;/strong&gt;</ept> has the default access level of <bpt id="p4">&lt;strong&gt;</bpt>private<ept id="p4">&lt;/strong&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;strong&gt;</bpt>static<ept id="p1">&lt;/strong&gt;</ept></source>
        </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve">
          <source>A method can be <bpt id="p1">&lt;strong&gt;</bpt>static<ept id="p1">&lt;/strong&gt;</ept>, but a field cannot.</source>
        </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve">
          <source>Both methods and fields can be <bpt id="p1">&lt;strong&gt;</bpt>static<ept id="p1">&lt;/strong&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;strong&gt;</bpt>super<ept id="p1">&lt;/strong&gt;</ept></source>
        </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>super<ept id="p1">&lt;/strong&gt;</ept> keyword is used in a derived class to access the same method on its base class.</source>
        </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>base<ept id="p1">&lt;/strong&gt;</ept> keyword is used in a derived class to access various methods in its base class.</source>
        </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve">
          <source>In C#, there is special syntax for using <bpt id="p1">&lt;strong&gt;</bpt>base<ept id="p1">&lt;/strong&gt;</ept> to call the base constructor.</source>
        </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve">
          <source><bpt id="p1">&lt;strong&gt;</bpt>this<ept id="p1">&lt;/strong&gt;</ept></source>
        </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve">
          <source>For a call from one instance method to another on the same object, a qualifier for the called method is required.</source>
        </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve">
          <source>The keyword <bpt id="p1">&lt;strong&gt;</bpt>this<ept id="p1">&lt;/strong&gt;</ept> is available as a qualifier for the current object.</source>
        </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve">
          <source>For a call from one instance method to another on the same object, a qualifier for the called method is not required.</source>
        </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve">
          <source>However, the <bpt id="p1">&lt;strong&gt;</bpt>this<ept id="p1">&lt;/strong&gt;</ept> keyword is available as a qualifier for the current object.</source>
        </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve">
          <source>In practice, the keyword <bpt id="p1">&lt;strong&gt;</bpt>this<ept id="p1">&lt;/strong&gt;</ept> can be helpful by displaying IntelliSense information.</source>
        </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`Object`</ph> class contains the <ph id="ph2">`finalize`</ph> method.</source>
        </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`finalize`</ph> method is not <bpt id="p1">&lt;strong&gt;</bpt>final<ept id="p1">&lt;/strong&gt;</ept>, and it can be overridden.</source>
        </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`finalize`</ph> method appears to resemble the <ph id="ph2">`System.Object.Finalize`</ph> method in C#, but in X++ the <ph id="ph3">`finalize`</ph> method has no special meaning of any kind.</source>
        </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve">
          <source>An object is automatically removed from memory when the last reference to the object stops referencing the object.</source>
        </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve">
          <source>For example, this can happen when the last reference goes out of scope or is assigned another object to reference.</source>
        </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve">
          <source>The methods <ph id="ph1">`Finalize`</ph> and <ph id="ph2">`Dispose`</ph> are common on some types of classes.</source>
        </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve">
          <source>The garbage collector calls the <ph id="ph1">`Finalize`</ph> and <ph id="ph2">`Dispose`</ph> methods when it destroys and object.</source>
        </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve">
          <source>In C#, the <ph id="ph1">`System.GC.Collect`</ph> method in the .NET Framework can be called to start the garbage collector.</source>
        </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve">
          <source>There is no similar function in X++ because X++ uses a deterministic garbage collector.</source>
        </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve">
          <source>Classes that are invoked from a menu have their <ph id="ph1">`main`</ph> method called by the system.</source>
        </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve">
          <source>Classes that are invoked from a command line console have their <ph id="ph1">`Main`</ph> method called by the system.</source>
        </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve">
          <source>Comparison: Classes</source>
        </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve">
          <source>When you use C<ph id="ph1">\#</ph> in the .NET Framework, classes are grouped into namespaces.</source>
        </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve">
          <source>Each namespace focuses on a functional area such as file operations or reflection.</source>
        </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve">
          <source>However, when you use the classes in X++, there are no visible groupings like a namespace.</source>
        </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve">
          <source>Comparison: Classes about Reflection</source>
        </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve">
          <source>In X++ the <ph id="ph1">`TreeNode`</ph> class provides access to the Application Object Tree (AOT).</source>
        </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`TreeNode`</ph> class is the center of reflection functionality in X++.</source>
        </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`TreeNode`</ph> class and its methods can be compared to the <ph id="ph2">`System.Reflection`</ph> namespace in the .NET Framework that C<ph id="ph3">\#</ph> uses.</source>
        </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve">
          <source>The following table lists several classes that are available to you when you write C<ph id="ph1">\#</ph> code.</source>
        </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve">
          <source>These are .NET Framework classes.</source>
        </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve">
          <source>For this table, all C<ph id="ph1">\#</ph> classes are in the <ph id="ph2">`System.Reflection`</ph> namespace unless otherwise specified.</source>
        </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve">
          <source>Each row shows the corresponding class, or class member, that is available to you when your write X++ code.</source>
        </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve">
          <source>X++</source>
        </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve">
          <source>Assembly is the first class to use when a C<ph id="ph1">\#</ph> program must gather reflection information.</source>
        </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve">
          <source>Static methods on the X++ class <ph id="ph1">`TreeNode`</ph> are the starting point for reflection in X++.</source>
        </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve">
          <source>Instance methods on <ph id="ph1">`TreeNode`</ph> correspond to instance methods on <ph id="ph2">`System.Type`</ph>.</source>
        </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`AOTgetSource`</ph> method returns several pieces of information together in one string.</source>
        </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve">
          <source>This includes the X++ source code in the method.</source>
        </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve">
          <source>In contrast, <ph id="ph1">`MethodInfo`</ph> has a separate member for each piece of information.</source>
        </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`TreeNode .AOTfirstChild`</ph> <ph id="ph2">`TreeNode .AOTnextSibling`</ph> <ph id="ph3">`TreeNode .AOTiterator`</ph> <ph id="ph4">`AOTiterator`</ph></source>
        </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve">
          <source>MethodInfo<ph id="ph1">\[</ph><ph id="ph2">\]</ph> (an array)</source>
        </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve">
          <source>In C<ph id="ph1">\#</ph>, the <ph id="ph2">`GetMethods`</ph> method on <ph id="ph3">`System.Type`</ph> returns an array of MethodInfo objects.</source>
        </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve">
          <source>You can loop through the array by the common technique of incrementing an indexer.</source>
        </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve">
          <source>In contrast, the X++ model is to navigate the tree control of the AOT.</source>
        </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`TreeNode`</ph> methods of <ph id="ph2">`AOTfirstChild`</ph> and <ph id="ph3">`AOTnextSibling`</ph> accomplish the navigation.</source>
        </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve">
          <source>As an equivalent alternative, the X++ <ph id="ph1">`AOTiterator`</ph> class is designed to navigate the tree control of the AOT.</source>
        </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve">
          <source>A class node is the parent over several method nodes.</source>
        </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`AOTiterator`</ph> steps through child nodes, returning each as another <ph id="ph2">`TreeNode`</ph> instance.</source>
        </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve">
          <source>See also the <ph id="ph1">`TreeNode`</ph> methods that are named <ph id="ph2">`AOTparent`</ph> and <ph id="ph3">`AOTprevious`</ph>.</source>
        </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`TreeNode .AOTgetProperty`</ph> <ph id="ph2">`TreeNode .AOTgetProperties`</ph> <ph id="ph3">`TreeNode .AOTname`</ph></source>
        </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve">
          <source>In X++, the <ph id="ph1">`AOTgetProperties`</ph> method returns a long string that contains name-value pairs for all the properties of the <ph id="ph2">`TreeNode`</ph>.</source>
        </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`AOTname`</ph> method returns a string that contains only the value for the name property.</source>
        </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`TreeNode .AOTsave`</ph> <ph id="ph2">`TreeNode .AOTinsert`</ph></source>
        </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`System .Reflection .Emit`</ph> (namespace of classes)</source>
        </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`AOTsave`</ph> method applies changes from a <ph id="ph2">`TreeNode`</ph> object in your X++ code to the AOT, and the changes are persisted.</source>
        </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve">
          <source>For a large code sample, see TreeNode.AOTsave Method.</source>
        </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve">
          <source>Comparison: Classes about File IO</source>
        </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve">
          <source>There are several classes that perform file input and output (IO) operations.</source>
        </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve">
          <source>In the .NET Framework that is used in C<ph id="ph1">\#</ph>, the counterparts to these classes reside in the <ph id="ph2">`System.IO`</ph> namespace.</source>
        </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve">
          <source>The following table lists several .NET Framework classes for C<ph id="ph1">\#</ph> that are in the <ph id="ph2">`System.IO`</ph> namespace.</source>
        </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve">
          <source>Each row in the table shows the X++ class or method that best corresponds to the .NET Framework class.</source>
        </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve">
          <source>X++</source>
        </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve">
          <source>C#</source>
        </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`FileStream`</ph> <ph id="ph2">`BinaryReader`</ph> <ph id="ph3">`BinaryWriter`</ph></source>
        </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve">
          <source>X++ classes such as <ph id="ph1">`BinaryIo`</ph> that extend from the abstract class <ph id="ph2">`Io`</ph> serve as a stream, and they also serve as a reader and writer for that stream.</source>
        </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve">
          <source>In C# the stream is a separate class the from the class that has the more specific read and write methods.</source>
        </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve">
          <source>These classes contain an in-memory buffer, and some of the methods treat the buffer as if it were a file on the hard disk.</source>
        </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve">
          <source>WINAPI::createDirectory WINAPI::folderExists WINAPI::removeDirectory</source>
        </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Directory`</ph> <ph id="ph2">`DirectoryInfo`</ph> <ph id="ph3">`Path`</ph></source>
        </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve">
          <source>X++ can use static methods in the <ph id="ph1">`WINAPI`</ph> class for many basic operating system functions that involve directories.</source>
        </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve">
          <source>WINAPI::getDriveType</source>
        </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`DriveInfo`</ph> <ph id="ph2">`DriveType`</ph></source>
        </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve">
          <source>These classes and methods are used to obtain drive related information.</source>
        </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve">
          <source>WINAPI::copyFile WINAPI::createFile WINAPI::deleteFile WINAPI::fileExists</source>
        </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`File`</ph> <ph id="ph2">`FileAttributes`</ph> <ph id="ph3">`FileInfo`</ph></source>
        </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve">
          <source>X++ can use static methods in the <ph id="ph1">`WINAPI`</ph> class for many basic operating system functions that involve files.</source>
        </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`CommaIo`</ph> <ph id="ph2">`Comma7Io`</ph></source>
        </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve">
          <source>(No corresponding class.)</source>
        </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve">
          <source>These X++ classes can generate files that Microsoft Excel can import.</source>
        </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve">
          <source>In X++ an <bpt id="p1">&lt;a href="http://epplus.codeplex.com/"&gt;</bpt>EPPlus<ept id="p1">&lt;/a&gt;</ept> library reference is available for additional interaction with Excel.</source>
        </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`AsciiIo`</ph> <ph id="ph2">`TextIo`</ph></source>
        </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`FileStream`</ph> <ph id="ph2">`TextReader`</ph> <ph id="ph3">`TextWriter`</ph></source>
        </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve">
          <source>These classes use different code pages.</source>
        </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`Stream`</ph> <ph id="ph2">`StreamReader`</ph> <ph id="ph3">`StreamWriter`</ph> <ph id="ph4">`FileStream`</ph></source>
        </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve">
          <source>These are often used as base classes that other classes extend.</source>
        </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`CodeAccessPermission`</ph> <ph id="ph2">`FileIoPermission`</ph></source>
        </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`System.Security`</ph> <ph id="ph2">`.CodeAccessPermission`</ph> The namespace <ph id="ph3">`System.Security.Permissions`</ph> includes the following classes:</source>
        </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve">
          <source>The concepts and methods of <ph id="ph1">`assert`</ph>, <ph id="ph2">`demand`</ph>, and <ph id="ph3">`revertAssert`</ph> apply to both languages.</source>
        </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve">
          <source>However, the <ph id="ph1">`deny`</ph> and <ph id="ph2">`revertDeny`</ph> methods that are available in C# are not available in X++.</source>
        </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve">
          <source>X++, ANSI SQL Comparison: SQL Select</source>
        </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve">
          <source>In X++, the SQL <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement syntax differs from the American National Standards Institute (ANSI) specification.</source>
        </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve">
          <source>Single Table Select</source>
        </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve">
          <source>The following table lists differences between the select statements of X++ SQL and ANSI SQL.</source>
        </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve">
          <source>Feature</source>
        </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve">
          <source>X++ SQL</source>
        </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve">
          <source>ANSI SQL</source>
        </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve">
          <source>Table name on the <bpt id="p1">&lt;strong&gt;</bpt>from<ept id="p1">&lt;/strong&gt;</ept> clause.</source>
        </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>from<ept id="p1">&lt;/strong&gt;</ept> clause lists a record buffer instance that is declared from a table, such as from the <ph id="ph1">`CustTable`</ph> table.</source>
        </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>from<ept id="p1">&lt;/strong&gt;</ept> clause lists a table name, not the name of a buffer.</source>
        </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve">
          <source>The record buffer has all the methods that the <ph id="ph1">`xRecord`</ph>class has in X++.</source>
        </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve">
          <source>Syntax sequence of the order by versus <bpt id="p1">&lt;strong&gt;</bpt>where<ept id="p1">&lt;/strong&gt;</ept> clauses.</source>
        </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve">
          <source>The order by clause must appear before the <bpt id="p1">&lt;strong&gt;</bpt>where<ept id="p1">&lt;/strong&gt;</ept> clause.</source>
        </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve">
          <source>The order by clause must appear after the <bpt id="p1">&lt;strong&gt;</bpt>from<ept id="p1">&lt;/strong&gt;</ept> or <bpt id="p2">&lt;strong&gt;</bpt>join<ept id="p2">&lt;/strong&gt;</ept> clause.</source>
        </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve">
          <source>The group by clause must follow the same syntax positioning rules that the order by follows.</source>
        </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve">
          <source>The order by clause must appear after the <bpt id="p1">&lt;strong&gt;</bpt>where<ept id="p1">&lt;/strong&gt;</ept> clause.</source>
        </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>where<ept id="p1">&lt;/strong&gt;</ept> clause must appear after the <bpt id="p2">&lt;strong&gt;</bpt>from<ept id="p2">&lt;/strong&gt;</ept> or <bpt id="p3">&lt;strong&gt;</bpt>join<ept id="p3">&lt;/strong&gt;</ept> clause.</source>
        </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve">
          <source>In both X++ and ANSI SQL, the <bpt id="p1">&lt;strong&gt;</bpt>from<ept id="p1">&lt;/strong&gt;</ept> and <bpt id="p2">&lt;strong&gt;</bpt>join<ept id="p2">&lt;/strong&gt;</ept> clauses must appear before the order by and <bpt id="p3">&lt;strong&gt;</bpt>where<ept id="p3">&lt;/strong&gt;</ept> clauses.</source>
        </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve">
          <source>Condition negation.</source>
        </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve">
          <source>The exclamation mark ('!') is used for negation.</source>
        </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;strong&gt;</bpt>not<ept id="p1">&lt;/strong&gt;</ept> keyword is used for negation.</source>
        </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve">
          <source>X++ does not support the syntax !like.</source>
        </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve">
          <source>Instead, you must apply the !</source>
        </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve">
          <source>operator to a clause.</source>
        </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve">
          <source>Wildcard characters for the <bpt id="p1">&lt;strong&gt;</bpt>like<ept id="p1">&lt;/strong&gt;</ept> operator.</source>
        </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve">
          <source>0 to many  Asterisk ('*')</source>
        </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve">
          <source>Exactly 1  Question mark ('?')</source>
        </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve">
          <source>0 to many  Percent sign ('%')</source>
        </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve">
          <source>Exactly 1  Underbar ('_')</source>
        </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve">
          <source>Logical operators in the <bpt id="p1">&lt;strong&gt;</bpt>where<ept id="p1">&lt;/strong&gt;</ept> clause.</source>
        </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve">
          <source>And  &amp;&amp;</source>
        </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve">
          <source>Or  \</source>
        </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve">
          <source>And  <bpt id="p1">&lt;strong&gt;</bpt>and<ept id="p1">&lt;/strong&gt;</ept></source>
        </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve">
          <source>Or  <bpt id="p1">&lt;strong&gt;</bpt>or<ept id="p1">&lt;/strong&gt;</ept></source>
        </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve">
          <source>Code Example</source>
        </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve">
          <source>The following code example illustrates features in the previous table.</source>
        </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve">
          <source>X++ SQL Keywords</source>
        </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve">
          <source>The following X++ SQL keywords are among those that are not part of ANSI SQL:</source>
        </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve">
          <source>crosscompany</source>
        </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve">
          <source>firstonly100</source>
        </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve">
          <source>forceliterals</source>
        </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve">
          <source>forcenestedloop</source>
        </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve">
          <source>forceplaceholders</source>
        </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve">
          <source>forceselectorder</source>
        </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve">
          <source>validtimestate</source>
        </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve">
          <source>Join Clause</source>
        </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve">
          <source>The following table lists differences about the <bpt id="p1">**</bpt>join<ept id="p1">**</ept> keyword of X++ SQL and ANSI SQL.</source>
        </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve">
          <source>Feature</source>
        </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve">
          <source>X++ SQL</source>
        </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve">
          <source>ANSI SQL</source>
        </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve">
          <source>Columns list.</source>
        </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve">
          <source>The columns in the columns list must all come from the table listed in the <bpt id="p1">**</bpt>from<ept id="p1">**</ept> clause, and not from any table in a <bpt id="p2">**</bpt>join<ept id="p2">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve">
          <source>Columns in the list cannot be qualified by their table name.</source>
        </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve">
          <source>The columns in the columns list can come from any table in the <bpt id="p1">**</bpt>from<ept id="p1">**</ept> or <bpt id="p2">**</bpt>join<ept id="p2">**</ept> clauses.</source>
        </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve">
          <source>It helps others to maintain your code when you qualify the columns in the list with their table name.</source>
        </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve">
          <source>For more information, see Select Statements on Fields.</source>
        </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Join<ept id="p1">**</ept> clause syntax.</source>
        </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>join<ept id="p1">**</ept> clause follows the <bpt id="p2">**</bpt>where<ept id="p2">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>join<ept id="p1">**</ept> clause follows a table in the <bpt id="p2">**</bpt>from<ept id="p2">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve">
          <source>In the X++ code example, the <bpt id="p1">**</bpt>join<ept id="p1">**</ept> criteria is an equality of <ph id="ph1">`SalesPoolId`</ph> values.</source>
        </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Inner<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve">
          <source>The default <bpt id="p1">**</bpt>join<ept id="p1">**</ept> mode is inner join.</source>
        </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve">
          <source>There is no <bpt id="p1">**</bpt>inner<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve">
          <source>The default <bpt id="p1">**</bpt>join<ept id="p1">**</ept> mode is inner join.</source>
        </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>inner<ept id="p1">**</ept> keyword is available to make the code explicit.</source>
        </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>outer<ept id="p1">**</ept> keyword exists in both X++ SQL and ANSI SQL.</source>
        </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Left<ept id="p1">**</ept> and <bpt id="p2">**</bpt>right<ept id="p2">**</ept> keywords.</source>
        </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>left<ept id="p1">**</ept> and <bpt id="p2">**</bpt>right<ept id="p2">**</ept> keywords are not available.</source>
        </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve">
          <source>All joins are left.</source>
        </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>left<ept id="p1">**</ept> and <bpt id="p2">**</bpt>right<ept id="p2">**</ept> keywords are available to modify the <bpt id="p3">**</bpt>join<ept id="p3">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve">
          <source>No comments.</source>
        </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve">
          <source>Equality operator.</source>
        </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve">
          <source>The double equal sign operator ('<ph id="ph1">`==`</ph>') is used to test for the equality of two values.</source>
        </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve">
          <source>The single equal sign operator ('<ph id="ph1">`=`</ph>') is used to test for the equality of two values.</source>
        </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve">
          <source>No comments.</source>
        </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve">
          <source>Code Example</source>
        </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve">
          <source>The following code example illustrates the <bpt id="p1">**</bpt>join<ept id="p1">**</ept> syntax in X++ SQL.</source>
        </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve">
          <source>Aggregate Fields</source>
        </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve">
          <source>The following table lists some differences in how aggregate fields in the <bpt id="p1">**</bpt>select<ept id="p1">**</ept> column list are referenced between X++ SQL and ANSI SQL.</source>
        </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve">
          <source>Aggregate fields are those that are derived by functions such as <bpt id="p1">**</bpt>sum<ept id="p1">**</ept> or <bpt id="p2">**</bpt>avg<ept id="p2">**</ept>.</source>
        </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve">
          <source>Feature</source>
        </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve">
          <source>X++ SQL</source>
        </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve">
          <source>ANSI SQL</source>
        </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve">
          <source>Aggregate field name alias.</source>
        </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve">
          <source>The aggregate value is in the field that was aggregated.</source>
        </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve">
          <source>You can use the <bpt id="p1">**</bpt>as<ept id="p1">**</ept> keyword to tag an aggregate field with a name alias.</source>
        </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve">
          <source>The alias can be referenced in subsequent code.</source>
        </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve">
          <source>For more information, see Aggregate Functions: Differences Between X++ and SQL</source>
        </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve">
          <source>Code Example</source>
        </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve">
          <source>In the following code example, the call to the info method illustrates the way to reference aggregate fields (see <ph id="ph1">`tPurchLine.QtyOrdered`</ph>).</source>
        </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve">
          <source>Other Differences</source>
        </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve">
          <source>The following table lists other differences of the <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement between the X++ SQL and ANSI SQL.</source>
        </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve">
          <source>Feature</source>
        </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve">
          <source>X++ SQL</source>
        </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve">
          <source>ANSI SQL</source>
        </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>having<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve">
          <source>There is no <bpt id="p1">**</bpt>having<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>having<ept id="p1">**</ept> keyword enables you to specify filter criteria for rows that are generated by the group by clause.</source>
        </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve">
          <source>No comments.</source>
        </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve">
          <source>Null results.</source>
        </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve">
          <source>In a <bpt id="p1">**</bpt>while<ept id="p1">**</ept> select statement, if the <bpt id="p2">**</bpt>where<ept id="p2">**</ept> clause filters out all rows, no special count row is returned to report that.</source>
        </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve">
          <source>In a <bpt id="p1">**</bpt>select<ept id="p1">**</ept>, if the <bpt id="p2">**</bpt>where<ept id="p2">**</ept> clause filters out all rows, a special count row is returned.</source>
        </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve">
          <source>The count value is 0.</source>
        </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve">
          <source>No comments.</source>
        </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve">
          <source>Cursors for navigating returned rows.</source>
        </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve">
          <source>The while select statement provides cursor functionality.</source>
        </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve">
          <source>The alternative is to use the <bpt id="p1">**</bpt>next<ept id="p1">**</ept> keyword.</source>
        </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve">
          <source>You can declare a <bpt id="p1">**</bpt>cursor<ept id="p1">**</ept> for looping through the rows that are returned from a <bpt id="p2">**</bpt>select<ept id="p2">**</ept> statement.</source>
        </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>From<ept id="p1">**</ept> clause.</source>
        </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>from<ept id="p1">**</ept> keyword is optional when no columns are listed and only one table is referenced.</source>
        </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve">
          <source>The following two syntax options are equivalent:</source>
        </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement cannot read from a table unless the <bpt id="p2">**</bpt>from<ept id="p2">**</ept> clause is used.</source>
        </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve">
          <source>In X++ SQL, the simple <bpt id="p1">**</bpt>select<ept id="p1">**</ept> statement fills the table buffer variable with the first row that was returned.</source>
        </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve">
          <source>This is illustrated by the following code fragment:</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>