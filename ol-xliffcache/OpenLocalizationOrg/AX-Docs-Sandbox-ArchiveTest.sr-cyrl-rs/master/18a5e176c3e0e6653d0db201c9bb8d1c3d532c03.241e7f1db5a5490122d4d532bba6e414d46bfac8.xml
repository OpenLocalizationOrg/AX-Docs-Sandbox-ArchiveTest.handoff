{"content":"---\n# required metadata\n\ntitle: EventHandlerResult classes in request or response scenarios\ndescription: This topic describes how to use EventHandlerResult classes with delegate methods.\nauthor: RobinARH\nmanager: AnnBe\nms.date: 06/20/2017\nms.topic: article\nms.prod: \nms.service: dynamics-ax-platform\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \nms.reviewer: robinr\nms.search.scope: AX 7.0.0, Operations, UnifiedOperations\n# ms.tgt_pltfrm: \n# ms.custom: \nms.assetid: 3b2a9b85-f779-4358-b347-7b11a8e7960c\nms.search.region: Global\n# ms.search.industry: \nms.author: robinr\nms.search.validFrom: 2016-02-28\nms.dyn365.ops.version: AX 7.0.0\n\n---\n\n# EventHandlerResult classes in request or response scenarios\n\n[!include[banner](../includes/banner.md)]\n\n\nDelegate methods and delegate handler methods can be declared to support a request/response scenario, where the delegate calling logic requests the subscribers to provide a response. To support this scenario the **EventHandlerResult** class is most often passed as a parameter, and the delegate handler methods provide their result using one of the result methods on the class. However, the **EventHandlerResult** class can only contain a single result, so if multiple subscribers provide their individual result, the last respondent wins, and the results from the previous subscribers are overwritten.\n\nBefore the functionality described in this topic was introduced (platform update 5), there was no mechanism to ensure that, at most, a single subscriber provided a result, and that no results were lost if there were multiple subscribers.\n\n## Ensuring, at most, one response\n\nIn platform update 5, the **EventHandlerResult** class has an additional static constructor which ensures that the logic fails if more than one subscriber provides a result. The new constructor is named **newSingleResponse**. When instantiating an **EventHandlerResult** object using this method, the framework will throw an exception as soon as a second delegate handler method attempts to provide a result.\n\n    EventHandlerResult result = EventHandlerResult::newSingleResponse();\n    this.validateWarehouseTypeDelegate(this.WarehouseType, result);\n\n## IEventHandlerResultValidator interface\n\nThe validation in the **EventHandlerResult** class is handled by injecting an object of a type that implements the **IEventHandlerResultValidator** interface. When instantiating the **EventHandlerResult** object using the **newSingleResponse** static constructor, an **EventHandlerSingleResponseValidator** object is instantiated and injected into the **EventHandlerResult** object, and the injected object becomes responsible for validating any result provided to the **EventhandlerResult** object. Other validation classes can be implemented by having the class implement the **IEventHandlerResultValidator **interface, and injecting it into the **EventHandlerResult** class by instantiating the **EventHandlerResult** object using another new static constructor named **newWithResultValidator**. The constructor takes an argument of type **IEventHandlerResultValidator**, which makes it possible to inject any validator object as long as it implements the **IEventHandlerResultValidator **interface**.**\n\nFor example, the <strong>newSingleResponse</strong> static constructor simply delegates the instantiation to the **newWithResultValidator** static constructor like this.\n\n    return EventHandlerResult::newWithResultValidator(EventHandlerSingleResponseValidator::construct());\n    \n# Accept and reject request/response scenarios\n\nIn certain request/response scenarios, the subscriber is only expected to provide their acceptance or rejection. Using the **EventHandlerResult** class to request acceptance/rejection can be confusing, if the subscriber is only expected to respond with a Boolean value. In a validation scenario, for example, should the subscriber only respond with Boolean false, when validation fails, or should the subscriber also respond with Boolean true, if validation succeeds? If the response is gathered using an **EventHandlerResult** object, then the second subscriber that validates and replies with Boolean true, might overwrite the Boolean false from the first subscriber.\n\nTo mitigate this confusion, two new result type classes have been introduced in platform update 5: **EventHandlerAcceptResult** and **EventHandlerRejectResult**.\n\nWhen using the **EventHandlerAcceptResult** class, the delegate handler method can only respond by calling the **accept** method. When using the **EventHandlerRejectResult** class, only the **reject** method can be called.\n\n    [SubscribesTo(tableStr(InventWarehouseEntity), delegateStr(InventWarehouseEntity, validateWarehouseTypeDelegate))]\n    public static void validateWarehouseTypeIsSupportedStandardDelegateHandler(\n        InventLocationType _inventLocationType, \n        EventHandlerAcceptResult _result)\n    {\n        switch (_inventLocationType)\n        {\n            case InventLocationType::Standard: \n            case InventLocationType::Quarantine: \n            case InventLocationType::Transit: \n                _result.accept(); \n                break; \n        }     \n    }\n\nThe two new classes also contain a **newSingleResponse** static constructor for use in scenarios where, at most, one subscriber is allowed to respond with their rejection or acceptance. Whether any subscriber has responded can still be answered by querying the <strong>hasResult</strong> method, and the acceptance/rejection is queried by calling either the **isAccepted** or **isRejected** methods for the **EventHandlerAcceptResult **and** EventHandlerRejectResult **classes, respectively.\n\n    boolean ret = false;\n    EventHandlerAcceptResult result = EventHandlerAcceptResult::newSingleResponse(); \n    this.validateWarehouseTypeDelegate(this.WarehouseType, result);\n    if (result.hasResult())\n    {\n        ret = result.isAccepted();\n    }\n\n\n","nodes":[{"pos":[4,691],"embed":true,"restype":"x-metadata","content":"# required metadata\n\ntitle: EventHandlerResult classes in request or response scenarios\ndescription: This topic describes how to use EventHandlerResult classes with delegate methods.\nauthor: RobinARH\nmanager: AnnBe\nms.date: 06/20/2017\nms.topic: article\nms.prod: \nms.service: dynamics-ax-platform\nms.technology: \n\n# optional metadata\n\n# ms.search.form: \n# ROBOTS: \naudience: Developer\n# ms.devlang: \nms.reviewer: robinr\nms.search.scope: AX 7.0.0, Operations, UnifiedOperations\n# ms.tgt_pltfrm: \n# ms.custom: \nms.assetid: 3b2a9b85-f779-4358-b347-7b11a8e7960c\nms.search.region: Global\n# ms.search.industry: \nms.author: robinr\nms.search.validFrom: 2016-02-28\nms.dyn365.ops.version: AX 7.0.0\n","nodes":[{"content":"EventHandlerResult classes in request or response scenarios","nodes":[{"pos":[0,59],"content":"EventHandlerResult classes in request or response scenarios","nodes":[{"content":"EventHandlerResult classes in request or response scenarios","pos":[0,59]}]}],"path":["title"],"extradata":"MT"},{"content":"This topic describes how to use EventHandlerResult classes with delegate methods.","nodes":[{"pos":[0,81],"content":"This topic describes how to use EventHandlerResult classes with delegate methods.","nodes":[{"content":"This topic describes how to use EventHandlerResult classes with delegate methods.","pos":[0,81]}]}],"path":["description"],"extradata":"MT"}],"header":"# required metadata\n","yml":true},{"pos":[699,758],"content":"EventHandlerResult classes in request or response scenarios","linkify":"EventHandlerResult classes in request or response scenarios","nodes":[{"content":"EventHandlerResult classes in request or response scenarios","pos":[0,59]}]},{"content":"Delegate methods and delegate handler methods can be declared to support a request/response scenario, where the delegate calling logic requests the subscribers to provide a response.","pos":[804,986]},{"content":"To support this scenario the <bpt id=\"p1\">**</bpt>EventHandlerResult<ept id=\"p1\">**</ept> class is most often passed as a parameter, and the delegate handler methods provide their result using one of the result methods on the class.","pos":[987,1181],"source":" To support this scenario the **EventHandlerResult** class is most often passed as a parameter, and the delegate handler methods provide their result using one of the result methods on the class."},{"content":"However, the <bpt id=\"p1\">**</bpt>EventHandlerResult<ept id=\"p1\">**</ept> class can only contain a single result, so if multiple subscribers provide their individual result, the last respondent wins, and the results from the previous subscribers are overwritten.","pos":[1182,1406],"source":" However, the **EventHandlerResult** class can only contain a single result, so if multiple subscribers provide their individual result, the last respondent wins, and the results from the previous subscribers are overwritten."},{"content":"Before the functionality described in this topic was introduced (platform update 5), there was no mechanism to ensure that, at most, a single subscriber provided a result, and that no results were lost if there were multiple subscribers.","pos":[1408,1645]},{"pos":[1650,1681],"content":"Ensuring, at most, one response","linkify":"Ensuring, at most, one response","nodes":[{"content":"Ensuring, at most, one response","pos":[0,31]}]},{"content":"In platform update 5, the <bpt id=\"p1\">**</bpt>EventHandlerResult<ept id=\"p1\">**</ept> class has an additional static constructor which ensures that the logic fails if more than one subscriber provides a result.","pos":[1683,1856],"source":"In platform update 5, the **EventHandlerResult** class has an additional static constructor which ensures that the logic fails if more than one subscriber provides a result."},{"content":"The new constructor is named <bpt id=\"p1\">**</bpt>newSingleResponse<ept id=\"p1\">**</ept>.","pos":[1857,1908],"source":" The new constructor is named **newSingleResponse**."},{"content":"When instantiating an <bpt id=\"p1\">**</bpt>EventHandlerResult<ept id=\"p1\">**</ept> object using this method, the framework will throw an exception as soon as a second delegate handler method attempts to provide a result.","pos":[1909,2091],"source":" When instantiating an **EventHandlerResult** object using this method, the framework will throw an exception as soon as a second delegate handler method attempts to provide a result."},{"pos":[2238,2276],"content":"IEventHandlerResultValidator interface","linkify":"IEventHandlerResultValidator interface","nodes":[{"content":"IEventHandlerResultValidator interface","pos":[0,38]}]},{"content":"The validation in the <bpt id=\"p1\">**</bpt>EventHandlerResult<ept id=\"p1\">**</ept> class is handled by injecting an object of a type that implements the <bpt id=\"p2\">**</bpt>IEventHandlerResultValidator<ept id=\"p2\">**</ept> interface.","pos":[2278,2436],"source":"The validation in the **EventHandlerResult** class is handled by injecting an object of a type that implements the **IEventHandlerResultValidator** interface."},{"content":"When instantiating the <bpt id=\"p1\">**</bpt>EventHandlerResult<ept id=\"p1\">**</ept> object using the <bpt id=\"p2\">**</bpt>newSingleResponse<ept id=\"p2\">**</ept> static constructor, an <bpt id=\"p3\">**</bpt>EventHandlerSingleResponseValidator<ept id=\"p3\">**</ept> object is instantiated and injected into the <bpt id=\"p4\">**</bpt>EventHandlerResult<ept id=\"p4\">**</ept> object, and the injected object becomes responsible for validating any result provided to the <bpt id=\"p5\">**</bpt>EventhandlerResult<ept id=\"p5\">**</ept> object.","pos":[2437,2777],"source":" When instantiating the **EventHandlerResult** object using the **newSingleResponse** static constructor, an **EventHandlerSingleResponseValidator** object is instantiated and injected into the **EventHandlerResult** object, and the injected object becomes responsible for validating any result provided to the **EventhandlerResult** object."},{"content":"Other validation classes can be implemented by having the class implement the **IEventHandlerResultValidator **interface, and injecting it into the <bpt id=\"p1\">**</bpt>EventHandlerResult<ept id=\"p1\">**</ept> class by instantiating the <bpt id=\"p2\">**</bpt>EventHandlerResult<ept id=\"p2\">**</ept> object using another new static constructor named <bpt id=\"p3\">**</bpt>newWithResultValidator<ept id=\"p3\">**</ept>.","pos":[2778,3076],"source":" Other validation classes can be implemented by having the class implement the **IEventHandlerResultValidator **interface, and injecting it into the **EventHandlerResult** class by instantiating the **EventHandlerResult** object using another new static constructor named **newWithResultValidator**."},{"content":"The constructor takes an argument of type <bpt id=\"p1\">**</bpt>IEventHandlerResultValidator<ept id=\"p1\">**</ept>, which makes it possible to inject any validator object as long as it implements the <bpt id=\"p2\">**</bpt>IEventHandlerResultValidator <bpt id=\"p3\">**</bpt>interface<ept id=\"p3\">**</ept>.<ept id=\"p2\">**</ept>","pos":[3077,3284],"source":" The constructor takes an argument of type **IEventHandlerResultValidator**, which makes it possible to inject any validator object as long as it implements the **IEventHandlerResultValidator **interface**.**"},{"pos":[3286,3455],"content":"For example, the <bpt id=\"p1\">&lt;strong&gt;</bpt>newSingleResponse<ept id=\"p1\">&lt;/strong&gt;</ept> static constructor simply delegates the instantiation to the <bpt id=\"p2\">**</bpt>newWithResultValidator<ept id=\"p2\">**</ept> static constructor like this.","source":"For example, the <strong>newSingleResponse</strong> static constructor simply delegates the instantiation to the **newWithResultValidator** static constructor like this."},{"pos":[3569,3613],"content":"Accept and reject request/response scenarios","linkify":"Accept and reject request/response scenarios","nodes":[{"content":"Accept and reject request/response scenarios","pos":[0,44]}]},{"content":"In certain request/response scenarios, the subscriber is only expected to provide their acceptance or rejection.","pos":[3615,3727]},{"content":"Using the <bpt id=\"p1\">**</bpt>EventHandlerResult<ept id=\"p1\">**</ept> class to request acceptance/rejection can be confusing, if the subscriber is only expected to respond with a Boolean value.","pos":[3728,3884],"source":" Using the **EventHandlerResult** class to request acceptance/rejection can be confusing, if the subscriber is only expected to respond with a Boolean value."},{"content":"In a validation scenario, for example, should the subscriber only respond with Boolean false, when validation fails, or should the subscriber also respond with Boolean true, if validation succeeds?","pos":[3885,4082]},{"content":"If the response is gathered using an <bpt id=\"p1\">**</bpt>EventHandlerResult<ept id=\"p1\">**</ept> object, then the second subscriber that validates and replies with Boolean true, might overwrite the Boolean false from the first subscriber.","pos":[4083,4284],"source":" If the response is gathered using an **EventHandlerResult** object, then the second subscriber that validates and replies with Boolean true, might overwrite the Boolean false from the first subscriber."},{"pos":[4286,4447],"content":"To mitigate this confusion, two new result type classes have been introduced in platform update 5: <bpt id=\"p1\">**</bpt>EventHandlerAcceptResult<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>EventHandlerRejectResult<ept id=\"p2\">**</ept>.","source":"To mitigate this confusion, two new result type classes have been introduced in platform update 5: **EventHandlerAcceptResult** and **EventHandlerRejectResult**."},{"content":"When using the <bpt id=\"p1\">**</bpt>EventHandlerAcceptResult<ept id=\"p1\">**</ept> class, the delegate handler method can only respond by calling the <bpt id=\"p2\">**</bpt>accept<ept id=\"p2\">**</ept> method.","pos":[4449,4578],"source":"When using the **EventHandlerAcceptResult** class, the delegate handler method can only respond by calling the **accept** method."},{"content":"When using the <bpt id=\"p1\">**</bpt>EventHandlerRejectResult<ept id=\"p1\">**</ept> class, only the <bpt id=\"p2\">**</bpt>reject<ept id=\"p2\">**</ept> method can be called.","pos":[4579,4671],"source":" When using the **EventHandlerRejectResult** class, only the **reject** method can be called."},{"content":"The two new classes also contain a <bpt id=\"p1\">**</bpt>newSingleResponse<ept id=\"p1\">**</ept> static constructor for use in scenarios where, at most, one subscriber is allowed to respond with their rejection or acceptance.","pos":[5242,5427],"source":"The two new classes also contain a **newSingleResponse** static constructor for use in scenarios where, at most, one subscriber is allowed to respond with their rejection or acceptance."},{"content":"Whether any subscriber has responded can still be answered by querying the <bpt id=\"p1\">&lt;strong&gt;</bpt>hasResult<ept id=\"p1\">&lt;/strong&gt;</ept> method, and the acceptance/rejection is queried by calling either the <bpt id=\"p2\">**</bpt>isAccepted<ept id=\"p2\">**</ept> or <bpt id=\"p3\">**</bpt>isRejected<ept id=\"p3\">**</ept> methods for the **EventHandlerAcceptResult <bpt id=\"p4\">**</bpt>and<ept id=\"p4\">**</ept> EventHandlerRejectResult **classes, respectively.","pos":[5428,5733],"source":" Whether any subscriber has responded can still be answered by querying the <strong>hasResult</strong> method, and the acceptance/rejection is queried by calling either the **isAccepted** or **isRejected** methods for the **EventHandlerAcceptResult **and** EventHandlerRejectResult **classes, respectively."}]}